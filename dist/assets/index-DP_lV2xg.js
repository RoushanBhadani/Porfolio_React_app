var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var require_index_001 = __commonJS({
  "assets/index-DP_lV2xg.js"(exports, module) {
    (function polyfill() {
      const relList = document.createElement("link").relList;
      if (relList && relList.supports && relList.supports("modulepreload")) {
        return;
      }
      for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
        processPreload(link);
      }
      new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.type !== "childList") {
            continue;
          }
          for (const node of mutation.addedNodes) {
            if (node.tagName === "LINK" && node.rel === "modulepreload")
              processPreload(node);
          }
        }
      }).observe(document, { childList: true, subtree: true });
      function getFetchOpts(link) {
        const fetchOpts = {};
        if (link.integrity) fetchOpts.integrity = link.integrity;
        if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
        if (link.crossOrigin === "use-credentials")
          fetchOpts.credentials = "include";
        else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
        else fetchOpts.credentials = "same-origin";
        return fetchOpts;
      }
      function processPreload(link) {
        if (link.ep)
          return;
        link.ep = true;
        const fetchOpts = getFetchOpts(link);
        fetch(link.href, fetchOpts);
      }
    })();
    function getDefaultExportFromCjs(x) {
      return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
    }
    var jsxRuntime = { exports: {} };
    var reactJsxRuntime_production_min = {};
    var react = { exports: {} };
    var react_production_min = {};
    /**
     * @license React
     * react.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var hasRequiredReact_production_min;
    function requireReact_production_min() {
      if (hasRequiredReact_production_min) return react_production_min;
      hasRequiredReact_production_min = 1;
      var l = Symbol.for("react.element"), n = Symbol.for("react.portal"), p = Symbol.for("react.fragment"), q = Symbol.for("react.strict_mode"), r = Symbol.for("react.profiler"), t = Symbol.for("react.provider"), u = Symbol.for("react.context"), v = Symbol.for("react.forward_ref"), w = Symbol.for("react.suspense"), x = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), z = Symbol.iterator;
      function A(a) {
        if (null === a || "object" !== typeof a) return null;
        a = z && a[z] || a["@@iterator"];
        return "function" === typeof a ? a : null;
      }
      var B = { isMounted: function() {
        return false;
      }, enqueueForceUpdate: function() {
      }, enqueueReplaceState: function() {
      }, enqueueSetState: function() {
      } }, C = Object.assign, D = {};
      function E(a, b, e) {
        this.props = a;
        this.context = b;
        this.refs = D;
        this.updater = e || B;
      }
      E.prototype.isReactComponent = {};
      E.prototype.setState = function(a, b) {
        if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, a, b, "setState");
      };
      E.prototype.forceUpdate = function(a) {
        this.updater.enqueueForceUpdate(this, a, "forceUpdate");
      };
      function F() {
      }
      F.prototype = E.prototype;
      function G(a, b, e) {
        this.props = a;
        this.context = b;
        this.refs = D;
        this.updater = e || B;
      }
      var H = G.prototype = new F();
      H.constructor = G;
      C(H, E.prototype);
      H.isPureReactComponent = true;
      var I = Array.isArray, J = Object.prototype.hasOwnProperty, K = { current: null }, L = { key: true, ref: true, __self: true, __source: true };
      function M(a, b, e) {
        var d, c = {}, k = null, h = null;
        if (null != b) for (d in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b) J.call(b, d) && !L.hasOwnProperty(d) && (c[d] = b[d]);
        var g = arguments.length - 2;
        if (1 === g) c.children = e;
        else if (1 < g) {
          for (var f = Array(g), m = 0; m < g; m++) f[m] = arguments[m + 2];
          c.children = f;
        }
        if (a && a.defaultProps) for (d in g = a.defaultProps, g) void 0 === c[d] && (c[d] = g[d]);
        return { $$typeof: l, type: a, key: k, ref: h, props: c, _owner: K.current };
      }
      function N(a, b) {
        return { $$typeof: l, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
      }
      function O(a) {
        return "object" === typeof a && null !== a && a.$$typeof === l;
      }
      function escape(a) {
        var b = { "=": "=0", ":": "=2" };
        return "$" + a.replace(/[=:]/g, function(a2) {
          return b[a2];
        });
      }
      var P = /\/+/g;
      function Q(a, b) {
        return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
      }
      function R(a, b, e, d, c) {
        var k = typeof a;
        if ("undefined" === k || "boolean" === k) a = null;
        var h = false;
        if (null === a) h = true;
        else switch (k) {
          case "string":
          case "number":
            h = true;
            break;
          case "object":
            switch (a.$$typeof) {
              case l:
              case n:
                h = true;
            }
        }
        if (h) return h = a, c = c(h), a = "" === d ? "." + Q(h, 0) : d, I(c) ? (e = "", null != a && (e = a.replace(P, "$&/") + "/"), R(c, b, e, "", function(a2) {
          return a2;
        })) : null != c && (O(c) && (c = N(c, e + (!c.key || h && h.key === c.key ? "" : ("" + c.key).replace(P, "$&/") + "/") + a)), b.push(c)), 1;
        h = 0;
        d = "" === d ? "." : d + ":";
        if (I(a)) for (var g = 0; g < a.length; g++) {
          k = a[g];
          var f = d + Q(k, g);
          h += R(k, b, e, f, c);
        }
        else if (f = A(a), "function" === typeof f) for (a = f.call(a), g = 0; !(k = a.next()).done; ) k = k.value, f = d + Q(k, g++), h += R(k, b, e, f, c);
        else if ("object" === k) throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
        return h;
      }
      function S(a, b, e) {
        if (null == a) return a;
        var d = [], c = 0;
        R(a, d, "", "", function(a2) {
          return b.call(e, a2, c++);
        });
        return d;
      }
      function T(a) {
        if (-1 === a._status) {
          var b = a._result;
          b = b();
          b.then(function(b2) {
            if (0 === a._status || -1 === a._status) a._status = 1, a._result = b2;
          }, function(b2) {
            if (0 === a._status || -1 === a._status) a._status = 2, a._result = b2;
          });
          -1 === a._status && (a._status = 0, a._result = b);
        }
        if (1 === a._status) return a._result.default;
        throw a._result;
      }
      var U = { current: null }, V = { transition: null }, W = { ReactCurrentDispatcher: U, ReactCurrentBatchConfig: V, ReactCurrentOwner: K };
      function X() {
        throw Error("act(...) is not supported in production builds of React.");
      }
      react_production_min.Children = { map: S, forEach: function(a, b, e) {
        S(a, function() {
          b.apply(this, arguments);
        }, e);
      }, count: function(a) {
        var b = 0;
        S(a, function() {
          b++;
        });
        return b;
      }, toArray: function(a) {
        return S(a, function(a2) {
          return a2;
        }) || [];
      }, only: function(a) {
        if (!O(a)) throw Error("React.Children.only expected to receive a single React element child.");
        return a;
      } };
      react_production_min.Component = E;
      react_production_min.Fragment = p;
      react_production_min.Profiler = r;
      react_production_min.PureComponent = G;
      react_production_min.StrictMode = q;
      react_production_min.Suspense = w;
      react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
      react_production_min.act = X;
      react_production_min.cloneElement = function(a, b, e) {
        if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
        var d = C({}, a.props), c = a.key, k = a.ref, h = a._owner;
        if (null != b) {
          void 0 !== b.ref && (k = b.ref, h = K.current);
          void 0 !== b.key && (c = "" + b.key);
          if (a.type && a.type.defaultProps) var g = a.type.defaultProps;
          for (f in b) J.call(b, f) && !L.hasOwnProperty(f) && (d[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
        }
        var f = arguments.length - 2;
        if (1 === f) d.children = e;
        else if (1 < f) {
          g = Array(f);
          for (var m = 0; m < f; m++) g[m] = arguments[m + 2];
          d.children = g;
        }
        return { $$typeof: l, type: a.type, key: c, ref: k, props: d, _owner: h };
      };
      react_production_min.createContext = function(a) {
        a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
        a.Provider = { $$typeof: t, _context: a };
        return a.Consumer = a;
      };
      react_production_min.createElement = M;
      react_production_min.createFactory = function(a) {
        var b = M.bind(null, a);
        b.type = a;
        return b;
      };
      react_production_min.createRef = function() {
        return { current: null };
      };
      react_production_min.forwardRef = function(a) {
        return { $$typeof: v, render: a };
      };
      react_production_min.isValidElement = O;
      react_production_min.lazy = function(a) {
        return { $$typeof: y, _payload: { _status: -1, _result: a }, _init: T };
      };
      react_production_min.memo = function(a, b) {
        return { $$typeof: x, type: a, compare: void 0 === b ? null : b };
      };
      react_production_min.startTransition = function(a) {
        var b = V.transition;
        V.transition = {};
        try {
          a();
        } finally {
          V.transition = b;
        }
      };
      react_production_min.unstable_act = X;
      react_production_min.useCallback = function(a, b) {
        return U.current.useCallback(a, b);
      };
      react_production_min.useContext = function(a) {
        return U.current.useContext(a);
      };
      react_production_min.useDebugValue = function() {
      };
      react_production_min.useDeferredValue = function(a) {
        return U.current.useDeferredValue(a);
      };
      react_production_min.useEffect = function(a, b) {
        return U.current.useEffect(a, b);
      };
      react_production_min.useId = function() {
        return U.current.useId();
      };
      react_production_min.useImperativeHandle = function(a, b, e) {
        return U.current.useImperativeHandle(a, b, e);
      };
      react_production_min.useInsertionEffect = function(a, b) {
        return U.current.useInsertionEffect(a, b);
      };
      react_production_min.useLayoutEffect = function(a, b) {
        return U.current.useLayoutEffect(a, b);
      };
      react_production_min.useMemo = function(a, b) {
        return U.current.useMemo(a, b);
      };
      react_production_min.useReducer = function(a, b, e) {
        return U.current.useReducer(a, b, e);
      };
      react_production_min.useRef = function(a) {
        return U.current.useRef(a);
      };
      react_production_min.useState = function(a) {
        return U.current.useState(a);
      };
      react_production_min.useSyncExternalStore = function(a, b, e) {
        return U.current.useSyncExternalStore(a, b, e);
      };
      react_production_min.useTransition = function() {
        return U.current.useTransition();
      };
      react_production_min.version = "18.3.1";
      return react_production_min;
    }
    var hasRequiredReact;
    function requireReact() {
      if (hasRequiredReact) return react.exports;
      hasRequiredReact = 1;
      {
        react.exports = requireReact_production_min();
      }
      return react.exports;
    }
    /**
     * @license React
     * react-jsx-runtime.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var hasRequiredReactJsxRuntime_production_min;
    function requireReactJsxRuntime_production_min() {
      if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
      hasRequiredReactJsxRuntime_production_min = 1;
      var f = requireReact(), k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: true, ref: true, __self: true, __source: true };
      function q(c, a, g) {
        var b, d = {}, e = null, h = null;
        void 0 !== g && (e = "" + g);
        void 0 !== a.key && (e = "" + a.key);
        void 0 !== a.ref && (h = a.ref);
        for (b in a) m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
        if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
        return { $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current };
      }
      reactJsxRuntime_production_min.Fragment = l;
      reactJsxRuntime_production_min.jsx = q;
      reactJsxRuntime_production_min.jsxs = q;
      return reactJsxRuntime_production_min;
    }
    var hasRequiredJsxRuntime;
    function requireJsxRuntime() {
      if (hasRequiredJsxRuntime) return jsxRuntime.exports;
      hasRequiredJsxRuntime = 1;
      {
        jsxRuntime.exports = requireReactJsxRuntime_production_min();
      }
      return jsxRuntime.exports;
    }
    var jsxRuntimeExports = requireJsxRuntime();
    var reactExports = requireReact();
    const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
    var client = {};
    var reactDom = { exports: {} };
    var reactDom_production_min = {};
    var scheduler = { exports: {} };
    var scheduler_production_min = {};
    /**
     * @license React
     * scheduler.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var hasRequiredScheduler_production_min;
    function requireScheduler_production_min() {
      if (hasRequiredScheduler_production_min) return scheduler_production_min;
      hasRequiredScheduler_production_min = 1;
      (function(exports2) {
        function f(a, b) {
          var c = a.length;
          a.push(b);
          a: for (; 0 < c; ) {
            var d = c - 1 >>> 1, e = a[d];
            if (0 < g(e, b)) a[d] = b, a[c] = e, c = d;
            else break a;
          }
        }
        function h(a) {
          return 0 === a.length ? null : a[0];
        }
        function k(a) {
          if (0 === a.length) return null;
          var b = a[0], c = a.pop();
          if (c !== b) {
            a[0] = c;
            a: for (var d = 0, e = a.length, w = e >>> 1; d < w; ) {
              var m = 2 * (d + 1) - 1, C = a[m], n = m + 1, x = a[n];
              if (0 > g(C, c)) n < e && 0 > g(x, C) ? (a[d] = x, a[n] = c, d = n) : (a[d] = C, a[m] = c, d = m);
              else if (n < e && 0 > g(x, c)) a[d] = x, a[n] = c, d = n;
              else break a;
            }
          }
          return b;
        }
        function g(a, b) {
          var c = a.sortIndex - b.sortIndex;
          return 0 !== c ? c : a.id - b.id;
        }
        if ("object" === typeof performance && "function" === typeof performance.now) {
          var l = performance;
          exports2.unstable_now = function() {
            return l.now();
          };
        } else {
          var p = Date, q = p.now();
          exports2.unstable_now = function() {
            return p.now() - q;
          };
        }
        var r = [], t = [], u = 1, v = null, y = 3, z = false, A = false, B = false, D = "function" === typeof setTimeout ? setTimeout : null, E = "function" === typeof clearTimeout ? clearTimeout : null, F = "undefined" !== typeof setImmediate ? setImmediate : null;
        "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
        function G(a) {
          for (var b = h(t); null !== b; ) {
            if (null === b.callback) k(t);
            else if (b.startTime <= a) k(t), b.sortIndex = b.expirationTime, f(r, b);
            else break;
            b = h(t);
          }
        }
        function H(a) {
          B = false;
          G(a);
          if (!A) if (null !== h(r)) A = true, I(J);
          else {
            var b = h(t);
            null !== b && K(H, b.startTime - a);
          }
        }
        function J(a, b) {
          A = false;
          B && (B = false, E(L), L = -1);
          z = true;
          var c = y;
          try {
            G(b);
            for (v = h(r); null !== v && (!(v.expirationTime > b) || a && !M()); ) {
              var d = v.callback;
              if ("function" === typeof d) {
                v.callback = null;
                y = v.priorityLevel;
                var e = d(v.expirationTime <= b);
                b = exports2.unstable_now();
                "function" === typeof e ? v.callback = e : v === h(r) && k(r);
                G(b);
              } else k(r);
              v = h(r);
            }
            if (null !== v) var w = true;
            else {
              var m = h(t);
              null !== m && K(H, m.startTime - b);
              w = false;
            }
            return w;
          } finally {
            v = null, y = c, z = false;
          }
        }
        var N = false, O = null, L = -1, P = 5, Q = -1;
        function M() {
          return exports2.unstable_now() - Q < P ? false : true;
        }
        function R() {
          if (null !== O) {
            var a = exports2.unstable_now();
            Q = a;
            var b = true;
            try {
              b = O(true, a);
            } finally {
              b ? S() : (N = false, O = null);
            }
          } else N = false;
        }
        var S;
        if ("function" === typeof F) S = function() {
          F(R);
        };
        else if ("undefined" !== typeof MessageChannel) {
          var T = new MessageChannel(), U = T.port2;
          T.port1.onmessage = R;
          S = function() {
            U.postMessage(null);
          };
        } else S = function() {
          D(R, 0);
        };
        function I(a) {
          O = a;
          N || (N = true, S());
        }
        function K(a, b) {
          L = D(function() {
            a(exports2.unstable_now());
          }, b);
        }
        exports2.unstable_IdlePriority = 5;
        exports2.unstable_ImmediatePriority = 1;
        exports2.unstable_LowPriority = 4;
        exports2.unstable_NormalPriority = 3;
        exports2.unstable_Profiling = null;
        exports2.unstable_UserBlockingPriority = 2;
        exports2.unstable_cancelCallback = function(a) {
          a.callback = null;
        };
        exports2.unstable_continueExecution = function() {
          A || z || (A = true, I(J));
        };
        exports2.unstable_forceFrameRate = function(a) {
          0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < a ? Math.floor(1e3 / a) : 5;
        };
        exports2.unstable_getCurrentPriorityLevel = function() {
          return y;
        };
        exports2.unstable_getFirstCallbackNode = function() {
          return h(r);
        };
        exports2.unstable_next = function(a) {
          switch (y) {
            case 1:
            case 2:
            case 3:
              var b = 3;
              break;
            default:
              b = y;
          }
          var c = y;
          y = b;
          try {
            return a();
          } finally {
            y = c;
          }
        };
        exports2.unstable_pauseExecution = function() {
        };
        exports2.unstable_requestPaint = function() {
        };
        exports2.unstable_runWithPriority = function(a, b) {
          switch (a) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
              break;
            default:
              a = 3;
          }
          var c = y;
          y = a;
          try {
            return b();
          } finally {
            y = c;
          }
        };
        exports2.unstable_scheduleCallback = function(a, b, c) {
          var d = exports2.unstable_now();
          "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
          switch (a) {
            case 1:
              var e = -1;
              break;
            case 2:
              e = 250;
              break;
            case 5:
              e = 1073741823;
              break;
            case 4:
              e = 1e4;
              break;
            default:
              e = 5e3;
          }
          e = c + e;
          a = { id: u++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 };
          c > d ? (a.sortIndex = c, f(t, a), null === h(r) && a === h(t) && (B ? (E(L), L = -1) : B = true, K(H, c - d))) : (a.sortIndex = e, f(r, a), A || z || (A = true, I(J)));
          return a;
        };
        exports2.unstable_shouldYield = M;
        exports2.unstable_wrapCallback = function(a) {
          var b = y;
          return function() {
            var c = y;
            y = b;
            try {
              return a.apply(this, arguments);
            } finally {
              y = c;
            }
          };
        };
      })(scheduler_production_min);
      return scheduler_production_min;
    }
    var hasRequiredScheduler;
    function requireScheduler() {
      if (hasRequiredScheduler) return scheduler.exports;
      hasRequiredScheduler = 1;
      {
        scheduler.exports = requireScheduler_production_min();
      }
      return scheduler.exports;
    }
    /**
     * @license React
     * react-dom.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var hasRequiredReactDom_production_min;
    function requireReactDom_production_min() {
      if (hasRequiredReactDom_production_min) return reactDom_production_min;
      hasRequiredReactDom_production_min = 1;
      var aa = requireReact(), ca = requireScheduler();
      function p(a) {
        for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);
        return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      var da = /* @__PURE__ */ new Set(), ea = {};
      function fa(a, b) {
        ha(a, b);
        ha(a + "Capture", b);
      }
      function ha(a, b) {
        ea[a] = b;
        for (a = 0; a < b.length; a++) da.add(b[a]);
      }
      var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
      function oa(a) {
        if (ja.call(ma, a)) return true;
        if (ja.call(la, a)) return false;
        if (ka.test(a)) return ma[a] = true;
        la[a] = true;
        return false;
      }
      function pa(a, b, c, d) {
        if (null !== c && 0 === c.type) return false;
        switch (typeof b) {
          case "function":
          case "symbol":
            return true;
          case "boolean":
            if (d) return false;
            if (null !== c) return !c.acceptsBooleans;
            a = a.toLowerCase().slice(0, 5);
            return "data-" !== a && "aria-" !== a;
          default:
            return false;
        }
      }
      function qa(a, b, c, d) {
        if (null === b || "undefined" === typeof b || pa(a, b, c, d)) return true;
        if (d) return false;
        if (null !== c) switch (c.type) {
          case 3:
            return !b;
          case 4:
            return false === b;
          case 5:
            return isNaN(b);
          case 6:
            return isNaN(b) || 1 > b;
        }
        return false;
      }
      function v(a, b, c, d, e, f, g) {
        this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
        this.attributeName = d;
        this.attributeNamespace = e;
        this.mustUseProperty = c;
        this.propertyName = a;
        this.type = b;
        this.sanitizeURL = f;
        this.removeEmptyString = g;
      }
      var z = {};
      "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
        z[a] = new v(a, 0, false, a, null, false, false);
      });
      [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
        var b = a[0];
        z[b] = new v(b, 1, false, a[1], null, false, false);
      });
      ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
        z[a] = new v(a, 2, false, a.toLowerCase(), null, false, false);
      });
      ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
        z[a] = new v(a, 2, false, a, null, false, false);
      });
      "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
        z[a] = new v(a, 3, false, a.toLowerCase(), null, false, false);
      });
      ["checked", "multiple", "muted", "selected"].forEach(function(a) {
        z[a] = new v(a, 3, true, a, null, false, false);
      });
      ["capture", "download"].forEach(function(a) {
        z[a] = new v(a, 4, false, a, null, false, false);
      });
      ["cols", "rows", "size", "span"].forEach(function(a) {
        z[a] = new v(a, 6, false, a, null, false, false);
      });
      ["rowSpan", "start"].forEach(function(a) {
        z[a] = new v(a, 5, false, a.toLowerCase(), null, false, false);
      });
      var ra = /[\-:]([a-z])/g;
      function sa(a) {
        return a[1].toUpperCase();
      }
      "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
        var b = a.replace(
          ra,
          sa
        );
        z[b] = new v(b, 1, false, a, null, false, false);
      });
      "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
        var b = a.replace(ra, sa);
        z[b] = new v(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
      });
      ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
        var b = a.replace(ra, sa);
        z[b] = new v(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
      });
      ["tabIndex", "crossOrigin"].forEach(function(a) {
        z[a] = new v(a, 1, false, a.toLowerCase(), null, false, false);
      });
      z.xlinkHref = new v("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
      ["src", "href", "action", "formAction"].forEach(function(a) {
        z[a] = new v(a, 1, false, a.toLowerCase(), null, true, true);
      });
      function ta(a, b, c, d) {
        var e = z.hasOwnProperty(b) ? z[b] : null;
        if (null !== e ? 0 !== e.type : d || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1]) qa(b, c, e, d) && (c = null), d || null === e ? oa(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? false : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && true === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c)));
      }
      var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
      var Ia = Symbol.for("react.offscreen");
      var Ja = Symbol.iterator;
      function Ka(a) {
        if (null === a || "object" !== typeof a) return null;
        a = Ja && a[Ja] || a["@@iterator"];
        return "function" === typeof a ? a : null;
      }
      var A = Object.assign, La;
      function Ma(a) {
        if (void 0 === La) try {
          throw Error();
        } catch (c) {
          var b = c.stack.trim().match(/\n( *(at )?)/);
          La = b && b[1] || "";
        }
        return "\n" + La + a;
      }
      var Na = false;
      function Oa(a, b) {
        if (!a || Na) return "";
        Na = true;
        var c = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
          if (b) if (b = function() {
            throw Error();
          }, Object.defineProperty(b.prototype, "props", { set: function() {
            throw Error();
          } }), "object" === typeof Reflect && Reflect.construct) {
            try {
              Reflect.construct(b, []);
            } catch (l) {
              var d = l;
            }
            Reflect.construct(a, [], b);
          } else {
            try {
              b.call();
            } catch (l) {
              d = l;
            }
            a.call(b.prototype);
          }
          else {
            try {
              throw Error();
            } catch (l) {
              d = l;
            }
            a();
          }
        } catch (l) {
          if (l && d && "string" === typeof l.stack) {
            for (var e = l.stack.split("\n"), f = d.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h]; ) h--;
            for (; 1 <= g && 0 <= h; g--, h--) if (e[g] !== f[h]) {
              if (1 !== g || 1 !== h) {
                do
                  if (g--, h--, 0 > h || e[g] !== f[h]) {
                    var k = "\n" + e[g].replace(" at new ", " at ");
                    a.displayName && k.includes("<anonymous>") && (k = k.replace("<anonymous>", a.displayName));
                    return k;
                  }
                while (1 <= g && 0 <= h);
              }
              break;
            }
          }
        } finally {
          Na = false, Error.prepareStackTrace = c;
        }
        return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
      }
      function Pa(a) {
        switch (a.tag) {
          case 5:
            return Ma(a.type);
          case 16:
            return Ma("Lazy");
          case 13:
            return Ma("Suspense");
          case 19:
            return Ma("SuspenseList");
          case 0:
          case 2:
          case 15:
            return a = Oa(a.type, false), a;
          case 11:
            return a = Oa(a.type.render, false), a;
          case 1:
            return a = Oa(a.type, true), a;
          default:
            return "";
        }
      }
      function Qa(a) {
        if (null == a) return null;
        if ("function" === typeof a) return a.displayName || a.name || null;
        if ("string" === typeof a) return a;
        switch (a) {
          case ya:
            return "Fragment";
          case wa:
            return "Portal";
          case Aa:
            return "Profiler";
          case za:
            return "StrictMode";
          case Ea:
            return "Suspense";
          case Fa:
            return "SuspenseList";
        }
        if ("object" === typeof a) switch (a.$$typeof) {
          case Ca:
            return (a.displayName || "Context") + ".Consumer";
          case Ba:
            return (a._context.displayName || "Context") + ".Provider";
          case Da:
            var b = a.render;
            a = a.displayName;
            a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
            return a;
          case Ga:
            return b = a.displayName || null, null !== b ? b : Qa(a.type) || "Memo";
          case Ha:
            b = a._payload;
            a = a._init;
            try {
              return Qa(a(b));
            } catch (c) {
            }
        }
        return null;
      }
      function Ra(a) {
        var b = a.type;
        switch (a.tag) {
          case 24:
            return "Cache";
          case 9:
            return (b.displayName || "Context") + ".Consumer";
          case 10:
            return (b._context.displayName || "Context") + ".Provider";
          case 18:
            return "DehydratedFragment";
          case 11:
            return a = b.render, a = a.displayName || a.name || "", b.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
          case 7:
            return "Fragment";
          case 5:
            return b;
          case 4:
            return "Portal";
          case 3:
            return "Root";
          case 6:
            return "Text";
          case 16:
            return Qa(b);
          case 8:
            return b === za ? "StrictMode" : "Mode";
          case 22:
            return "Offscreen";
          case 12:
            return "Profiler";
          case 21:
            return "Scope";
          case 13:
            return "Suspense";
          case 19:
            return "SuspenseList";
          case 25:
            return "TracingMarker";
          case 1:
          case 0:
          case 17:
          case 2:
          case 14:
          case 15:
            if ("function" === typeof b) return b.displayName || b.name || null;
            if ("string" === typeof b) return b;
        }
        return null;
      }
      function Sa(a) {
        switch (typeof a) {
          case "boolean":
          case "number":
          case "string":
          case "undefined":
            return a;
          case "object":
            return a;
          default:
            return "";
        }
      }
      function Ta(a) {
        var b = a.type;
        return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
      }
      function Ua(a) {
        var b = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b];
        if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
          var e = c.get, f = c.set;
          Object.defineProperty(a, b, { configurable: true, get: function() {
            return e.call(this);
          }, set: function(a2) {
            d = "" + a2;
            f.call(this, a2);
          } });
          Object.defineProperty(a, b, { enumerable: c.enumerable });
          return { getValue: function() {
            return d;
          }, setValue: function(a2) {
            d = "" + a2;
          }, stopTracking: function() {
            a._valueTracker = null;
            delete a[b];
          } };
        }
      }
      function Va(a) {
        a._valueTracker || (a._valueTracker = Ua(a));
      }
      function Wa(a) {
        if (!a) return false;
        var b = a._valueTracker;
        if (!b) return true;
        var c = b.getValue();
        var d = "";
        a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
        a = d;
        return a !== c ? (b.setValue(a), true) : false;
      }
      function Xa(a) {
        a = a || ("undefined" !== typeof document ? document : void 0);
        if ("undefined" === typeof a) return null;
        try {
          return a.activeElement || a.body;
        } catch (b) {
          return a.body;
        }
      }
      function Ya(a, b) {
        var c = b.checked;
        return A({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a._wrapperState.initialChecked });
      }
      function Za(a, b) {
        var c = null == b.defaultValue ? "" : b.defaultValue, d = null != b.checked ? b.checked : b.defaultChecked;
        c = Sa(null != b.value ? b.value : c);
        a._wrapperState = { initialChecked: d, initialValue: c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
      }
      function ab(a, b) {
        b = b.checked;
        null != b && ta(a, "checked", b, false);
      }
      function bb(a, b) {
        ab(a, b);
        var c = Sa(b.value), d = b.type;
        if (null != c) if ("number" === d) {
          if (0 === c && "" === a.value || a.value != c) a.value = "" + c;
        } else a.value !== "" + c && (a.value = "" + c);
        else if ("submit" === d || "reset" === d) {
          a.removeAttribute("value");
          return;
        }
        b.hasOwnProperty("value") ? cb(a, b.type, c) : b.hasOwnProperty("defaultValue") && cb(a, b.type, Sa(b.defaultValue));
        null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
      }
      function db(a, b, c) {
        if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
          var d = b.type;
          if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value)) return;
          b = "" + a._wrapperState.initialValue;
          c || b === a.value || (a.value = b);
          a.defaultValue = b;
        }
        c = a.name;
        "" !== c && (a.name = "");
        a.defaultChecked = !!a._wrapperState.initialChecked;
        "" !== c && (a.name = c);
      }
      function cb(a, b, c) {
        if ("number" !== b || Xa(a.ownerDocument) !== a) null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
      }
      var eb = Array.isArray;
      function fb(a, b, c, d) {
        a = a.options;
        if (b) {
          b = {};
          for (var e = 0; e < c.length; e++) b["$" + c[e]] = true;
          for (c = 0; c < a.length; c++) e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = true);
        } else {
          c = "" + Sa(c);
          b = null;
          for (e = 0; e < a.length; e++) {
            if (a[e].value === c) {
              a[e].selected = true;
              d && (a[e].defaultSelected = true);
              return;
            }
            null !== b || a[e].disabled || (b = a[e]);
          }
          null !== b && (b.selected = true);
        }
      }
      function gb(a, b) {
        if (null != b.dangerouslySetInnerHTML) throw Error(p(91));
        return A({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
      }
      function hb(a, b) {
        var c = b.value;
        if (null == c) {
          c = b.children;
          b = b.defaultValue;
          if (null != c) {
            if (null != b) throw Error(p(92));
            if (eb(c)) {
              if (1 < c.length) throw Error(p(93));
              c = c[0];
            }
            b = c;
          }
          null == b && (b = "");
          c = b;
        }
        a._wrapperState = { initialValue: Sa(c) };
      }
      function ib(a, b) {
        var c = Sa(b.value), d = Sa(b.defaultValue);
        null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
        null != d && (a.defaultValue = "" + d);
      }
      function jb(a) {
        var b = a.textContent;
        b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
      }
      function kb(a) {
        switch (a) {
          case "svg":
            return "http://www.w3.org/2000/svg";
          case "math":
            return "http://www.w3.org/1998/Math/MathML";
          default:
            return "http://www.w3.org/1999/xhtml";
        }
      }
      function lb(a, b) {
        return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
      }
      var mb, nb = function(a) {
        return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {
          MSApp.execUnsafeLocalFunction(function() {
            return a(b, c, d, e);
          });
        } : a;
      }(function(a, b) {
        if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a) a.innerHTML = b;
        else {
          mb = mb || document.createElement("div");
          mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
          for (b = mb.firstChild; a.firstChild; ) a.removeChild(a.firstChild);
          for (; b.firstChild; ) a.appendChild(b.firstChild);
        }
      });
      function ob(a, b) {
        if (b) {
          var c = a.firstChild;
          if (c && c === a.lastChild && 3 === c.nodeType) {
            c.nodeValue = b;
            return;
          }
        }
        a.textContent = b;
      }
      var pb = {
        animationIterationCount: true,
        aspectRatio: true,
        borderImageOutset: true,
        borderImageSlice: true,
        borderImageWidth: true,
        boxFlex: true,
        boxFlexGroup: true,
        boxOrdinalGroup: true,
        columnCount: true,
        columns: true,
        flex: true,
        flexGrow: true,
        flexPositive: true,
        flexShrink: true,
        flexNegative: true,
        flexOrder: true,
        gridArea: true,
        gridRow: true,
        gridRowEnd: true,
        gridRowSpan: true,
        gridRowStart: true,
        gridColumn: true,
        gridColumnEnd: true,
        gridColumnSpan: true,
        gridColumnStart: true,
        fontWeight: true,
        lineClamp: true,
        lineHeight: true,
        opacity: true,
        order: true,
        orphans: true,
        tabSize: true,
        widows: true,
        zIndex: true,
        zoom: true,
        fillOpacity: true,
        floodOpacity: true,
        stopOpacity: true,
        strokeDasharray: true,
        strokeDashoffset: true,
        strokeMiterlimit: true,
        strokeOpacity: true,
        strokeWidth: true
      }, qb = ["Webkit", "ms", "Moz", "O"];
      Object.keys(pb).forEach(function(a) {
        qb.forEach(function(b) {
          b = b + a.charAt(0).toUpperCase() + a.substring(1);
          pb[b] = pb[a];
        });
      });
      function rb(a, b, c) {
        return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || pb.hasOwnProperty(a) && pb[a] ? ("" + b).trim() : b + "px";
      }
      function sb(a, b) {
        a = a.style;
        for (var c in b) if (b.hasOwnProperty(c)) {
          var d = 0 === c.indexOf("--"), e = rb(c, b[c], d);
          "float" === c && (c = "cssFloat");
          d ? a.setProperty(c, e) : a[c] = e;
        }
      }
      var tb = A({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
      function ub(a, b) {
        if (b) {
          if (tb[a] && (null != b.children || null != b.dangerouslySetInnerHTML)) throw Error(p(137, a));
          if (null != b.dangerouslySetInnerHTML) {
            if (null != b.children) throw Error(p(60));
            if ("object" !== typeof b.dangerouslySetInnerHTML || !("__html" in b.dangerouslySetInnerHTML)) throw Error(p(61));
          }
          if (null != b.style && "object" !== typeof b.style) throw Error(p(62));
        }
      }
      function vb(a, b) {
        if (-1 === a.indexOf("-")) return "string" === typeof b.is;
        switch (a) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return false;
          default:
            return true;
        }
      }
      var wb = null;
      function xb(a) {
        a = a.target || a.srcElement || window;
        a.correspondingUseElement && (a = a.correspondingUseElement);
        return 3 === a.nodeType ? a.parentNode : a;
      }
      var yb = null, zb = null, Ab = null;
      function Bb(a) {
        if (a = Cb(a)) {
          if ("function" !== typeof yb) throw Error(p(280));
          var b = a.stateNode;
          b && (b = Db(b), yb(a.stateNode, a.type, b));
        }
      }
      function Eb(a) {
        zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
      }
      function Fb() {
        if (zb) {
          var a = zb, b = Ab;
          Ab = zb = null;
          Bb(a);
          if (b) for (a = 0; a < b.length; a++) Bb(b[a]);
        }
      }
      function Gb(a, b) {
        return a(b);
      }
      function Hb() {
      }
      var Ib = false;
      function Jb(a, b, c) {
        if (Ib) return a(b, c);
        Ib = true;
        try {
          return Gb(a, b, c);
        } finally {
          if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
        }
      }
      function Kb(a, b) {
        var c = a.stateNode;
        if (null === c) return null;
        var d = Db(c);
        if (null === d) return null;
        c = d[b];
        a: switch (b) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
            a = !d;
            break a;
          default:
            a = false;
        }
        if (a) return null;
        if (c && "function" !== typeof c) throw Error(p(231, b, typeof c));
        return c;
      }
      var Lb = false;
      if (ia) try {
        var Mb = {};
        Object.defineProperty(Mb, "passive", { get: function() {
          Lb = true;
        } });
        window.addEventListener("test", Mb, Mb);
        window.removeEventListener("test", Mb, Mb);
      } catch (a) {
        Lb = false;
      }
      function Nb(a, b, c, d, e, f, g, h, k) {
        var l = Array.prototype.slice.call(arguments, 3);
        try {
          b.apply(c, l);
        } catch (m) {
          this.onError(m);
        }
      }
      var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a) {
        Ob = true;
        Pb = a;
      } };
      function Tb(a, b, c, d, e, f, g, h, k) {
        Ob = false;
        Pb = null;
        Nb.apply(Sb, arguments);
      }
      function Ub(a, b, c, d, e, f, g, h, k) {
        Tb.apply(this, arguments);
        if (Ob) {
          if (Ob) {
            var l = Pb;
            Ob = false;
            Pb = null;
          } else throw Error(p(198));
          Qb || (Qb = true, Rb = l);
        }
      }
      function Vb(a) {
        var b = a, c = a;
        if (a.alternate) for (; b.return; ) b = b.return;
        else {
          a = b;
          do
            b = a, 0 !== (b.flags & 4098) && (c = b.return), a = b.return;
          while (a);
        }
        return 3 === b.tag ? c : null;
      }
      function Wb(a) {
        if (13 === a.tag) {
          var b = a.memoizedState;
          null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
          if (null !== b) return b.dehydrated;
        }
        return null;
      }
      function Xb(a) {
        if (Vb(a) !== a) throw Error(p(188));
      }
      function Yb(a) {
        var b = a.alternate;
        if (!b) {
          b = Vb(a);
          if (null === b) throw Error(p(188));
          return b !== a ? null : a;
        }
        for (var c = a, d = b; ; ) {
          var e = c.return;
          if (null === e) break;
          var f = e.alternate;
          if (null === f) {
            d = e.return;
            if (null !== d) {
              c = d;
              continue;
            }
            break;
          }
          if (e.child === f.child) {
            for (f = e.child; f; ) {
              if (f === c) return Xb(e), a;
              if (f === d) return Xb(e), b;
              f = f.sibling;
            }
            throw Error(p(188));
          }
          if (c.return !== d.return) c = e, d = f;
          else {
            for (var g = false, h = e.child; h; ) {
              if (h === c) {
                g = true;
                c = e;
                d = f;
                break;
              }
              if (h === d) {
                g = true;
                d = e;
                c = f;
                break;
              }
              h = h.sibling;
            }
            if (!g) {
              for (h = f.child; h; ) {
                if (h === c) {
                  g = true;
                  c = f;
                  d = e;
                  break;
                }
                if (h === d) {
                  g = true;
                  d = f;
                  c = e;
                  break;
                }
                h = h.sibling;
              }
              if (!g) throw Error(p(189));
            }
          }
          if (c.alternate !== d) throw Error(p(190));
        }
        if (3 !== c.tag) throw Error(p(188));
        return c.stateNode.current === c ? a : b;
      }
      function Zb(a) {
        a = Yb(a);
        return null !== a ? $b(a) : null;
      }
      function $b(a) {
        if (5 === a.tag || 6 === a.tag) return a;
        for (a = a.child; null !== a; ) {
          var b = $b(a);
          if (null !== b) return b;
          a = a.sibling;
        }
        return null;
      }
      var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
      function mc(a) {
        if (lc && "function" === typeof lc.onCommitFiberRoot) try {
          lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
        } catch (b) {
        }
      }
      var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
      function nc(a) {
        a >>>= 0;
        return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
      }
      var rc = 64, sc = 4194304;
      function tc(a) {
        switch (a & -a) {
          case 1:
            return 1;
          case 2:
            return 2;
          case 4:
            return 4;
          case 8:
            return 8;
          case 16:
            return 16;
          case 32:
            return 32;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return a & 4194240;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            return a & 130023424;
          case 134217728:
            return 134217728;
          case 268435456:
            return 268435456;
          case 536870912:
            return 536870912;
          case 1073741824:
            return 1073741824;
          default:
            return a;
        }
      }
      function uc(a, b) {
        var c = a.pendingLanes;
        if (0 === c) return 0;
        var d = 0, e = a.suspendedLanes, f = a.pingedLanes, g = c & 268435455;
        if (0 !== g) {
          var h = g & ~e;
          0 !== h ? d = tc(h) : (f &= g, 0 !== f && (d = tc(f)));
        } else g = c & ~e, 0 !== g ? d = tc(g) : 0 !== f && (d = tc(f));
        if (0 === d) return 0;
        if (0 !== b && b !== d && 0 === (b & e) && (e = d & -d, f = b & -b, e >= f || 16 === e && 0 !== (f & 4194240))) return b;
        0 !== (d & 4) && (d |= c & 16);
        b = a.entangledLanes;
        if (0 !== b) for (a = a.entanglements, b &= d; 0 < b; ) c = 31 - oc(b), e = 1 << c, d |= a[c], b &= ~e;
        return d;
      }
      function vc(a, b) {
        switch (a) {
          case 1:
          case 2:
          case 4:
            return b + 250;
          case 8:
          case 16:
          case 32:
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return b + 5e3;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            return -1;
          case 134217728:
          case 268435456:
          case 536870912:
          case 1073741824:
            return -1;
          default:
            return -1;
        }
      }
      function wc(a, b) {
        for (var c = a.suspendedLanes, d = a.pingedLanes, e = a.expirationTimes, f = a.pendingLanes; 0 < f; ) {
          var g = 31 - oc(f), h = 1 << g, k = e[g];
          if (-1 === k) {
            if (0 === (h & c) || 0 !== (h & d)) e[g] = vc(h, b);
          } else k <= b && (a.expiredLanes |= h);
          f &= ~h;
        }
      }
      function xc(a) {
        a = a.pendingLanes & -1073741825;
        return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
      }
      function yc() {
        var a = rc;
        rc <<= 1;
        0 === (rc & 4194240) && (rc = 64);
        return a;
      }
      function zc(a) {
        for (var b = [], c = 0; 31 > c; c++) b.push(a);
        return b;
      }
      function Ac(a, b, c) {
        a.pendingLanes |= b;
        536870912 !== b && (a.suspendedLanes = 0, a.pingedLanes = 0);
        a = a.eventTimes;
        b = 31 - oc(b);
        a[b] = c;
      }
      function Bc(a, b) {
        var c = a.pendingLanes & ~b;
        a.pendingLanes = b;
        a.suspendedLanes = 0;
        a.pingedLanes = 0;
        a.expiredLanes &= b;
        a.mutableReadLanes &= b;
        a.entangledLanes &= b;
        b = a.entanglements;
        var d = a.eventTimes;
        for (a = a.expirationTimes; 0 < c; ) {
          var e = 31 - oc(c), f = 1 << e;
          b[e] = 0;
          d[e] = -1;
          a[e] = -1;
          c &= ~f;
        }
      }
      function Cc(a, b) {
        var c = a.entangledLanes |= b;
        for (a = a.entanglements; c; ) {
          var d = 31 - oc(c), e = 1 << d;
          e & b | a[d] & b && (a[d] |= b);
          c &= ~e;
        }
      }
      var C = 0;
      function Dc(a) {
        a &= -a;
        return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
      }
      var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
      function Sc(a, b) {
        switch (a) {
          case "focusin":
          case "focusout":
            Lc = null;
            break;
          case "dragenter":
          case "dragleave":
            Mc = null;
            break;
          case "mouseover":
          case "mouseout":
            Nc = null;
            break;
          case "pointerover":
          case "pointerout":
            Oc.delete(b.pointerId);
            break;
          case "gotpointercapture":
          case "lostpointercapture":
            Pc.delete(b.pointerId);
        }
      }
      function Tc(a, b, c, d, e, f) {
        if (null === a || a.nativeEvent !== f) return a = { blockedOn: b, domEventName: c, eventSystemFlags: d, nativeEvent: f, targetContainers: [e] }, null !== b && (b = Cb(b), null !== b && Fc(b)), a;
        a.eventSystemFlags |= d;
        b = a.targetContainers;
        null !== e && -1 === b.indexOf(e) && b.push(e);
        return a;
      }
      function Uc(a, b, c, d, e) {
        switch (b) {
          case "focusin":
            return Lc = Tc(Lc, a, b, c, d, e), true;
          case "dragenter":
            return Mc = Tc(Mc, a, b, c, d, e), true;
          case "mouseover":
            return Nc = Tc(Nc, a, b, c, d, e), true;
          case "pointerover":
            var f = e.pointerId;
            Oc.set(f, Tc(Oc.get(f) || null, a, b, c, d, e));
            return true;
          case "gotpointercapture":
            return f = e.pointerId, Pc.set(f, Tc(Pc.get(f) || null, a, b, c, d, e)), true;
        }
        return false;
      }
      function Vc(a) {
        var b = Wc(a.target);
        if (null !== b) {
          var c = Vb(b);
          if (null !== c) {
            if (b = c.tag, 13 === b) {
              if (b = Wb(c), null !== b) {
                a.blockedOn = b;
                Ic(a.priority, function() {
                  Gc(c);
                });
                return;
              }
            } else if (3 === b && c.stateNode.current.memoizedState.isDehydrated) {
              a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
              return;
            }
          }
        }
        a.blockedOn = null;
      }
      function Xc(a) {
        if (null !== a.blockedOn) return false;
        for (var b = a.targetContainers; 0 < b.length; ) {
          var c = Yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
          if (null === c) {
            c = a.nativeEvent;
            var d = new c.constructor(c.type, c);
            wb = d;
            c.target.dispatchEvent(d);
            wb = null;
          } else return b = Cb(c), null !== b && Fc(b), a.blockedOn = c, false;
          b.shift();
        }
        return true;
      }
      function Zc(a, b, c) {
        Xc(a) && c.delete(b);
      }
      function $c() {
        Jc = false;
        null !== Lc && Xc(Lc) && (Lc = null);
        null !== Mc && Xc(Mc) && (Mc = null);
        null !== Nc && Xc(Nc) && (Nc = null);
        Oc.forEach(Zc);
        Pc.forEach(Zc);
      }
      function ad(a, b) {
        a.blockedOn === b && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
      }
      function bd(a) {
        function b(b2) {
          return ad(b2, a);
        }
        if (0 < Kc.length) {
          ad(Kc[0], a);
          for (var c = 1; c < Kc.length; c++) {
            var d = Kc[c];
            d.blockedOn === a && (d.blockedOn = null);
          }
        }
        null !== Lc && ad(Lc, a);
        null !== Mc && ad(Mc, a);
        null !== Nc && ad(Nc, a);
        Oc.forEach(b);
        Pc.forEach(b);
        for (c = 0; c < Qc.length; c++) d = Qc[c], d.blockedOn === a && (d.blockedOn = null);
        for (; 0 < Qc.length && (c = Qc[0], null === c.blockedOn); ) Vc(c), null === c.blockedOn && Qc.shift();
      }
      var cd = ua.ReactCurrentBatchConfig, dd = true;
      function ed(a, b, c, d) {
        var e = C, f = cd.transition;
        cd.transition = null;
        try {
          C = 1, fd(a, b, c, d);
        } finally {
          C = e, cd.transition = f;
        }
      }
      function gd(a, b, c, d) {
        var e = C, f = cd.transition;
        cd.transition = null;
        try {
          C = 4, fd(a, b, c, d);
        } finally {
          C = e, cd.transition = f;
        }
      }
      function fd(a, b, c, d) {
        if (dd) {
          var e = Yc(a, b, c, d);
          if (null === e) hd(a, b, d, id, c), Sc(a, d);
          else if (Uc(e, a, b, c, d)) d.stopPropagation();
          else if (Sc(a, d), b & 4 && -1 < Rc.indexOf(a)) {
            for (; null !== e; ) {
              var f = Cb(e);
              null !== f && Ec(f);
              f = Yc(a, b, c, d);
              null === f && hd(a, b, d, id, c);
              if (f === e) break;
              e = f;
            }
            null !== e && d.stopPropagation();
          } else hd(a, b, d, null, c);
        }
      }
      var id = null;
      function Yc(a, b, c, d) {
        id = null;
        a = xb(d);
        a = Wc(a);
        if (null !== a) if (b = Vb(a), null === b) a = null;
        else if (c = b.tag, 13 === c) {
          a = Wb(b);
          if (null !== a) return a;
          a = null;
        } else if (3 === c) {
          if (b.stateNode.current.memoizedState.isDehydrated) return 3 === b.tag ? b.stateNode.containerInfo : null;
          a = null;
        } else b !== a && (a = null);
        id = a;
        return null;
      }
      function jd(a) {
        switch (a) {
          case "cancel":
          case "click":
          case "close":
          case "contextmenu":
          case "copy":
          case "cut":
          case "auxclick":
          case "dblclick":
          case "dragend":
          case "dragstart":
          case "drop":
          case "focusin":
          case "focusout":
          case "input":
          case "invalid":
          case "keydown":
          case "keypress":
          case "keyup":
          case "mousedown":
          case "mouseup":
          case "paste":
          case "pause":
          case "play":
          case "pointercancel":
          case "pointerdown":
          case "pointerup":
          case "ratechange":
          case "reset":
          case "resize":
          case "seeked":
          case "submit":
          case "touchcancel":
          case "touchend":
          case "touchstart":
          case "volumechange":
          case "change":
          case "selectionchange":
          case "textInput":
          case "compositionstart":
          case "compositionend":
          case "compositionupdate":
          case "beforeblur":
          case "afterblur":
          case "beforeinput":
          case "blur":
          case "fullscreenchange":
          case "focus":
          case "hashchange":
          case "popstate":
          case "select":
          case "selectstart":
            return 1;
          case "drag":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "mousemove":
          case "mouseout":
          case "mouseover":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "scroll":
          case "toggle":
          case "touchmove":
          case "wheel":
          case "mouseenter":
          case "mouseleave":
          case "pointerenter":
          case "pointerleave":
            return 4;
          case "message":
            switch (ec()) {
              case fc:
                return 1;
              case gc:
                return 4;
              case hc:
              case ic:
                return 16;
              case jc:
                return 536870912;
              default:
                return 16;
            }
          default:
            return 16;
        }
      }
      var kd = null, ld = null, md = null;
      function nd() {
        if (md) return md;
        var a, b = ld, c = b.length, d, e = "value" in kd ? kd.value : kd.textContent, f = e.length;
        for (a = 0; a < c && b[a] === e[a]; a++) ;
        var g = c - a;
        for (d = 1; d <= g && b[c - d] === e[f - d]; d++) ;
        return md = e.slice(a, 1 < d ? 1 - d : void 0);
      }
      function od(a) {
        var b = a.keyCode;
        "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
        10 === a && (a = 13);
        return 32 <= a || 13 === a ? a : 0;
      }
      function pd() {
        return true;
      }
      function qd() {
        return false;
      }
      function rd(a) {
        function b(b2, d, e, f, g) {
          this._reactName = b2;
          this._targetInst = e;
          this.type = d;
          this.nativeEvent = f;
          this.target = g;
          this.currentTarget = null;
          for (var c in a) a.hasOwnProperty(c) && (b2 = a[c], this[c] = b2 ? b2(f) : f[c]);
          this.isDefaultPrevented = (null != f.defaultPrevented ? f.defaultPrevented : false === f.returnValue) ? pd : qd;
          this.isPropagationStopped = qd;
          return this;
        }
        A(b.prototype, { preventDefault: function() {
          this.defaultPrevented = true;
          var a2 = this.nativeEvent;
          a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
        }, stopPropagation: function() {
          var a2 = this.nativeEvent;
          a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
        }, persist: function() {
        }, isPersistent: pd });
        return b;
      }
      var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
        return a.timeStamp || Date.now();
      }, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
        return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
      }, movementX: function(a) {
        if ("movementX" in a) return a.movementX;
        a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
        return wd;
      }, movementY: function(a) {
        return "movementY" in a ? a.movementY : xd;
      } }), Bd = rd(Ad), Cd = A({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A({}, sd, { clipboardData: function(a) {
        return "clipboardData" in a ? a.clipboardData : window.clipboardData;
      } }), Jd = rd(Id), Kd = A({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
      }, Nd = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
      }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
      function Pd(a) {
        var b = this.nativeEvent;
        return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : false;
      }
      function zd() {
        return Pd;
      }
      var Qd = A({}, ud, { key: function(a) {
        if (a.key) {
          var b = Md[a.key] || a.key;
          if ("Unidentified" !== b) return b;
        }
        return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
      }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
        return "keypress" === a.type ? od(a) : 0;
      }, keyCode: function(a) {
        return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
      }, which: function(a) {
        return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
      } }), Rd = rd(Qd), Sd = A({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A({}, Ad, {
        deltaX: function(a) {
          return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
        },
        deltaY: function(a) {
          return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
        },
        deltaZ: 0,
        deltaMode: 0
      }), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
      ia && "documentMode" in document && (be = document.documentMode);
      var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
      function ge(a, b) {
        switch (a) {
          case "keyup":
            return -1 !== $d.indexOf(b.keyCode);
          case "keydown":
            return 229 !== b.keyCode;
          case "keypress":
          case "mousedown":
          case "focusout":
            return true;
          default:
            return false;
        }
      }
      function he(a) {
        a = a.detail;
        return "object" === typeof a && "data" in a ? a.data : null;
      }
      var ie = false;
      function je(a, b) {
        switch (a) {
          case "compositionend":
            return he(b);
          case "keypress":
            if (32 !== b.which) return null;
            fe = true;
            return ee;
          case "textInput":
            return a = b.data, a === ee && fe ? null : a;
          default:
            return null;
        }
      }
      function ke(a, b) {
        if (ie) return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
        switch (a) {
          case "paste":
            return null;
          case "keypress":
            if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
              if (b.char && 1 < b.char.length) return b.char;
              if (b.which) return String.fromCharCode(b.which);
            }
            return null;
          case "compositionend":
            return de && "ko" !== b.locale ? null : b.data;
          default:
            return null;
        }
      }
      var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
      function me(a) {
        var b = a && a.nodeName && a.nodeName.toLowerCase();
        return "input" === b ? !!le[a.type] : "textarea" === b ? true : false;
      }
      function ne(a, b, c, d) {
        Eb(d);
        b = oe(b, "onChange");
        0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({ event: c, listeners: b }));
      }
      var pe = null, qe = null;
      function re(a) {
        se(a, 0);
      }
      function te(a) {
        var b = ue(a);
        if (Wa(b)) return a;
      }
      function ve(a, b) {
        if ("change" === a) return b;
      }
      var we = false;
      if (ia) {
        var xe;
        if (ia) {
          var ye = "oninput" in document;
          if (!ye) {
            var ze = document.createElement("div");
            ze.setAttribute("oninput", "return;");
            ye = "function" === typeof ze.oninput;
          }
          xe = ye;
        } else xe = false;
        we = xe && (!document.documentMode || 9 < document.documentMode);
      }
      function Ae() {
        pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
      }
      function Be(a) {
        if ("value" === a.propertyName && te(qe)) {
          var b = [];
          ne(b, qe, a, xb(a));
          Jb(re, b);
        }
      }
      function Ce(a, b, c) {
        "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
      }
      function De(a) {
        if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te(qe);
      }
      function Ee(a, b) {
        if ("click" === a) return te(b);
      }
      function Fe(a, b) {
        if ("input" === a || "change" === a) return te(b);
      }
      function Ge(a, b) {
        return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
      }
      var He = "function" === typeof Object.is ? Object.is : Ge;
      function Ie(a, b) {
        if (He(a, b)) return true;
        if ("object" !== typeof a || null === a || "object" !== typeof b || null === b) return false;
        var c = Object.keys(a), d = Object.keys(b);
        if (c.length !== d.length) return false;
        for (d = 0; d < c.length; d++) {
          var e = c[d];
          if (!ja.call(b, e) || !He(a[e], b[e])) return false;
        }
        return true;
      }
      function Je(a) {
        for (; a && a.firstChild; ) a = a.firstChild;
        return a;
      }
      function Ke(a, b) {
        var c = Je(a);
        a = 0;
        for (var d; c; ) {
          if (3 === c.nodeType) {
            d = a + c.textContent.length;
            if (a <= b && d >= b) return { node: c, offset: b - a };
            a = d;
          }
          a: {
            for (; c; ) {
              if (c.nextSibling) {
                c = c.nextSibling;
                break a;
              }
              c = c.parentNode;
            }
            c = void 0;
          }
          c = Je(c);
        }
      }
      function Le(a, b) {
        return a && b ? a === b ? true : a && 3 === a.nodeType ? false : b && 3 === b.nodeType ? Le(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
      }
      function Me() {
        for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
          try {
            var c = "string" === typeof b.contentWindow.location.href;
          } catch (d) {
            c = false;
          }
          if (c) a = b.contentWindow;
          else break;
          b = Xa(a.document);
        }
        return b;
      }
      function Ne(a) {
        var b = a && a.nodeName && a.nodeName.toLowerCase();
        return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
      }
      function Oe(a) {
        var b = Me(), c = a.focusedElem, d = a.selectionRange;
        if (b !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
          if (null !== d && Ne(c)) {
            if (b = d.start, a = d.end, void 0 === a && (a = b), "selectionStart" in c) c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);
            else if (a = (b = c.ownerDocument || document) && b.defaultView || window, a.getSelection) {
              a = a.getSelection();
              var e = c.textContent.length, f = Math.min(d.start, e);
              d = void 0 === d.end ? f : Math.min(d.end, e);
              !a.extend && f > d && (e = d, d = f, f = e);
              e = Ke(c, f);
              var g = Ke(
                c,
                d
              );
              e && g && (1 !== a.rangeCount || a.anchorNode !== e.node || a.anchorOffset !== e.offset || a.focusNode !== g.node || a.focusOffset !== g.offset) && (b = b.createRange(), b.setStart(e.node, e.offset), a.removeAllRanges(), f > d ? (a.addRange(b), a.extend(g.node, g.offset)) : (b.setEnd(g.node, g.offset), a.addRange(b)));
            }
          }
          b = [];
          for (a = c; a = a.parentNode; ) 1 === a.nodeType && b.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
          "function" === typeof c.focus && c.focus();
          for (c = 0; c < b.length; c++) a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
        }
      }
      var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
      function Ue(a, b, c) {
        var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
        Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Ne(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se && Ie(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({ event: b, listeners: d }), b.target = Qe)));
      }
      function Ve(a, b) {
        var c = {};
        c[a.toLowerCase()] = b.toLowerCase();
        c["Webkit" + a] = "webkit" + b;
        c["Moz" + a] = "moz" + b;
        return c;
      }
      var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
      ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
      function Ze(a) {
        if (Xe[a]) return Xe[a];
        if (!We[a]) return a;
        var b = We[a], c;
        for (c in b) if (b.hasOwnProperty(c) && c in Ye) return Xe[a] = b[c];
        return a;
      }
      var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
      function ff(a, b) {
        df.set(a, b);
        fa(b, [a]);
      }
      for (var gf = 0; gf < ef.length; gf++) {
        var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
        ff(jf, "on" + kf);
      }
      ff($e, "onAnimationEnd");
      ff(af, "onAnimationIteration");
      ff(bf, "onAnimationStart");
      ff("dblclick", "onDoubleClick");
      ff("focusin", "onFocus");
      ff("focusout", "onBlur");
      ff(cf, "onTransitionEnd");
      ha("onMouseEnter", ["mouseout", "mouseover"]);
      ha("onMouseLeave", ["mouseout", "mouseover"]);
      ha("onPointerEnter", ["pointerout", "pointerover"]);
      ha("onPointerLeave", ["pointerout", "pointerover"]);
      fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
      fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
      fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
      fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
      fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
      fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
      var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
      function nf(a, b, c) {
        var d = a.type || "unknown-event";
        a.currentTarget = c;
        Ub(d, b, void 0, a);
        a.currentTarget = null;
      }
      function se(a, b) {
        b = 0 !== (b & 4);
        for (var c = 0; c < a.length; c++) {
          var d = a[c], e = d.event;
          d = d.listeners;
          a: {
            var f = void 0;
            if (b) for (var g = d.length - 1; 0 <= g; g--) {
              var h = d[g], k = h.instance, l = h.currentTarget;
              h = h.listener;
              if (k !== f && e.isPropagationStopped()) break a;
              nf(e, h, l);
              f = k;
            }
            else for (g = 0; g < d.length; g++) {
              h = d[g];
              k = h.instance;
              l = h.currentTarget;
              h = h.listener;
              if (k !== f && e.isPropagationStopped()) break a;
              nf(e, h, l);
              f = k;
            }
          }
        }
        if (Qb) throw a = Rb, Qb = false, Rb = null, a;
      }
      function D(a, b) {
        var c = b[of];
        void 0 === c && (c = b[of] = /* @__PURE__ */ new Set());
        var d = a + "__bubble";
        c.has(d) || (pf(b, a, 2, false), c.add(d));
      }
      function qf(a, b, c) {
        var d = 0;
        b && (d |= 4);
        pf(c, a, d, b);
      }
      var rf = "_reactListening" + Math.random().toString(36).slice(2);
      function sf(a) {
        if (!a[rf]) {
          a[rf] = true;
          da.forEach(function(b2) {
            "selectionchange" !== b2 && (mf.has(b2) || qf(b2, false, a), qf(b2, true, a));
          });
          var b = 9 === a.nodeType ? a : a.ownerDocument;
          null === b || b[rf] || (b[rf] = true, qf("selectionchange", false, b));
        }
      }
      function pf(a, b, c, d) {
        switch (jd(b)) {
          case 1:
            var e = ed;
            break;
          case 4:
            e = gd;
            break;
          default:
            e = fd;
        }
        c = e.bind(null, b, c, a);
        e = void 0;
        !Lb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = true);
        d ? void 0 !== e ? a.addEventListener(b, c, { capture: true, passive: e }) : a.addEventListener(b, c, true) : void 0 !== e ? a.addEventListener(b, c, { passive: e }) : a.addEventListener(b, c, false);
      }
      function hd(a, b, c, d, e) {
        var f = d;
        if (0 === (b & 1) && 0 === (b & 2) && null !== d) a: for (; ; ) {
          if (null === d) return;
          var g = d.tag;
          if (3 === g || 4 === g) {
            var h = d.stateNode.containerInfo;
            if (h === e || 8 === h.nodeType && h.parentNode === e) break;
            if (4 === g) for (g = d.return; null !== g; ) {
              var k = g.tag;
              if (3 === k || 4 === k) {
                if (k = g.stateNode.containerInfo, k === e || 8 === k.nodeType && k.parentNode === e) return;
              }
              g = g.return;
            }
            for (; null !== h; ) {
              g = Wc(h);
              if (null === g) return;
              k = g.tag;
              if (5 === k || 6 === k) {
                d = f = g;
                continue a;
              }
              h = h.parentNode;
            }
          }
          d = d.return;
        }
        Jb(function() {
          var d2 = f, e2 = xb(c), g2 = [];
          a: {
            var h2 = df.get(a);
            if (void 0 !== h2) {
              var k2 = td, n = a;
              switch (a) {
                case "keypress":
                  if (0 === od(c)) break a;
                case "keydown":
                case "keyup":
                  k2 = Rd;
                  break;
                case "focusin":
                  n = "focus";
                  k2 = Fd;
                  break;
                case "focusout":
                  n = "blur";
                  k2 = Fd;
                  break;
                case "beforeblur":
                case "afterblur":
                  k2 = Fd;
                  break;
                case "click":
                  if (2 === c.button) break a;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                  k2 = Bd;
                  break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                  k2 = Dd;
                  break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                  k2 = Vd;
                  break;
                case $e:
                case af:
                case bf:
                  k2 = Hd;
                  break;
                case cf:
                  k2 = Xd;
                  break;
                case "scroll":
                  k2 = vd;
                  break;
                case "wheel":
                  k2 = Zd;
                  break;
                case "copy":
                case "cut":
                case "paste":
                  k2 = Jd;
                  break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                  k2 = Td;
              }
              var t = 0 !== (b & 4), J = !t && "scroll" === a, x = t ? null !== h2 ? h2 + "Capture" : null : h2;
              t = [];
              for (var w = d2, u; null !== w; ) {
                u = w;
                var F = u.stateNode;
                5 === u.tag && null !== F && (u = F, null !== x && (F = Kb(w, x), null != F && t.push(tf(w, F, u))));
                if (J) break;
                w = w.return;
              }
              0 < t.length && (h2 = new k2(h2, n, null, c, e2), g2.push({ event: h2, listeners: t }));
            }
          }
          if (0 === (b & 7)) {
            a: {
              h2 = "mouseover" === a || "pointerover" === a;
              k2 = "mouseout" === a || "pointerout" === a;
              if (h2 && c !== wb && (n = c.relatedTarget || c.fromElement) && (Wc(n) || n[uf])) break a;
              if (k2 || h2) {
                h2 = e2.window === e2 ? e2 : (h2 = e2.ownerDocument) ? h2.defaultView || h2.parentWindow : window;
                if (k2) {
                  if (n = c.relatedTarget || c.toElement, k2 = d2, n = n ? Wc(n) : null, null !== n && (J = Vb(n), n !== J || 5 !== n.tag && 6 !== n.tag)) n = null;
                } else k2 = null, n = d2;
                if (k2 !== n) {
                  t = Bd;
                  F = "onMouseLeave";
                  x = "onMouseEnter";
                  w = "mouse";
                  if ("pointerout" === a || "pointerover" === a) t = Td, F = "onPointerLeave", x = "onPointerEnter", w = "pointer";
                  J = null == k2 ? h2 : ue(k2);
                  u = null == n ? h2 : ue(n);
                  h2 = new t(F, w + "leave", k2, c, e2);
                  h2.target = J;
                  h2.relatedTarget = u;
                  F = null;
                  Wc(e2) === d2 && (t = new t(x, w + "enter", n, c, e2), t.target = u, t.relatedTarget = J, F = t);
                  J = F;
                  if (k2 && n) b: {
                    t = k2;
                    x = n;
                    w = 0;
                    for (u = t; u; u = vf(u)) w++;
                    u = 0;
                    for (F = x; F; F = vf(F)) u++;
                    for (; 0 < w - u; ) t = vf(t), w--;
                    for (; 0 < u - w; ) x = vf(x), u--;
                    for (; w--; ) {
                      if (t === x || null !== x && t === x.alternate) break b;
                      t = vf(t);
                      x = vf(x);
                    }
                    t = null;
                  }
                  else t = null;
                  null !== k2 && wf(g2, h2, k2, t, false);
                  null !== n && null !== J && wf(g2, J, n, t, true);
                }
              }
            }
            a: {
              h2 = d2 ? ue(d2) : window;
              k2 = h2.nodeName && h2.nodeName.toLowerCase();
              if ("select" === k2 || "input" === k2 && "file" === h2.type) var na = ve;
              else if (me(h2)) if (we) na = Fe;
              else {
                na = De;
                var xa = Ce;
              }
              else (k2 = h2.nodeName) && "input" === k2.toLowerCase() && ("checkbox" === h2.type || "radio" === h2.type) && (na = Ee);
              if (na && (na = na(a, d2))) {
                ne(g2, na, c, e2);
                break a;
              }
              xa && xa(a, h2, d2);
              "focusout" === a && (xa = h2._wrapperState) && xa.controlled && "number" === h2.type && cb(h2, "number", h2.value);
            }
            xa = d2 ? ue(d2) : window;
            switch (a) {
              case "focusin":
                if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d2, Se = null;
                break;
              case "focusout":
                Se = Re = Qe = null;
                break;
              case "mousedown":
                Te = true;
                break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                Te = false;
                Ue(g2, c, e2);
                break;
              case "selectionchange":
                if (Pe) break;
              case "keydown":
              case "keyup":
                Ue(g2, c, e2);
            }
            var $a;
            if (ae) b: {
              switch (a) {
                case "compositionstart":
                  var ba = "onCompositionStart";
                  break b;
                case "compositionend":
                  ba = "onCompositionEnd";
                  break b;
                case "compositionupdate":
                  ba = "onCompositionUpdate";
                  break b;
              }
              ba = void 0;
            }
            else ie ? ge(a, c) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (ba = "onCompositionStart");
            ba && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e2, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d2, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c, e2), g2.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c), null !== $a && (ba.data = $a))));
            if ($a = ce ? je(a, c) : ke(a, c)) d2 = oe(d2, "onBeforeInput"), 0 < d2.length && (e2 = new Ld("onBeforeInput", "beforeinput", null, c, e2), g2.push({ event: e2, listeners: d2 }), e2.data = $a);
          }
          se(g2, b);
        });
      }
      function tf(a, b, c) {
        return { instance: a, listener: b, currentTarget: c };
      }
      function oe(a, b) {
        for (var c = b + "Capture", d = []; null !== a; ) {
          var e = a, f = e.stateNode;
          5 === e.tag && null !== f && (e = f, f = Kb(a, c), null != f && d.unshift(tf(a, f, e)), f = Kb(a, b), null != f && d.push(tf(a, f, e)));
          a = a.return;
        }
        return d;
      }
      function vf(a) {
        if (null === a) return null;
        do
          a = a.return;
        while (a && 5 !== a.tag);
        return a ? a : null;
      }
      function wf(a, b, c, d, e) {
        for (var f = b._reactName, g = []; null !== c && c !== d; ) {
          var h = c, k = h.alternate, l = h.stateNode;
          if (null !== k && k === d) break;
          5 === h.tag && null !== l && (h = l, e ? (k = Kb(c, f), null != k && g.unshift(tf(c, k, h))) : e || (k = Kb(c, f), null != k && g.push(tf(c, k, h))));
          c = c.return;
        }
        0 !== g.length && a.push({ event: b, listeners: g });
      }
      var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
      function zf(a) {
        return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
      }
      function Af(a, b, c) {
        b = zf(b);
        if (zf(a) !== b && c) throw Error(p(425));
      }
      function Bf() {
      }
      var Cf = null, Df = null;
      function Ef(a, b) {
        return "textarea" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
      }
      var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
        return Hf.resolve(null).then(a).catch(If);
      } : Ff;
      function If(a) {
        setTimeout(function() {
          throw a;
        });
      }
      function Kf(a, b) {
        var c = b, d = 0;
        do {
          var e = c.nextSibling;
          a.removeChild(c);
          if (e && 8 === e.nodeType) if (c = e.data, "/$" === c) {
            if (0 === d) {
              a.removeChild(e);
              bd(b);
              return;
            }
            d--;
          } else "$" !== c && "$?" !== c && "$!" !== c || d++;
          c = e;
        } while (c);
        bd(b);
      }
      function Lf(a) {
        for (; null != a; a = a.nextSibling) {
          var b = a.nodeType;
          if (1 === b || 3 === b) break;
          if (8 === b) {
            b = a.data;
            if ("$" === b || "$!" === b || "$?" === b) break;
            if ("/$" === b) return null;
          }
        }
        return a;
      }
      function Mf(a) {
        a = a.previousSibling;
        for (var b = 0; a; ) {
          if (8 === a.nodeType) {
            var c = a.data;
            if ("$" === c || "$!" === c || "$?" === c) {
              if (0 === b) return a;
              b--;
            } else "/$" === c && b++;
          }
          a = a.previousSibling;
        }
        return null;
      }
      var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
      function Wc(a) {
        var b = a[Of];
        if (b) return b;
        for (var c = a.parentNode; c; ) {
          if (b = c[uf] || c[Of]) {
            c = b.alternate;
            if (null !== b.child || null !== c && null !== c.child) for (a = Mf(a); null !== a; ) {
              if (c = a[Of]) return c;
              a = Mf(a);
            }
            return b;
          }
          a = c;
          c = a.parentNode;
        }
        return null;
      }
      function Cb(a) {
        a = a[Of] || a[uf];
        return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
      }
      function ue(a) {
        if (5 === a.tag || 6 === a.tag) return a.stateNode;
        throw Error(p(33));
      }
      function Db(a) {
        return a[Pf] || null;
      }
      var Sf = [], Tf = -1;
      function Uf(a) {
        return { current: a };
      }
      function E(a) {
        0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
      }
      function G(a, b) {
        Tf++;
        Sf[Tf] = a.current;
        a.current = b;
      }
      var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
      function Yf(a, b) {
        var c = a.type.contextTypes;
        if (!c) return Vf;
        var d = a.stateNode;
        if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
        var e = {}, f;
        for (f in c) e[f] = b[f];
        d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
        return e;
      }
      function Zf(a) {
        a = a.childContextTypes;
        return null !== a && void 0 !== a;
      }
      function $f() {
        E(Wf);
        E(H);
      }
      function ag(a, b, c) {
        if (H.current !== Vf) throw Error(p(168));
        G(H, b);
        G(Wf, c);
      }
      function bg(a, b, c) {
        var d = a.stateNode;
        b = b.childContextTypes;
        if ("function" !== typeof d.getChildContext) return c;
        d = d.getChildContext();
        for (var e in d) if (!(e in b)) throw Error(p(108, Ra(a) || "Unknown", e));
        return A({}, c, d);
      }
      function cg(a) {
        a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
        Xf = H.current;
        G(H, a);
        G(Wf, Wf.current);
        return true;
      }
      function dg(a, b, c) {
        var d = a.stateNode;
        if (!d) throw Error(p(169));
        c ? (a = bg(a, b, Xf), d.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
        G(Wf, c);
      }
      var eg = null, fg = false, gg = false;
      function hg(a) {
        null === eg ? eg = [a] : eg.push(a);
      }
      function ig(a) {
        fg = true;
        hg(a);
      }
      function jg() {
        if (!gg && null !== eg) {
          gg = true;
          var a = 0, b = C;
          try {
            var c = eg;
            for (C = 1; a < c.length; a++) {
              var d = c[a];
              do
                d = d(true);
              while (null !== d);
            }
            eg = null;
            fg = false;
          } catch (e) {
            throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e;
          } finally {
            C = b, gg = false;
          }
        }
        return null;
      }
      var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
      function tg(a, b) {
        kg[lg++] = ng;
        kg[lg++] = mg;
        mg = a;
        ng = b;
      }
      function ug(a, b, c) {
        og[pg++] = rg;
        og[pg++] = sg;
        og[pg++] = qg;
        qg = a;
        var d = rg;
        a = sg;
        var e = 32 - oc(d) - 1;
        d &= ~(1 << e);
        c += 1;
        var f = 32 - oc(b) + e;
        if (30 < f) {
          var g = e - e % 5;
          f = (d & (1 << g) - 1).toString(32);
          d >>= g;
          e -= g;
          rg = 1 << 32 - oc(b) + e | c << e | d;
          sg = f + a;
        } else rg = 1 << f | c << e | d, sg = a;
      }
      function vg(a) {
        null !== a.return && (tg(a, 1), ug(a, 1, 0));
      }
      function wg(a) {
        for (; a === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
        for (; a === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
      }
      var xg = null, yg = null, I = false, zg = null;
      function Ag(a, b) {
        var c = Bg(5, null, null, 0);
        c.elementType = "DELETED";
        c.stateNode = b;
        c.return = a;
        b = a.deletions;
        null === b ? (a.deletions = [c], a.flags |= 16) : b.push(c);
      }
      function Cg(a, b) {
        switch (a.tag) {
          case 5:
            var c = a.type;
            b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
            return null !== b ? (a.stateNode = b, xg = a, yg = Lf(b.firstChild), true) : false;
          case 6:
            return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, xg = a, yg = null, true) : false;
          case 13:
            return b = 8 !== b.nodeType ? null : b, null !== b ? (c = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b, treeContext: c, retryLane: 1073741824 }, c = Bg(18, null, null, 0), c.stateNode = b, c.return = a, a.child = c, xg = a, yg = null, true) : false;
          default:
            return false;
        }
      }
      function Dg(a) {
        return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
      }
      function Eg(a) {
        if (I) {
          var b = yg;
          if (b) {
            var c = b;
            if (!Cg(a, b)) {
              if (Dg(a)) throw Error(p(418));
              b = Lf(c.nextSibling);
              var d = xg;
              b && Cg(a, b) ? Ag(d, c) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
            }
          } else {
            if (Dg(a)) throw Error(p(418));
            a.flags = a.flags & -4097 | 2;
            I = false;
            xg = a;
          }
        }
      }
      function Fg(a) {
        for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; ) a = a.return;
        xg = a;
      }
      function Gg(a) {
        if (a !== xg) return false;
        if (!I) return Fg(a), I = true, false;
        var b;
        (b = 3 !== a.tag) && !(b = 5 !== a.tag) && (b = a.type, b = "head" !== b && "body" !== b && !Ef(a.type, a.memoizedProps));
        if (b && (b = yg)) {
          if (Dg(a)) throw Hg(), Error(p(418));
          for (; b; ) Ag(a, b), b = Lf(b.nextSibling);
        }
        Fg(a);
        if (13 === a.tag) {
          a = a.memoizedState;
          a = null !== a ? a.dehydrated : null;
          if (!a) throw Error(p(317));
          a: {
            a = a.nextSibling;
            for (b = 0; a; ) {
              if (8 === a.nodeType) {
                var c = a.data;
                if ("/$" === c) {
                  if (0 === b) {
                    yg = Lf(a.nextSibling);
                    break a;
                  }
                  b--;
                } else "$" !== c && "$!" !== c && "$?" !== c || b++;
              }
              a = a.nextSibling;
            }
            yg = null;
          }
        } else yg = xg ? Lf(a.stateNode.nextSibling) : null;
        return true;
      }
      function Hg() {
        for (var a = yg; a; ) a = Lf(a.nextSibling);
      }
      function Ig() {
        yg = xg = null;
        I = false;
      }
      function Jg(a) {
        null === zg ? zg = [a] : zg.push(a);
      }
      var Kg = ua.ReactCurrentBatchConfig;
      function Lg(a, b, c) {
        a = c.ref;
        if (null !== a && "function" !== typeof a && "object" !== typeof a) {
          if (c._owner) {
            c = c._owner;
            if (c) {
              if (1 !== c.tag) throw Error(p(309));
              var d = c.stateNode;
            }
            if (!d) throw Error(p(147, a));
            var e = d, f = "" + a;
            if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f) return b.ref;
            b = function(a2) {
              var b2 = e.refs;
              null === a2 ? delete b2[f] : b2[f] = a2;
            };
            b._stringRef = f;
            return b;
          }
          if ("string" !== typeof a) throw Error(p(284));
          if (!c._owner) throw Error(p(290, a));
        }
        return a;
      }
      function Mg(a, b) {
        a = Object.prototype.toString.call(b);
        throw Error(p(31, "[object Object]" === a ? "object with keys {" + Object.keys(b).join(", ") + "}" : a));
      }
      function Ng(a) {
        var b = a._init;
        return b(a._payload);
      }
      function Og(a) {
        function b(b2, c2) {
          if (a) {
            var d2 = b2.deletions;
            null === d2 ? (b2.deletions = [c2], b2.flags |= 16) : d2.push(c2);
          }
        }
        function c(c2, d2) {
          if (!a) return null;
          for (; null !== d2; ) b(c2, d2), d2 = d2.sibling;
          return null;
        }
        function d(a2, b2) {
          for (a2 = /* @__PURE__ */ new Map(); null !== b2; ) null !== b2.key ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
          return a2;
        }
        function e(a2, b2) {
          a2 = Pg(a2, b2);
          a2.index = 0;
          a2.sibling = null;
          return a2;
        }
        function f(b2, c2, d2) {
          b2.index = d2;
          if (!a) return b2.flags |= 1048576, c2;
          d2 = b2.alternate;
          if (null !== d2) return d2 = d2.index, d2 < c2 ? (b2.flags |= 2, c2) : d2;
          b2.flags |= 2;
          return c2;
        }
        function g(b2) {
          a && null === b2.alternate && (b2.flags |= 2);
          return b2;
        }
        function h(a2, b2, c2, d2) {
          if (null === b2 || 6 !== b2.tag) return b2 = Qg(c2, a2.mode, d2), b2.return = a2, b2;
          b2 = e(b2, c2);
          b2.return = a2;
          return b2;
        }
        function k(a2, b2, c2, d2) {
          var f2 = c2.type;
          if (f2 === ya) return m(a2, b2, c2.props.children, d2, c2.key);
          if (null !== b2 && (b2.elementType === f2 || "object" === typeof f2 && null !== f2 && f2.$$typeof === Ha && Ng(f2) === b2.type)) return d2 = e(b2, c2.props), d2.ref = Lg(a2, b2, c2), d2.return = a2, d2;
          d2 = Rg(c2.type, c2.key, c2.props, null, a2.mode, d2);
          d2.ref = Lg(a2, b2, c2);
          d2.return = a2;
          return d2;
        }
        function l(a2, b2, c2, d2) {
          if (null === b2 || 4 !== b2.tag || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation) return b2 = Sg(c2, a2.mode, d2), b2.return = a2, b2;
          b2 = e(b2, c2.children || []);
          b2.return = a2;
          return b2;
        }
        function m(a2, b2, c2, d2, f2) {
          if (null === b2 || 7 !== b2.tag) return b2 = Tg(c2, a2.mode, d2, f2), b2.return = a2, b2;
          b2 = e(b2, c2);
          b2.return = a2;
          return b2;
        }
        function q(a2, b2, c2) {
          if ("string" === typeof b2 && "" !== b2 || "number" === typeof b2) return b2 = Qg("" + b2, a2.mode, c2), b2.return = a2, b2;
          if ("object" === typeof b2 && null !== b2) {
            switch (b2.$$typeof) {
              case va:
                return c2 = Rg(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = Lg(a2, null, b2), c2.return = a2, c2;
              case wa:
                return b2 = Sg(b2, a2.mode, c2), b2.return = a2, b2;
              case Ha:
                var d2 = b2._init;
                return q(a2, d2(b2._payload), c2);
            }
            if (eb(b2) || Ka(b2)) return b2 = Tg(b2, a2.mode, c2, null), b2.return = a2, b2;
            Mg(a2, b2);
          }
          return null;
        }
        function r(a2, b2, c2, d2) {
          var e2 = null !== b2 ? b2.key : null;
          if ("string" === typeof c2 && "" !== c2 || "number" === typeof c2) return null !== e2 ? null : h(a2, b2, "" + c2, d2);
          if ("object" === typeof c2 && null !== c2) {
            switch (c2.$$typeof) {
              case va:
                return c2.key === e2 ? k(a2, b2, c2, d2) : null;
              case wa:
                return c2.key === e2 ? l(a2, b2, c2, d2) : null;
              case Ha:
                return e2 = c2._init, r(
                  a2,
                  b2,
                  e2(c2._payload),
                  d2
                );
            }
            if (eb(c2) || Ka(c2)) return null !== e2 ? null : m(a2, b2, c2, d2, null);
            Mg(a2, c2);
          }
          return null;
        }
        function y(a2, b2, c2, d2, e2) {
          if ("string" === typeof d2 && "" !== d2 || "number" === typeof d2) return a2 = a2.get(c2) || null, h(b2, a2, "" + d2, e2);
          if ("object" === typeof d2 && null !== d2) {
            switch (d2.$$typeof) {
              case va:
                return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, k(b2, a2, d2, e2);
              case wa:
                return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, l(b2, a2, d2, e2);
              case Ha:
                var f2 = d2._init;
                return y(a2, b2, c2, f2(d2._payload), e2);
            }
            if (eb(d2) || Ka(d2)) return a2 = a2.get(c2) || null, m(b2, a2, d2, e2, null);
            Mg(b2, d2);
          }
          return null;
        }
        function n(e2, g2, h2, k2) {
          for (var l2 = null, m2 = null, u = g2, w = g2 = 0, x = null; null !== u && w < h2.length; w++) {
            u.index > w ? (x = u, u = null) : x = u.sibling;
            var n2 = r(e2, u, h2[w], k2);
            if (null === n2) {
              null === u && (u = x);
              break;
            }
            a && u && null === n2.alternate && b(e2, u);
            g2 = f(n2, g2, w);
            null === m2 ? l2 = n2 : m2.sibling = n2;
            m2 = n2;
            u = x;
          }
          if (w === h2.length) return c(e2, u), I && tg(e2, w), l2;
          if (null === u) {
            for (; w < h2.length; w++) u = q(e2, h2[w], k2), null !== u && (g2 = f(u, g2, w), null === m2 ? l2 = u : m2.sibling = u, m2 = u);
            I && tg(e2, w);
            return l2;
          }
          for (u = d(e2, u); w < h2.length; w++) x = y(u, e2, w, h2[w], k2), null !== x && (a && null !== x.alternate && u.delete(null === x.key ? w : x.key), g2 = f(x, g2, w), null === m2 ? l2 = x : m2.sibling = x, m2 = x);
          a && u.forEach(function(a2) {
            return b(e2, a2);
          });
          I && tg(e2, w);
          return l2;
        }
        function t(e2, g2, h2, k2) {
          var l2 = Ka(h2);
          if ("function" !== typeof l2) throw Error(p(150));
          h2 = l2.call(h2);
          if (null == h2) throw Error(p(151));
          for (var u = l2 = null, m2 = g2, w = g2 = 0, x = null, n2 = h2.next(); null !== m2 && !n2.done; w++, n2 = h2.next()) {
            m2.index > w ? (x = m2, m2 = null) : x = m2.sibling;
            var t2 = r(e2, m2, n2.value, k2);
            if (null === t2) {
              null === m2 && (m2 = x);
              break;
            }
            a && m2 && null === t2.alternate && b(e2, m2);
            g2 = f(t2, g2, w);
            null === u ? l2 = t2 : u.sibling = t2;
            u = t2;
            m2 = x;
          }
          if (n2.done) return c(
            e2,
            m2
          ), I && tg(e2, w), l2;
          if (null === m2) {
            for (; !n2.done; w++, n2 = h2.next()) n2 = q(e2, n2.value, k2), null !== n2 && (g2 = f(n2, g2, w), null === u ? l2 = n2 : u.sibling = n2, u = n2);
            I && tg(e2, w);
            return l2;
          }
          for (m2 = d(e2, m2); !n2.done; w++, n2 = h2.next()) n2 = y(m2, e2, w, n2.value, k2), null !== n2 && (a && null !== n2.alternate && m2.delete(null === n2.key ? w : n2.key), g2 = f(n2, g2, w), null === u ? l2 = n2 : u.sibling = n2, u = n2);
          a && m2.forEach(function(a2) {
            return b(e2, a2);
          });
          I && tg(e2, w);
          return l2;
        }
        function J(a2, d2, f2, h2) {
          "object" === typeof f2 && null !== f2 && f2.type === ya && null === f2.key && (f2 = f2.props.children);
          if ("object" === typeof f2 && null !== f2) {
            switch (f2.$$typeof) {
              case va:
                a: {
                  for (var k2 = f2.key, l2 = d2; null !== l2; ) {
                    if (l2.key === k2) {
                      k2 = f2.type;
                      if (k2 === ya) {
                        if (7 === l2.tag) {
                          c(a2, l2.sibling);
                          d2 = e(l2, f2.props.children);
                          d2.return = a2;
                          a2 = d2;
                          break a;
                        }
                      } else if (l2.elementType === k2 || "object" === typeof k2 && null !== k2 && k2.$$typeof === Ha && Ng(k2) === l2.type) {
                        c(a2, l2.sibling);
                        d2 = e(l2, f2.props);
                        d2.ref = Lg(a2, l2, f2);
                        d2.return = a2;
                        a2 = d2;
                        break a;
                      }
                      c(a2, l2);
                      break;
                    } else b(a2, l2);
                    l2 = l2.sibling;
                  }
                  f2.type === ya ? (d2 = Tg(f2.props.children, a2.mode, h2, f2.key), d2.return = a2, a2 = d2) : (h2 = Rg(f2.type, f2.key, f2.props, null, a2.mode, h2), h2.ref = Lg(a2, d2, f2), h2.return = a2, a2 = h2);
                }
                return g(a2);
              case wa:
                a: {
                  for (l2 = f2.key; null !== d2; ) {
                    if (d2.key === l2) if (4 === d2.tag && d2.stateNode.containerInfo === f2.containerInfo && d2.stateNode.implementation === f2.implementation) {
                      c(a2, d2.sibling);
                      d2 = e(d2, f2.children || []);
                      d2.return = a2;
                      a2 = d2;
                      break a;
                    } else {
                      c(a2, d2);
                      break;
                    }
                    else b(a2, d2);
                    d2 = d2.sibling;
                  }
                  d2 = Sg(f2, a2.mode, h2);
                  d2.return = a2;
                  a2 = d2;
                }
                return g(a2);
              case Ha:
                return l2 = f2._init, J(a2, d2, l2(f2._payload), h2);
            }
            if (eb(f2)) return n(a2, d2, f2, h2);
            if (Ka(f2)) return t(a2, d2, f2, h2);
            Mg(a2, f2);
          }
          return "string" === typeof f2 && "" !== f2 || "number" === typeof f2 ? (f2 = "" + f2, null !== d2 && 6 === d2.tag ? (c(a2, d2.sibling), d2 = e(d2, f2), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = Qg(f2, a2.mode, h2), d2.return = a2, a2 = d2), g(a2)) : c(a2, d2);
        }
        return J;
      }
      var Ug = Og(true), Vg = Og(false), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
      function $g() {
        Zg = Yg = Xg = null;
      }
      function ah(a) {
        var b = Wg.current;
        E(Wg);
        a._currentValue = b;
      }
      function bh(a, b, c) {
        for (; null !== a; ) {
          var d = a.alternate;
          (a.childLanes & b) !== b ? (a.childLanes |= b, null !== d && (d.childLanes |= b)) : null !== d && (d.childLanes & b) !== b && (d.childLanes |= b);
          if (a === c) break;
          a = a.return;
        }
      }
      function ch(a, b) {
        Xg = a;
        Zg = Yg = null;
        a = a.dependencies;
        null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (dh = true), a.firstContext = null);
      }
      function eh(a) {
        var b = a._currentValue;
        if (Zg !== a) if (a = { context: a, memoizedValue: b, next: null }, null === Yg) {
          if (null === Xg) throw Error(p(308));
          Yg = a;
          Xg.dependencies = { lanes: 0, firstContext: a };
        } else Yg = Yg.next = a;
        return b;
      }
      var fh = null;
      function gh(a) {
        null === fh ? fh = [a] : fh.push(a);
      }
      function hh(a, b, c, d) {
        var e = b.interleaved;
        null === e ? (c.next = c, gh(b)) : (c.next = e.next, e.next = c);
        b.interleaved = c;
        return ih(a, d);
      }
      function ih(a, b) {
        a.lanes |= b;
        var c = a.alternate;
        null !== c && (c.lanes |= b);
        c = a;
        for (a = a.return; null !== a; ) a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
        return 3 === c.tag ? c.stateNode : null;
      }
      var jh = false;
      function kh(a) {
        a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
      }
      function lh(a, b) {
        a = a.updateQueue;
        b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
      }
      function mh(a, b) {
        return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };
      }
      function nh(a, b, c) {
        var d = a.updateQueue;
        if (null === d) return null;
        d = d.shared;
        if (0 !== (K & 2)) {
          var e = d.pending;
          null === e ? b.next = b : (b.next = e.next, e.next = b);
          d.pending = b;
          return ih(a, c);
        }
        e = d.interleaved;
        null === e ? (b.next = b, gh(d)) : (b.next = e.next, e.next = b);
        d.interleaved = b;
        return ih(a, c);
      }
      function oh(a, b, c) {
        b = b.updateQueue;
        if (null !== b && (b = b.shared, 0 !== (c & 4194240))) {
          var d = b.lanes;
          d &= a.pendingLanes;
          c |= d;
          b.lanes = c;
          Cc(a, c);
        }
      }
      function ph(a, b) {
        var c = a.updateQueue, d = a.alternate;
        if (null !== d && (d = d.updateQueue, c === d)) {
          var e = null, f = null;
          c = c.firstBaseUpdate;
          if (null !== c) {
            do {
              var g = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
              null === f ? e = f = g : f = f.next = g;
              c = c.next;
            } while (null !== c);
            null === f ? e = f = b : f = f.next = b;
          } else e = f = b;
          c = { baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f, shared: d.shared, effects: d.effects };
          a.updateQueue = c;
          return;
        }
        a = c.lastBaseUpdate;
        null === a ? c.firstBaseUpdate = b : a.next = b;
        c.lastBaseUpdate = b;
      }
      function qh(a, b, c, d) {
        var e = a.updateQueue;
        jh = false;
        var f = e.firstBaseUpdate, g = e.lastBaseUpdate, h = e.shared.pending;
        if (null !== h) {
          e.shared.pending = null;
          var k = h, l = k.next;
          k.next = null;
          null === g ? f = l : g.next = l;
          g = k;
          var m = a.alternate;
          null !== m && (m = m.updateQueue, h = m.lastBaseUpdate, h !== g && (null === h ? m.firstBaseUpdate = l : h.next = l, m.lastBaseUpdate = k));
        }
        if (null !== f) {
          var q = e.baseState;
          g = 0;
          m = l = k = null;
          h = f;
          do {
            var r = h.lane, y = h.eventTime;
            if ((d & r) === r) {
              null !== m && (m = m.next = {
                eventTime: y,
                lane: 0,
                tag: h.tag,
                payload: h.payload,
                callback: h.callback,
                next: null
              });
              a: {
                var n = a, t = h;
                r = b;
                y = c;
                switch (t.tag) {
                  case 1:
                    n = t.payload;
                    if ("function" === typeof n) {
                      q = n.call(y, q, r);
                      break a;
                    }
                    q = n;
                    break a;
                  case 3:
                    n.flags = n.flags & -65537 | 128;
                  case 0:
                    n = t.payload;
                    r = "function" === typeof n ? n.call(y, q, r) : n;
                    if (null === r || void 0 === r) break a;
                    q = A({}, q, r);
                    break a;
                  case 2:
                    jh = true;
                }
              }
              null !== h.callback && 0 !== h.lane && (a.flags |= 64, r = e.effects, null === r ? e.effects = [h] : r.push(h));
            } else y = { eventTime: y, lane: r, tag: h.tag, payload: h.payload, callback: h.callback, next: null }, null === m ? (l = m = y, k = q) : m = m.next = y, g |= r;
            h = h.next;
            if (null === h) if (h = e.shared.pending, null === h) break;
            else r = h, h = r.next, r.next = null, e.lastBaseUpdate = r, e.shared.pending = null;
          } while (1);
          null === m && (k = q);
          e.baseState = k;
          e.firstBaseUpdate = l;
          e.lastBaseUpdate = m;
          b = e.shared.interleaved;
          if (null !== b) {
            e = b;
            do
              g |= e.lane, e = e.next;
            while (e !== b);
          } else null === f && (e.shared.lanes = 0);
          rh |= g;
          a.lanes = g;
          a.memoizedState = q;
        }
      }
      function sh(a, b, c) {
        a = b.effects;
        b.effects = null;
        if (null !== a) for (b = 0; b < a.length; b++) {
          var d = a[b], e = d.callback;
          if (null !== e) {
            d.callback = null;
            d = c;
            if ("function" !== typeof e) throw Error(p(191, e));
            e.call(d);
          }
        }
      }
      var th = {}, uh = Uf(th), vh = Uf(th), wh = Uf(th);
      function xh(a) {
        if (a === th) throw Error(p(174));
        return a;
      }
      function yh(a, b) {
        G(wh, b);
        G(vh, a);
        G(uh, th);
        a = b.nodeType;
        switch (a) {
          case 9:
          case 11:
            b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
            break;
          default:
            a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = lb(b, a);
        }
        E(uh);
        G(uh, b);
      }
      function zh() {
        E(uh);
        E(vh);
        E(wh);
      }
      function Ah(a) {
        xh(wh.current);
        var b = xh(uh.current);
        var c = lb(b, a.type);
        b !== c && (G(vh, a), G(uh, c));
      }
      function Bh(a) {
        vh.current === a && (E(uh), E(vh));
      }
      var L = Uf(0);
      function Ch(a) {
        for (var b = a; null !== b; ) {
          if (13 === b.tag) {
            var c = b.memoizedState;
            if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data)) return b;
          } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
            if (0 !== (b.flags & 128)) return b;
          } else if (null !== b.child) {
            b.child.return = b;
            b = b.child;
            continue;
          }
          if (b === a) break;
          for (; null === b.sibling; ) {
            if (null === b.return || b.return === a) return null;
            b = b.return;
          }
          b.sibling.return = b.return;
          b = b.sibling;
        }
        return null;
      }
      var Dh = [];
      function Eh() {
        for (var a = 0; a < Dh.length; a++) Dh[a]._workInProgressVersionPrimary = null;
        Dh.length = 0;
      }
      var Fh = ua.ReactCurrentDispatcher, Gh = ua.ReactCurrentBatchConfig, Hh = 0, M = null, N = null, O = null, Ih = false, Jh = false, Kh = 0, Lh = 0;
      function P() {
        throw Error(p(321));
      }
      function Mh(a, b) {
        if (null === b) return false;
        for (var c = 0; c < b.length && c < a.length; c++) if (!He(a[c], b[c])) return false;
        return true;
      }
      function Nh(a, b, c, d, e, f) {
        Hh = f;
        M = b;
        b.memoizedState = null;
        b.updateQueue = null;
        b.lanes = 0;
        Fh.current = null === a || null === a.memoizedState ? Oh : Ph;
        a = c(d, e);
        if (Jh) {
          f = 0;
          do {
            Jh = false;
            Kh = 0;
            if (25 <= f) throw Error(p(301));
            f += 1;
            O = N = null;
            b.updateQueue = null;
            Fh.current = Qh;
            a = c(d, e);
          } while (Jh);
        }
        Fh.current = Rh;
        b = null !== N && null !== N.next;
        Hh = 0;
        O = N = M = null;
        Ih = false;
        if (b) throw Error(p(300));
        return a;
      }
      function Sh() {
        var a = 0 !== Kh;
        Kh = 0;
        return a;
      }
      function Th() {
        var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
        null === O ? M.memoizedState = O = a : O = O.next = a;
        return O;
      }
      function Uh() {
        if (null === N) {
          var a = M.alternate;
          a = null !== a ? a.memoizedState : null;
        } else a = N.next;
        var b = null === O ? M.memoizedState : O.next;
        if (null !== b) O = b, N = a;
        else {
          if (null === a) throw Error(p(310));
          N = a;
          a = { memoizedState: N.memoizedState, baseState: N.baseState, baseQueue: N.baseQueue, queue: N.queue, next: null };
          null === O ? M.memoizedState = O = a : O = O.next = a;
        }
        return O;
      }
      function Vh(a, b) {
        return "function" === typeof b ? b(a) : b;
      }
      function Wh(a) {
        var b = Uh(), c = b.queue;
        if (null === c) throw Error(p(311));
        c.lastRenderedReducer = a;
        var d = N, e = d.baseQueue, f = c.pending;
        if (null !== f) {
          if (null !== e) {
            var g = e.next;
            e.next = f.next;
            f.next = g;
          }
          d.baseQueue = e = f;
          c.pending = null;
        }
        if (null !== e) {
          f = e.next;
          d = d.baseState;
          var h = g = null, k = null, l = f;
          do {
            var m = l.lane;
            if ((Hh & m) === m) null !== k && (k = k.next = { lane: 0, action: l.action, hasEagerState: l.hasEagerState, eagerState: l.eagerState, next: null }), d = l.hasEagerState ? l.eagerState : a(d, l.action);
            else {
              var q = {
                lane: m,
                action: l.action,
                hasEagerState: l.hasEagerState,
                eagerState: l.eagerState,
                next: null
              };
              null === k ? (h = k = q, g = d) : k = k.next = q;
              M.lanes |= m;
              rh |= m;
            }
            l = l.next;
          } while (null !== l && l !== f);
          null === k ? g = d : k.next = h;
          He(d, b.memoizedState) || (dh = true);
          b.memoizedState = d;
          b.baseState = g;
          b.baseQueue = k;
          c.lastRenderedState = d;
        }
        a = c.interleaved;
        if (null !== a) {
          e = a;
          do
            f = e.lane, M.lanes |= f, rh |= f, e = e.next;
          while (e !== a);
        } else null === e && (c.lanes = 0);
        return [b.memoizedState, c.dispatch];
      }
      function Xh(a) {
        var b = Uh(), c = b.queue;
        if (null === c) throw Error(p(311));
        c.lastRenderedReducer = a;
        var d = c.dispatch, e = c.pending, f = b.memoizedState;
        if (null !== e) {
          c.pending = null;
          var g = e = e.next;
          do
            f = a(f, g.action), g = g.next;
          while (g !== e);
          He(f, b.memoizedState) || (dh = true);
          b.memoizedState = f;
          null === b.baseQueue && (b.baseState = f);
          c.lastRenderedState = f;
        }
        return [f, d];
      }
      function Yh() {
      }
      function Zh(a, b) {
        var c = M, d = Uh(), e = b(), f = !He(d.memoizedState, e);
        f && (d.memoizedState = e, dh = true);
        d = d.queue;
        $h(ai.bind(null, c, d, a), [a]);
        if (d.getSnapshot !== b || f || null !== O && O.memoizedState.tag & 1) {
          c.flags |= 2048;
          bi(9, ci.bind(null, c, d, e, b), void 0, null);
          if (null === Q) throw Error(p(349));
          0 !== (Hh & 30) || di(c, b, e);
        }
        return e;
      }
      function di(a, b, c) {
        a.flags |= 16384;
        a = { getSnapshot: b, value: c };
        b = M.updateQueue;
        null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.stores = [a]) : (c = b.stores, null === c ? b.stores = [a] : c.push(a));
      }
      function ci(a, b, c, d) {
        b.value = c;
        b.getSnapshot = d;
        ei(b) && fi(a);
      }
      function ai(a, b, c) {
        return c(function() {
          ei(b) && fi(a);
        });
      }
      function ei(a) {
        var b = a.getSnapshot;
        a = a.value;
        try {
          var c = b();
          return !He(a, c);
        } catch (d) {
          return true;
        }
      }
      function fi(a) {
        var b = ih(a, 1);
        null !== b && gi(b, a, 1, -1);
      }
      function hi(a) {
        var b = Th();
        "function" === typeof a && (a = a());
        b.memoizedState = b.baseState = a;
        a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a };
        b.queue = a;
        a = a.dispatch = ii.bind(null, M, a);
        return [b.memoizedState, a];
      }
      function bi(a, b, c, d) {
        a = { tag: a, create: b, destroy: c, deps: d, next: null };
        b = M.updateQueue;
        null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
        return a;
      }
      function ji() {
        return Uh().memoizedState;
      }
      function ki(a, b, c, d) {
        var e = Th();
        M.flags |= a;
        e.memoizedState = bi(1 | b, c, void 0, void 0 === d ? null : d);
      }
      function li(a, b, c, d) {
        var e = Uh();
        d = void 0 === d ? null : d;
        var f = void 0;
        if (null !== N) {
          var g = N.memoizedState;
          f = g.destroy;
          if (null !== d && Mh(d, g.deps)) {
            e.memoizedState = bi(b, c, f, d);
            return;
          }
        }
        M.flags |= a;
        e.memoizedState = bi(1 | b, c, f, d);
      }
      function mi(a, b) {
        return ki(8390656, 8, a, b);
      }
      function $h(a, b) {
        return li(2048, 8, a, b);
      }
      function ni(a, b) {
        return li(4, 2, a, b);
      }
      function oi(a, b) {
        return li(4, 4, a, b);
      }
      function pi(a, b) {
        if ("function" === typeof b) return a = a(), b(a), function() {
          b(null);
        };
        if (null !== b && void 0 !== b) return a = a(), b.current = a, function() {
          b.current = null;
        };
      }
      function qi(a, b, c) {
        c = null !== c && void 0 !== c ? c.concat([a]) : null;
        return li(4, 4, pi.bind(null, b, a), c);
      }
      function ri() {
      }
      function si(a, b) {
        var c = Uh();
        b = void 0 === b ? null : b;
        var d = c.memoizedState;
        if (null !== d && null !== b && Mh(b, d[1])) return d[0];
        c.memoizedState = [a, b];
        return a;
      }
      function ti(a, b) {
        var c = Uh();
        b = void 0 === b ? null : b;
        var d = c.memoizedState;
        if (null !== d && null !== b && Mh(b, d[1])) return d[0];
        a = a();
        c.memoizedState = [a, b];
        return a;
      }
      function ui(a, b, c) {
        if (0 === (Hh & 21)) return a.baseState && (a.baseState = false, dh = true), a.memoizedState = c;
        He(c, b) || (c = yc(), M.lanes |= c, rh |= c, a.baseState = true);
        return b;
      }
      function vi(a, b) {
        var c = C;
        C = 0 !== c && 4 > c ? c : 4;
        a(true);
        var d = Gh.transition;
        Gh.transition = {};
        try {
          a(false), b();
        } finally {
          C = c, Gh.transition = d;
        }
      }
      function wi() {
        return Uh().memoizedState;
      }
      function xi(a, b, c) {
        var d = yi(a);
        c = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
        if (zi(a)) Ai(b, c);
        else if (c = hh(a, b, c, d), null !== c) {
          var e = R();
          gi(c, a, d, e);
          Bi(c, b, d);
        }
      }
      function ii(a, b, c) {
        var d = yi(a), e = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
        if (zi(a)) Ai(b, e);
        else {
          var f = a.alternate;
          if (0 === a.lanes && (null === f || 0 === f.lanes) && (f = b.lastRenderedReducer, null !== f)) try {
            var g = b.lastRenderedState, h = f(g, c);
            e.hasEagerState = true;
            e.eagerState = h;
            if (He(h, g)) {
              var k = b.interleaved;
              null === k ? (e.next = e, gh(b)) : (e.next = k.next, k.next = e);
              b.interleaved = e;
              return;
            }
          } catch (l) {
          } finally {
          }
          c = hh(a, b, e, d);
          null !== c && (e = R(), gi(c, a, d, e), Bi(c, b, d));
        }
      }
      function zi(a) {
        var b = a.alternate;
        return a === M || null !== b && b === M;
      }
      function Ai(a, b) {
        Jh = Ih = true;
        var c = a.pending;
        null === c ? b.next = b : (b.next = c.next, c.next = b);
        a.pending = b;
      }
      function Bi(a, b, c) {
        if (0 !== (c & 4194240)) {
          var d = b.lanes;
          d &= a.pendingLanes;
          c |= d;
          b.lanes = c;
          Cc(a, c);
        }
      }
      var Rh = { readContext: eh, useCallback: P, useContext: P, useEffect: P, useImperativeHandle: P, useInsertionEffect: P, useLayoutEffect: P, useMemo: P, useReducer: P, useRef: P, useState: P, useDebugValue: P, useDeferredValue: P, useTransition: P, useMutableSource: P, useSyncExternalStore: P, useId: P, unstable_isNewReconciler: false }, Oh = { readContext: eh, useCallback: function(a, b) {
        Th().memoizedState = [a, void 0 === b ? null : b];
        return a;
      }, useContext: eh, useEffect: mi, useImperativeHandle: function(a, b, c) {
        c = null !== c && void 0 !== c ? c.concat([a]) : null;
        return ki(
          4194308,
          4,
          pi.bind(null, b, a),
          c
        );
      }, useLayoutEffect: function(a, b) {
        return ki(4194308, 4, a, b);
      }, useInsertionEffect: function(a, b) {
        return ki(4, 2, a, b);
      }, useMemo: function(a, b) {
        var c = Th();
        b = void 0 === b ? null : b;
        a = a();
        c.memoizedState = [a, b];
        return a;
      }, useReducer: function(a, b, c) {
        var d = Th();
        b = void 0 !== c ? c(b) : b;
        d.memoizedState = d.baseState = b;
        a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b };
        d.queue = a;
        a = a.dispatch = xi.bind(null, M, a);
        return [d.memoizedState, a];
      }, useRef: function(a) {
        var b = Th();
        a = { current: a };
        return b.memoizedState = a;
      }, useState: hi, useDebugValue: ri, useDeferredValue: function(a) {
        return Th().memoizedState = a;
      }, useTransition: function() {
        var a = hi(false), b = a[0];
        a = vi.bind(null, a[1]);
        Th().memoizedState = a;
        return [b, a];
      }, useMutableSource: function() {
      }, useSyncExternalStore: function(a, b, c) {
        var d = M, e = Th();
        if (I) {
          if (void 0 === c) throw Error(p(407));
          c = c();
        } else {
          c = b();
          if (null === Q) throw Error(p(349));
          0 !== (Hh & 30) || di(d, b, c);
        }
        e.memoizedState = c;
        var f = { value: c, getSnapshot: b };
        e.queue = f;
        mi(ai.bind(
          null,
          d,
          f,
          a
        ), [a]);
        d.flags |= 2048;
        bi(9, ci.bind(null, d, f, c, b), void 0, null);
        return c;
      }, useId: function() {
        var a = Th(), b = Q.identifierPrefix;
        if (I) {
          var c = sg;
          var d = rg;
          c = (d & ~(1 << 32 - oc(d) - 1)).toString(32) + c;
          b = ":" + b + "R" + c;
          c = Kh++;
          0 < c && (b += "H" + c.toString(32));
          b += ":";
        } else c = Lh++, b = ":" + b + "r" + c.toString(32) + ":";
        return a.memoizedState = b;
      }, unstable_isNewReconciler: false }, Ph = {
        readContext: eh,
        useCallback: si,
        useContext: eh,
        useEffect: $h,
        useImperativeHandle: qi,
        useInsertionEffect: ni,
        useLayoutEffect: oi,
        useMemo: ti,
        useReducer: Wh,
        useRef: ji,
        useState: function() {
          return Wh(Vh);
        },
        useDebugValue: ri,
        useDeferredValue: function(a) {
          var b = Uh();
          return ui(b, N.memoizedState, a);
        },
        useTransition: function() {
          var a = Wh(Vh)[0], b = Uh().memoizedState;
          return [a, b];
        },
        useMutableSource: Yh,
        useSyncExternalStore: Zh,
        useId: wi,
        unstable_isNewReconciler: false
      }, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
        return Xh(Vh);
      }, useDebugValue: ri, useDeferredValue: function(a) {
        var b = Uh();
        return null === N ? b.memoizedState = a : ui(b, N.memoizedState, a);
      }, useTransition: function() {
        var a = Xh(Vh)[0], b = Uh().memoizedState;
        return [a, b];
      }, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
      function Ci(a, b) {
        if (a && a.defaultProps) {
          b = A({}, b);
          a = a.defaultProps;
          for (var c in a) void 0 === b[c] && (b[c] = a[c]);
          return b;
        }
        return b;
      }
      function Di(a, b, c, d) {
        b = a.memoizedState;
        c = c(d, b);
        c = null === c || void 0 === c ? b : A({}, b, c);
        a.memoizedState = c;
        0 === a.lanes && (a.updateQueue.baseState = c);
      }
      var Ei = { isMounted: function(a) {
        return (a = a._reactInternals) ? Vb(a) === a : false;
      }, enqueueSetState: function(a, b, c) {
        a = a._reactInternals;
        var d = R(), e = yi(a), f = mh(d, e);
        f.payload = b;
        void 0 !== c && null !== c && (f.callback = c);
        b = nh(a, f, e);
        null !== b && (gi(b, a, e, d), oh(b, a, e));
      }, enqueueReplaceState: function(a, b, c) {
        a = a._reactInternals;
        var d = R(), e = yi(a), f = mh(d, e);
        f.tag = 1;
        f.payload = b;
        void 0 !== c && null !== c && (f.callback = c);
        b = nh(a, f, e);
        null !== b && (gi(b, a, e, d), oh(b, a, e));
      }, enqueueForceUpdate: function(a, b) {
        a = a._reactInternals;
        var c = R(), d = yi(a), e = mh(c, d);
        e.tag = 2;
        void 0 !== b && null !== b && (e.callback = b);
        b = nh(a, e, d);
        null !== b && (gi(b, a, d, c), oh(b, a, d));
      } };
      function Fi(a, b, c, d, e, f, g) {
        a = a.stateNode;
        return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Ie(c, d) || !Ie(e, f) : true;
      }
      function Gi(a, b, c) {
        var d = false, e = Vf;
        var f = b.contextType;
        "object" === typeof f && null !== f ? f = eh(f) : (e = Zf(b) ? Xf : H.current, d = b.contextTypes, f = (d = null !== d && void 0 !== d) ? Yf(a, e) : Vf);
        b = new b(c, f);
        a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
        b.updater = Ei;
        a.stateNode = b;
        b._reactInternals = a;
        d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
        return b;
      }
      function Hi(a, b, c, d) {
        a = b.state;
        "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
        "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
        b.state !== a && Ei.enqueueReplaceState(b, b.state, null);
      }
      function Ii(a, b, c, d) {
        var e = a.stateNode;
        e.props = c;
        e.state = a.memoizedState;
        e.refs = {};
        kh(a);
        var f = b.contextType;
        "object" === typeof f && null !== f ? e.context = eh(f) : (f = Zf(b) ? Xf : H.current, e.context = Yf(a, f));
        e.state = a.memoizedState;
        f = b.getDerivedStateFromProps;
        "function" === typeof f && (Di(a, b, f, c), e.state = a.memoizedState);
        "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Ei.enqueueReplaceState(e, e.state, null), qh(a, c, e, d), e.state = a.memoizedState);
        "function" === typeof e.componentDidMount && (a.flags |= 4194308);
      }
      function Ji(a, b) {
        try {
          var c = "", d = b;
          do
            c += Pa(d), d = d.return;
          while (d);
          var e = c;
        } catch (f) {
          e = "\nError generating stack: " + f.message + "\n" + f.stack;
        }
        return { value: a, source: b, stack: e, digest: null };
      }
      function Ki(a, b, c) {
        return { value: a, source: null, stack: null != c ? c : null, digest: null != b ? b : null };
      }
      function Li(a, b) {
        try {
          console.error(b.value);
        } catch (c) {
          setTimeout(function() {
            throw c;
          });
        }
      }
      var Mi = "function" === typeof WeakMap ? WeakMap : Map;
      function Ni(a, b, c) {
        c = mh(-1, c);
        c.tag = 3;
        c.payload = { element: null };
        var d = b.value;
        c.callback = function() {
          Oi || (Oi = true, Pi = d);
          Li(a, b);
        };
        return c;
      }
      function Qi(a, b, c) {
        c = mh(-1, c);
        c.tag = 3;
        var d = a.type.getDerivedStateFromError;
        if ("function" === typeof d) {
          var e = b.value;
          c.payload = function() {
            return d(e);
          };
          c.callback = function() {
            Li(a, b);
          };
        }
        var f = a.stateNode;
        null !== f && "function" === typeof f.componentDidCatch && (c.callback = function() {
          Li(a, b);
          "function" !== typeof d && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
          var c2 = b.stack;
          this.componentDidCatch(b.value, { componentStack: null !== c2 ? c2 : "" });
        });
        return c;
      }
      function Si(a, b, c) {
        var d = a.pingCache;
        if (null === d) {
          d = a.pingCache = new Mi();
          var e = /* @__PURE__ */ new Set();
          d.set(b, e);
        } else e = d.get(b), void 0 === e && (e = /* @__PURE__ */ new Set(), d.set(b, e));
        e.has(c) || (e.add(c), a = Ti.bind(null, a, b, c), b.then(a, a));
      }
      function Ui(a) {
        do {
          var b;
          if (b = 13 === a.tag) b = a.memoizedState, b = null !== b ? null !== b.dehydrated ? true : false : true;
          if (b) return a;
          a = a.return;
        } while (null !== a);
        return null;
      }
      function Vi(a, b, c, d, e) {
        if (0 === (a.mode & 1)) return a === b ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, 1 === c.tag && (null === c.alternate ? c.tag = 17 : (b = mh(-1, 1), b.tag = 2, nh(c, b, 1))), c.lanes |= 1), a;
        a.flags |= 65536;
        a.lanes = e;
        return a;
      }
      var Wi = ua.ReactCurrentOwner, dh = false;
      function Xi(a, b, c, d) {
        b.child = null === a ? Vg(b, null, c, d) : Ug(b, a.child, c, d);
      }
      function Yi(a, b, c, d, e) {
        c = c.render;
        var f = b.ref;
        ch(b, e);
        d = Nh(a, b, c, d, f, e);
        c = Sh();
        if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e);
        I && c && vg(b);
        b.flags |= 1;
        Xi(a, b, d, e);
        return b.child;
      }
      function $i(a, b, c, d, e) {
        if (null === a) {
          var f = c.type;
          if ("function" === typeof f && !aj(f) && void 0 === f.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, b.type = f, bj(a, b, f, d, e);
          a = Rg(c.type, null, d, b, b.mode, e);
          a.ref = b.ref;
          a.return = b;
          return b.child = a;
        }
        f = a.child;
        if (0 === (a.lanes & e)) {
          var g = f.memoizedProps;
          c = c.compare;
          c = null !== c ? c : Ie;
          if (c(g, d) && a.ref === b.ref) return Zi(a, b, e);
        }
        b.flags |= 1;
        a = Pg(f, d);
        a.ref = b.ref;
        a.return = b;
        return b.child = a;
      }
      function bj(a, b, c, d, e) {
        if (null !== a) {
          var f = a.memoizedProps;
          if (Ie(f, d) && a.ref === b.ref) if (dh = false, b.pendingProps = d = f, 0 !== (a.lanes & e)) 0 !== (a.flags & 131072) && (dh = true);
          else return b.lanes = a.lanes, Zi(a, b, e);
        }
        return cj(a, b, c, d, e);
      }
      function dj(a, b, c) {
        var d = b.pendingProps, e = d.children, f = null !== a ? a.memoizedState : null;
        if ("hidden" === d.mode) if (0 === (b.mode & 1)) b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c;
        else {
          if (0 === (c & 1073741824)) return a = null !== f ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b.updateQueue = null, G(ej, fj), fj |= a, null;
          b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
          d = null !== f ? f.baseLanes : c;
          G(ej, fj);
          fj |= d;
        }
        else null !== f ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, G(ej, fj), fj |= d;
        Xi(a, b, e, c);
        return b.child;
      }
      function gj(a, b) {
        var c = b.ref;
        if (null === a && null !== c || null !== a && a.ref !== c) b.flags |= 512, b.flags |= 2097152;
      }
      function cj(a, b, c, d, e) {
        var f = Zf(c) ? Xf : H.current;
        f = Yf(b, f);
        ch(b, e);
        c = Nh(a, b, c, d, f, e);
        d = Sh();
        if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e);
        I && d && vg(b);
        b.flags |= 1;
        Xi(a, b, c, e);
        return b.child;
      }
      function hj(a, b, c, d, e) {
        if (Zf(c)) {
          var f = true;
          cg(b);
        } else f = false;
        ch(b, e);
        if (null === b.stateNode) ij(a, b), Gi(b, c, d), Ii(b, c, d, e), d = true;
        else if (null === a) {
          var g = b.stateNode, h = b.memoizedProps;
          g.props = h;
          var k = g.context, l = c.contextType;
          "object" === typeof l && null !== l ? l = eh(l) : (l = Zf(c) ? Xf : H.current, l = Yf(b, l));
          var m = c.getDerivedStateFromProps, q = "function" === typeof m || "function" === typeof g.getSnapshotBeforeUpdate;
          q || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || k !== l) && Hi(b, g, d, l);
          jh = false;
          var r = b.memoizedState;
          g.state = r;
          qh(b, d, g, e);
          k = b.memoizedState;
          h !== d || r !== k || Wf.current || jh ? ("function" === typeof m && (Di(b, c, m, d), k = b.memoizedState), (h = jh || Fi(b, c, h, d, r, k, l)) ? (q || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l, d = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), d = false);
        } else {
          g = b.stateNode;
          lh(a, b);
          h = b.memoizedProps;
          l = b.type === b.elementType ? h : Ci(b.type, h);
          g.props = l;
          q = b.pendingProps;
          r = g.context;
          k = c.contextType;
          "object" === typeof k && null !== k ? k = eh(k) : (k = Zf(c) ? Xf : H.current, k = Yf(b, k));
          var y = c.getDerivedStateFromProps;
          (m = "function" === typeof y || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== q || r !== k) && Hi(b, g, d, k);
          jh = false;
          r = b.memoizedState;
          g.state = r;
          qh(b, d, g, e);
          var n = b.memoizedState;
          h !== q || r !== n || Wf.current || jh ? ("function" === typeof y && (Di(b, c, y, d), n = b.memoizedState), (l = jh || Fi(b, c, l, d, r, n, k) || false) ? (m || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, n, k), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, n, k)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), b.memoizedProps = d, b.memoizedState = n), g.props = d, g.state = n, g.context = k, d = l) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), d = false);
        }
        return jj(a, b, c, d, f, e);
      }
      function jj(a, b, c, d, e, f) {
        gj(a, b);
        var g = 0 !== (b.flags & 128);
        if (!d && !g) return e && dg(b, c, false), Zi(a, b, f);
        d = b.stateNode;
        Wi.current = b;
        var h = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
        b.flags |= 1;
        null !== a && g ? (b.child = Ug(b, a.child, null, f), b.child = Ug(b, null, h, f)) : Xi(a, b, h, f);
        b.memoizedState = d.state;
        e && dg(b, c, true);
        return b.child;
      }
      function kj(a) {
        var b = a.stateNode;
        b.pendingContext ? ag(a, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a, b.context, false);
        yh(a, b.containerInfo);
      }
      function lj(a, b, c, d, e) {
        Ig();
        Jg(e);
        b.flags |= 256;
        Xi(a, b, c, d);
        return b.child;
      }
      var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
      function nj(a) {
        return { baseLanes: a, cachePool: null, transitions: null };
      }
      function oj(a, b, c) {
        var d = b.pendingProps, e = L.current, f = false, g = 0 !== (b.flags & 128), h;
        (h = g) || (h = null !== a && null === a.memoizedState ? false : 0 !== (e & 2));
        if (h) f = true, b.flags &= -129;
        else if (null === a || null !== a.memoizedState) e |= 1;
        G(L, e & 1);
        if (null === a) {
          Eg(b);
          a = b.memoizedState;
          if (null !== a && (a = a.dehydrated, null !== a)) return 0 === (b.mode & 1) ? b.lanes = 1 : "$!" === a.data ? b.lanes = 8 : b.lanes = 1073741824, null;
          g = d.children;
          a = d.fallback;
          return f ? (d = b.mode, f = b.child, g = { mode: "hidden", children: g }, 0 === (d & 1) && null !== f ? (f.childLanes = 0, f.pendingProps = g) : f = pj(g, d, 0, null), a = Tg(a, d, c, null), f.return = b, a.return = b, f.sibling = a, b.child = f, b.child.memoizedState = nj(c), b.memoizedState = mj, a) : qj(b, g);
        }
        e = a.memoizedState;
        if (null !== e && (h = e.dehydrated, null !== h)) return rj(a, b, g, d, h, e, c);
        if (f) {
          f = d.fallback;
          g = b.mode;
          e = a.child;
          h = e.sibling;
          var k = { mode: "hidden", children: d.children };
          0 === (g & 1) && b.child !== e ? (d = b.child, d.childLanes = 0, d.pendingProps = k, b.deletions = null) : (d = Pg(e, k), d.subtreeFlags = e.subtreeFlags & 14680064);
          null !== h ? f = Pg(h, f) : (f = Tg(f, g, c, null), f.flags |= 2);
          f.return = b;
          d.return = b;
          d.sibling = f;
          b.child = d;
          d = f;
          f = b.child;
          g = a.child.memoizedState;
          g = null === g ? nj(c) : { baseLanes: g.baseLanes | c, cachePool: null, transitions: g.transitions };
          f.memoizedState = g;
          f.childLanes = a.childLanes & ~c;
          b.memoizedState = mj;
          return d;
        }
        f = a.child;
        a = f.sibling;
        d = Pg(f, { mode: "visible", children: d.children });
        0 === (b.mode & 1) && (d.lanes = c);
        d.return = b;
        d.sibling = null;
        null !== a && (c = b.deletions, null === c ? (b.deletions = [a], b.flags |= 16) : c.push(a));
        b.child = d;
        b.memoizedState = null;
        return d;
      }
      function qj(a, b) {
        b = pj({ mode: "visible", children: b }, a.mode, 0, null);
        b.return = a;
        return a.child = b;
      }
      function sj(a, b, c, d) {
        null !== d && Jg(d);
        Ug(b, a.child, null, c);
        a = qj(b, b.pendingProps.children);
        a.flags |= 2;
        b.memoizedState = null;
        return a;
      }
      function rj(a, b, c, d, e, f, g) {
        if (c) {
          if (b.flags & 256) return b.flags &= -257, d = Ki(Error(p(422))), sj(a, b, g, d);
          if (null !== b.memoizedState) return b.child = a.child, b.flags |= 128, null;
          f = d.fallback;
          e = b.mode;
          d = pj({ mode: "visible", children: d.children }, e, 0, null);
          f = Tg(f, e, g, null);
          f.flags |= 2;
          d.return = b;
          f.return = b;
          d.sibling = f;
          b.child = d;
          0 !== (b.mode & 1) && Ug(b, a.child, null, g);
          b.child.memoizedState = nj(g);
          b.memoizedState = mj;
          return f;
        }
        if (0 === (b.mode & 1)) return sj(a, b, g, null);
        if ("$!" === e.data) {
          d = e.nextSibling && e.nextSibling.dataset;
          if (d) var h = d.dgst;
          d = h;
          f = Error(p(419));
          d = Ki(f, d, void 0);
          return sj(a, b, g, d);
        }
        h = 0 !== (g & a.childLanes);
        if (dh || h) {
          d = Q;
          if (null !== d) {
            switch (g & -g) {
              case 4:
                e = 2;
                break;
              case 16:
                e = 8;
                break;
              case 64:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
              case 67108864:
                e = 32;
                break;
              case 536870912:
                e = 268435456;
                break;
              default:
                e = 0;
            }
            e = 0 !== (e & (d.suspendedLanes | g)) ? 0 : e;
            0 !== e && e !== f.retryLane && (f.retryLane = e, ih(a, e), gi(d, a, e, -1));
          }
          tj();
          d = Ki(Error(p(421)));
          return sj(a, b, g, d);
        }
        if ("$?" === e.data) return b.flags |= 128, b.child = a.child, b = uj.bind(null, a), e._reactRetry = b, null;
        a = f.treeContext;
        yg = Lf(e.nextSibling);
        xg = b;
        I = true;
        zg = null;
        null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b);
        b = qj(b, d.children);
        b.flags |= 4096;
        return b;
      }
      function vj(a, b, c) {
        a.lanes |= b;
        var d = a.alternate;
        null !== d && (d.lanes |= b);
        bh(a.return, b, c);
      }
      function wj(a, b, c, d, e) {
        var f = a.memoizedState;
        null === f ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e } : (f.isBackwards = b, f.rendering = null, f.renderingStartTime = 0, f.last = d, f.tail = c, f.tailMode = e);
      }
      function xj(a, b, c) {
        var d = b.pendingProps, e = d.revealOrder, f = d.tail;
        Xi(a, b, d.children, c);
        d = L.current;
        if (0 !== (d & 2)) d = d & 1 | 2, b.flags |= 128;
        else {
          if (null !== a && 0 !== (a.flags & 128)) a: for (a = b.child; null !== a; ) {
            if (13 === a.tag) null !== a.memoizedState && vj(a, c, b);
            else if (19 === a.tag) vj(a, c, b);
            else if (null !== a.child) {
              a.child.return = a;
              a = a.child;
              continue;
            }
            if (a === b) break a;
            for (; null === a.sibling; ) {
              if (null === a.return || a.return === b) break a;
              a = a.return;
            }
            a.sibling.return = a.return;
            a = a.sibling;
          }
          d &= 1;
        }
        G(L, d);
        if (0 === (b.mode & 1)) b.memoizedState = null;
        else switch (e) {
          case "forwards":
            c = b.child;
            for (e = null; null !== c; ) a = c.alternate, null !== a && null === Ch(a) && (e = c), c = c.sibling;
            c = e;
            null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
            wj(b, false, e, c, f);
            break;
          case "backwards":
            c = null;
            e = b.child;
            for (b.child = null; null !== e; ) {
              a = e.alternate;
              if (null !== a && null === Ch(a)) {
                b.child = e;
                break;
              }
              a = e.sibling;
              e.sibling = c;
              c = e;
              e = a;
            }
            wj(b, true, c, null, f);
            break;
          case "together":
            wj(b, false, null, null, void 0);
            break;
          default:
            b.memoizedState = null;
        }
        return b.child;
      }
      function ij(a, b) {
        0 === (b.mode & 1) && null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
      }
      function Zi(a, b, c) {
        null !== a && (b.dependencies = a.dependencies);
        rh |= b.lanes;
        if (0 === (c & b.childLanes)) return null;
        if (null !== a && b.child !== a.child) throw Error(p(153));
        if (null !== b.child) {
          a = b.child;
          c = Pg(a, a.pendingProps);
          b.child = c;
          for (c.return = b; null !== a.sibling; ) a = a.sibling, c = c.sibling = Pg(a, a.pendingProps), c.return = b;
          c.sibling = null;
        }
        return b.child;
      }
      function yj(a, b, c) {
        switch (b.tag) {
          case 3:
            kj(b);
            Ig();
            break;
          case 5:
            Ah(b);
            break;
          case 1:
            Zf(b.type) && cg(b);
            break;
          case 4:
            yh(b, b.stateNode.containerInfo);
            break;
          case 10:
            var d = b.type._context, e = b.memoizedProps.value;
            G(Wg, d._currentValue);
            d._currentValue = e;
            break;
          case 13:
            d = b.memoizedState;
            if (null !== d) {
              if (null !== d.dehydrated) return G(L, L.current & 1), b.flags |= 128, null;
              if (0 !== (c & b.child.childLanes)) return oj(a, b, c);
              G(L, L.current & 1);
              a = Zi(a, b, c);
              return null !== a ? a.sibling : null;
            }
            G(L, L.current & 1);
            break;
          case 19:
            d = 0 !== (c & b.childLanes);
            if (0 !== (a.flags & 128)) {
              if (d) return xj(a, b, c);
              b.flags |= 128;
            }
            e = b.memoizedState;
            null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
            G(L, L.current);
            if (d) break;
            else return null;
          case 22:
          case 23:
            return b.lanes = 0, dj(a, b, c);
        }
        return Zi(a, b, c);
      }
      var zj, Aj, Bj, Cj;
      zj = function(a, b) {
        for (var c = b.child; null !== c; ) {
          if (5 === c.tag || 6 === c.tag) a.appendChild(c.stateNode);
          else if (4 !== c.tag && null !== c.child) {
            c.child.return = c;
            c = c.child;
            continue;
          }
          if (c === b) break;
          for (; null === c.sibling; ) {
            if (null === c.return || c.return === b) return;
            c = c.return;
          }
          c.sibling.return = c.return;
          c = c.sibling;
        }
      };
      Aj = function() {
      };
      Bj = function(a, b, c, d) {
        var e = a.memoizedProps;
        if (e !== d) {
          a = b.stateNode;
          xh(uh.current);
          var f = null;
          switch (c) {
            case "input":
              e = Ya(a, e);
              d = Ya(a, d);
              f = [];
              break;
            case "select":
              e = A({}, e, { value: void 0 });
              d = A({}, d, { value: void 0 });
              f = [];
              break;
            case "textarea":
              e = gb(a, e);
              d = gb(a, d);
              f = [];
              break;
            default:
              "function" !== typeof e.onClick && "function" === typeof d.onClick && (a.onclick = Bf);
          }
          ub(c, d);
          var g;
          c = null;
          for (l in e) if (!d.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l]) if ("style" === l) {
            var h = e[l];
            for (g in h) h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
          } else "dangerouslySetInnerHTML" !== l && "children" !== l && "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && "autoFocus" !== l && (ea.hasOwnProperty(l) ? f || (f = []) : (f = f || []).push(l, null));
          for (l in d) {
            var k = d[l];
            h = null != e ? e[l] : void 0;
            if (d.hasOwnProperty(l) && k !== h && (null != k || null != h)) if ("style" === l) if (h) {
              for (g in h) !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
              for (g in k) k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
            } else c || (f || (f = []), f.push(
              l,
              c
            )), c = k;
            else "dangerouslySetInnerHTML" === l ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, null != k && h !== k && (f = f || []).push(l, k)) : "children" === l ? "string" !== typeof k && "number" !== typeof k || (f = f || []).push(l, "" + k) : "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && (ea.hasOwnProperty(l) ? (null != k && "onScroll" === l && D("scroll", a), f || h === k || (f = [])) : (f = f || []).push(l, k));
          }
          c && (f = f || []).push("style", c);
          var l = f;
          if (b.updateQueue = l) b.flags |= 4;
        }
      };
      Cj = function(a, b, c, d) {
        c !== d && (b.flags |= 4);
      };
      function Dj(a, b) {
        if (!I) switch (a.tailMode) {
          case "hidden":
            b = a.tail;
            for (var c = null; null !== b; ) null !== b.alternate && (c = b), b = b.sibling;
            null === c ? a.tail = null : c.sibling = null;
            break;
          case "collapsed":
            c = a.tail;
            for (var d = null; null !== c; ) null !== c.alternate && (d = c), c = c.sibling;
            null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
        }
      }
      function S(a) {
        var b = null !== a.alternate && a.alternate.child === a.child, c = 0, d = 0;
        if (b) for (var e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags & 14680064, d |= e.flags & 14680064, e.return = a, e = e.sibling;
        else for (e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags, d |= e.flags, e.return = a, e = e.sibling;
        a.subtreeFlags |= d;
        a.childLanes = c;
        return b;
      }
      function Ej(a, b, c) {
        var d = b.pendingProps;
        wg(b);
        switch (b.tag) {
          case 2:
          case 16:
          case 15:
          case 0:
          case 11:
          case 7:
          case 8:
          case 12:
          case 9:
          case 14:
            return S(b), null;
          case 1:
            return Zf(b.type) && $f(), S(b), null;
          case 3:
            d = b.stateNode;
            zh();
            E(Wf);
            E(H);
            Eh();
            d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
            if (null === a || null === a.child) Gg(b) ? b.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, null !== zg && (Fj(zg), zg = null));
            Aj(a, b);
            S(b);
            return null;
          case 5:
            Bh(b);
            var e = xh(wh.current);
            c = b.type;
            if (null !== a && null != b.stateNode) Bj(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);
            else {
              if (!d) {
                if (null === b.stateNode) throw Error(p(166));
                S(b);
                return null;
              }
              a = xh(uh.current);
              if (Gg(b)) {
                d = b.stateNode;
                c = b.type;
                var f = b.memoizedProps;
                d[Of] = b;
                d[Pf] = f;
                a = 0 !== (b.mode & 1);
                switch (c) {
                  case "dialog":
                    D("cancel", d);
                    D("close", d);
                    break;
                  case "iframe":
                  case "object":
                  case "embed":
                    D("load", d);
                    break;
                  case "video":
                  case "audio":
                    for (e = 0; e < lf.length; e++) D(lf[e], d);
                    break;
                  case "source":
                    D("error", d);
                    break;
                  case "img":
                  case "image":
                  case "link":
                    D(
                      "error",
                      d
                    );
                    D("load", d);
                    break;
                  case "details":
                    D("toggle", d);
                    break;
                  case "input":
                    Za(d, f);
                    D("invalid", d);
                    break;
                  case "select":
                    d._wrapperState = { wasMultiple: !!f.multiple };
                    D("invalid", d);
                    break;
                  case "textarea":
                    hb(d, f), D("invalid", d);
                }
                ub(c, f);
                e = null;
                for (var g in f) if (f.hasOwnProperty(g)) {
                  var h = f[g];
                  "children" === g ? "string" === typeof h ? d.textContent !== h && (true !== f.suppressHydrationWarning && Af(d.textContent, h, a), e = ["children", h]) : "number" === typeof h && d.textContent !== "" + h && (true !== f.suppressHydrationWarning && Af(
                    d.textContent,
                    h,
                    a
                  ), e = ["children", "" + h]) : ea.hasOwnProperty(g) && null != h && "onScroll" === g && D("scroll", d);
                }
                switch (c) {
                  case "input":
                    Va(d);
                    db(d, f, true);
                    break;
                  case "textarea":
                    Va(d);
                    jb(d);
                    break;
                  case "select":
                  case "option":
                    break;
                  default:
                    "function" === typeof f.onClick && (d.onclick = Bf);
                }
                d = e;
                b.updateQueue = d;
                null !== d && (b.flags |= 4);
              } else {
                g = 9 === e.nodeType ? e : e.ownerDocument;
                "http://www.w3.org/1999/xhtml" === a && (a = kb(c));
                "http://www.w3.org/1999/xhtml" === a ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g.createElement(c, { is: d.is }) : (a = g.createElement(c), "select" === c && (g = a, d.multiple ? g.multiple = true : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
                a[Of] = b;
                a[Pf] = d;
                zj(a, b, false, false);
                b.stateNode = a;
                a: {
                  g = vb(c, d);
                  switch (c) {
                    case "dialog":
                      D("cancel", a);
                      D("close", a);
                      e = d;
                      break;
                    case "iframe":
                    case "object":
                    case "embed":
                      D("load", a);
                      e = d;
                      break;
                    case "video":
                    case "audio":
                      for (e = 0; e < lf.length; e++) D(lf[e], a);
                      e = d;
                      break;
                    case "source":
                      D("error", a);
                      e = d;
                      break;
                    case "img":
                    case "image":
                    case "link":
                      D(
                        "error",
                        a
                      );
                      D("load", a);
                      e = d;
                      break;
                    case "details":
                      D("toggle", a);
                      e = d;
                      break;
                    case "input":
                      Za(a, d);
                      e = Ya(a, d);
                      D("invalid", a);
                      break;
                    case "option":
                      e = d;
                      break;
                    case "select":
                      a._wrapperState = { wasMultiple: !!d.multiple };
                      e = A({}, d, { value: void 0 });
                      D("invalid", a);
                      break;
                    case "textarea":
                      hb(a, d);
                      e = gb(a, d);
                      D("invalid", a);
                      break;
                    default:
                      e = d;
                  }
                  ub(c, e);
                  h = e;
                  for (f in h) if (h.hasOwnProperty(f)) {
                    var k = h[f];
                    "style" === f ? sb(a, k) : "dangerouslySetInnerHTML" === f ? (k = k ? k.__html : void 0, null != k && nb(a, k)) : "children" === f ? "string" === typeof k ? ("textarea" !== c || "" !== k) && ob(a, k) : "number" === typeof k && ob(a, "" + k) : "suppressContentEditableWarning" !== f && "suppressHydrationWarning" !== f && "autoFocus" !== f && (ea.hasOwnProperty(f) ? null != k && "onScroll" === f && D("scroll", a) : null != k && ta(a, f, k, g));
                  }
                  switch (c) {
                    case "input":
                      Va(a);
                      db(a, d, false);
                      break;
                    case "textarea":
                      Va(a);
                      jb(a);
                      break;
                    case "option":
                      null != d.value && a.setAttribute("value", "" + Sa(d.value));
                      break;
                    case "select":
                      a.multiple = !!d.multiple;
                      f = d.value;
                      null != f ? fb(a, !!d.multiple, f, false) : null != d.defaultValue && fb(
                        a,
                        !!d.multiple,
                        d.defaultValue,
                        true
                      );
                      break;
                    default:
                      "function" === typeof e.onClick && (a.onclick = Bf);
                  }
                  switch (c) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      d = !!d.autoFocus;
                      break a;
                    case "img":
                      d = true;
                      break a;
                    default:
                      d = false;
                  }
                }
                d && (b.flags |= 4);
              }
              null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
            }
            S(b);
            return null;
          case 6:
            if (a && null != b.stateNode) Cj(a, b, a.memoizedProps, d);
            else {
              if ("string" !== typeof d && null === b.stateNode) throw Error(p(166));
              c = xh(wh.current);
              xh(uh.current);
              if (Gg(b)) {
                d = b.stateNode;
                c = b.memoizedProps;
                d[Of] = b;
                if (f = d.nodeValue !== c) {
                  if (a = xg, null !== a) switch (a.tag) {
                    case 3:
                      Af(d.nodeValue, c, 0 !== (a.mode & 1));
                      break;
                    case 5:
                      true !== a.memoizedProps.suppressHydrationWarning && Af(d.nodeValue, c, 0 !== (a.mode & 1));
                  }
                }
                f && (b.flags |= 4);
              } else d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[Of] = b, b.stateNode = d;
            }
            S(b);
            return null;
          case 13:
            E(L);
            d = b.memoizedState;
            if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
              if (I && null !== yg && 0 !== (b.mode & 1) && 0 === (b.flags & 128)) Hg(), Ig(), b.flags |= 98560, f = false;
              else if (f = Gg(b), null !== d && null !== d.dehydrated) {
                if (null === a) {
                  if (!f) throw Error(p(318));
                  f = b.memoizedState;
                  f = null !== f ? f.dehydrated : null;
                  if (!f) throw Error(p(317));
                  f[Of] = b;
                } else Ig(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
                S(b);
                f = false;
              } else null !== zg && (Fj(zg), zg = null), f = true;
              if (!f) return b.flags & 65536 ? b : null;
            }
            if (0 !== (b.flags & 128)) return b.lanes = c, b;
            d = null !== d;
            d !== (null !== a && null !== a.memoizedState) && d && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a || 0 !== (L.current & 1) ? 0 === T && (T = 3) : tj()));
            null !== b.updateQueue && (b.flags |= 4);
            S(b);
            return null;
          case 4:
            return zh(), Aj(a, b), null === a && sf(b.stateNode.containerInfo), S(b), null;
          case 10:
            return ah(b.type._context), S(b), null;
          case 17:
            return Zf(b.type) && $f(), S(b), null;
          case 19:
            E(L);
            f = b.memoizedState;
            if (null === f) return S(b), null;
            d = 0 !== (b.flags & 128);
            g = f.rendering;
            if (null === g) if (d) Dj(f, false);
            else {
              if (0 !== T || null !== a && 0 !== (a.flags & 128)) for (a = b.child; null !== a; ) {
                g = Ch(a);
                if (null !== g) {
                  b.flags |= 128;
                  Dj(f, false);
                  d = g.updateQueue;
                  null !== d && (b.updateQueue = d, b.flags |= 4);
                  b.subtreeFlags = 0;
                  d = c;
                  for (c = b.child; null !== c; ) f = c, a = d, f.flags &= 14680066, g = f.alternate, null === g ? (f.childLanes = 0, f.lanes = a, f.child = null, f.subtreeFlags = 0, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.subtreeFlags = 0, f.deletions = null, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
                  G(L, L.current & 1 | 2);
                  return b.child;
                }
                a = a.sibling;
              }
              null !== f.tail && B() > Gj && (b.flags |= 128, d = true, Dj(f, false), b.lanes = 4194304);
            }
            else {
              if (!d) if (a = Ch(g), null !== a) {
                if (b.flags |= 128, d = true, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Dj(f, true), null === f.tail && "hidden" === f.tailMode && !g.alternate && !I) return S(b), null;
              } else 2 * B() - f.renderingStartTime > Gj && 1073741824 !== c && (b.flags |= 128, d = true, Dj(f, false), b.lanes = 4194304);
              f.isBackwards ? (g.sibling = b.child, b.child = g) : (c = f.last, null !== c ? c.sibling = g : b.child = g, f.last = g);
            }
            if (null !== f.tail) return b = f.tail, f.rendering = b, f.tail = b.sibling, f.renderingStartTime = B(), b.sibling = null, c = L.current, G(L, d ? c & 1 | 2 : c & 1), b;
            S(b);
            return null;
          case 22:
          case 23:
            return Hj(), d = null !== b.memoizedState, null !== a && null !== a.memoizedState !== d && (b.flags |= 8192), d && 0 !== (b.mode & 1) ? 0 !== (fj & 1073741824) && (S(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S(b), null;
          case 24:
            return null;
          case 25:
            return null;
        }
        throw Error(p(156, b.tag));
      }
      function Ij(a, b) {
        wg(b);
        switch (b.tag) {
          case 1:
            return Zf(b.type) && $f(), a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
          case 3:
            return zh(), E(Wf), E(H), Eh(), a = b.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b.flags = a & -65537 | 128, b) : null;
          case 5:
            return Bh(b), null;
          case 13:
            E(L);
            a = b.memoizedState;
            if (null !== a && null !== a.dehydrated) {
              if (null === b.alternate) throw Error(p(340));
              Ig();
            }
            a = b.flags;
            return a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
          case 19:
            return E(L), null;
          case 4:
            return zh(), null;
          case 10:
            return ah(b.type._context), null;
          case 22:
          case 23:
            return Hj(), null;
          case 24:
            return null;
          default:
            return null;
        }
      }
      var Jj = false, U = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
      function Lj(a, b) {
        var c = a.ref;
        if (null !== c) if ("function" === typeof c) try {
          c(null);
        } catch (d) {
          W(a, b, d);
        }
        else c.current = null;
      }
      function Mj(a, b, c) {
        try {
          c();
        } catch (d) {
          W(a, b, d);
        }
      }
      var Nj = false;
      function Oj(a, b) {
        Cf = dd;
        a = Me();
        if (Ne(a)) {
          if ("selectionStart" in a) var c = { start: a.selectionStart, end: a.selectionEnd };
          else a: {
            c = (c = a.ownerDocument) && c.defaultView || window;
            var d = c.getSelection && c.getSelection();
            if (d && 0 !== d.rangeCount) {
              c = d.anchorNode;
              var e = d.anchorOffset, f = d.focusNode;
              d = d.focusOffset;
              try {
                c.nodeType, f.nodeType;
              } catch (F) {
                c = null;
                break a;
              }
              var g = 0, h = -1, k = -1, l = 0, m = 0, q = a, r = null;
              b: for (; ; ) {
                for (var y; ; ) {
                  q !== c || 0 !== e && 3 !== q.nodeType || (h = g + e);
                  q !== f || 0 !== d && 3 !== q.nodeType || (k = g + d);
                  3 === q.nodeType && (g += q.nodeValue.length);
                  if (null === (y = q.firstChild)) break;
                  r = q;
                  q = y;
                }
                for (; ; ) {
                  if (q === a) break b;
                  r === c && ++l === e && (h = g);
                  r === f && ++m === d && (k = g);
                  if (null !== (y = q.nextSibling)) break;
                  q = r;
                  r = q.parentNode;
                }
                q = y;
              }
              c = -1 === h || -1 === k ? null : { start: h, end: k };
            } else c = null;
          }
          c = c || { start: 0, end: 0 };
        } else c = null;
        Df = { focusedElem: a, selectionRange: c };
        dd = false;
        for (V = b; null !== V; ) if (b = V, a = b.child, 0 !== (b.subtreeFlags & 1028) && null !== a) a.return = b, V = a;
        else for (; null !== V; ) {
          b = V;
          try {
            var n = b.alternate;
            if (0 !== (b.flags & 1024)) switch (b.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n) {
                  var t = n.memoizedProps, J = n.memoizedState, x = b.stateNode, w = x.getSnapshotBeforeUpdate(b.elementType === b.type ? t : Ci(b.type, t), J);
                  x.__reactInternalSnapshotBeforeUpdate = w;
                }
                break;
              case 3:
                var u = b.stateNode.containerInfo;
                1 === u.nodeType ? u.textContent = "" : 9 === u.nodeType && u.documentElement && u.removeChild(u.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p(163));
            }
          } catch (F) {
            W(b, b.return, F);
          }
          a = b.sibling;
          if (null !== a) {
            a.return = b.return;
            V = a;
            break;
          }
          V = b.return;
        }
        n = Nj;
        Nj = false;
        return n;
      }
      function Pj(a, b, c) {
        var d = b.updateQueue;
        d = null !== d ? d.lastEffect : null;
        if (null !== d) {
          var e = d = d.next;
          do {
            if ((e.tag & a) === a) {
              var f = e.destroy;
              e.destroy = void 0;
              void 0 !== f && Mj(b, c, f);
            }
            e = e.next;
          } while (e !== d);
        }
      }
      function Qj(a, b) {
        b = b.updateQueue;
        b = null !== b ? b.lastEffect : null;
        if (null !== b) {
          var c = b = b.next;
          do {
            if ((c.tag & a) === a) {
              var d = c.create;
              c.destroy = d();
            }
            c = c.next;
          } while (c !== b);
        }
      }
      function Rj(a) {
        var b = a.ref;
        if (null !== b) {
          var c = a.stateNode;
          switch (a.tag) {
            case 5:
              a = c;
              break;
            default:
              a = c;
          }
          "function" === typeof b ? b(a) : b.current = a;
        }
      }
      function Sj(a) {
        var b = a.alternate;
        null !== b && (a.alternate = null, Sj(b));
        a.child = null;
        a.deletions = null;
        a.sibling = null;
        5 === a.tag && (b = a.stateNode, null !== b && (delete b[Of], delete b[Pf], delete b[of], delete b[Qf], delete b[Rf]));
        a.stateNode = null;
        a.return = null;
        a.dependencies = null;
        a.memoizedProps = null;
        a.memoizedState = null;
        a.pendingProps = null;
        a.stateNode = null;
        a.updateQueue = null;
      }
      function Tj(a) {
        return 5 === a.tag || 3 === a.tag || 4 === a.tag;
      }
      function Uj(a) {
        a: for (; ; ) {
          for (; null === a.sibling; ) {
            if (null === a.return || Tj(a.return)) return null;
            a = a.return;
          }
          a.sibling.return = a.return;
          for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
            if (a.flags & 2) continue a;
            if (null === a.child || 4 === a.tag) continue a;
            else a.child.return = a, a = a.child;
          }
          if (!(a.flags & 2)) return a.stateNode;
        }
      }
      function Vj(a, b, c) {
        var d = a.tag;
        if (5 === d || 6 === d) a = a.stateNode, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = Bf));
        else if (4 !== d && (a = a.child, null !== a)) for (Vj(a, b, c), a = a.sibling; null !== a; ) Vj(a, b, c), a = a.sibling;
      }
      function Wj(a, b, c) {
        var d = a.tag;
        if (5 === d || 6 === d) a = a.stateNode, b ? c.insertBefore(a, b) : c.appendChild(a);
        else if (4 !== d && (a = a.child, null !== a)) for (Wj(a, b, c), a = a.sibling; null !== a; ) Wj(a, b, c), a = a.sibling;
      }
      var X = null, Xj = false;
      function Yj(a, b, c) {
        for (c = c.child; null !== c; ) Zj(a, b, c), c = c.sibling;
      }
      function Zj(a, b, c) {
        if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
          lc.onCommitFiberUnmount(kc, c);
        } catch (h) {
        }
        switch (c.tag) {
          case 5:
            U || Lj(c, b);
          case 6:
            var d = X, e = Xj;
            X = null;
            Yj(a, b, c);
            X = d;
            Xj = e;
            null !== X && (Xj ? (a = X, c = c.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c) : a.removeChild(c)) : X.removeChild(c.stateNode));
            break;
          case 18:
            null !== X && (Xj ? (a = X, c = c.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c) : 1 === a.nodeType && Kf(a, c), bd(a)) : Kf(X, c.stateNode));
            break;
          case 4:
            d = X;
            e = Xj;
            X = c.stateNode.containerInfo;
            Xj = true;
            Yj(a, b, c);
            X = d;
            Xj = e;
            break;
          case 0:
          case 11:
          case 14:
          case 15:
            if (!U && (d = c.updateQueue, null !== d && (d = d.lastEffect, null !== d))) {
              e = d = d.next;
              do {
                var f = e, g = f.destroy;
                f = f.tag;
                void 0 !== g && (0 !== (f & 2) ? Mj(c, b, g) : 0 !== (f & 4) && Mj(c, b, g));
                e = e.next;
              } while (e !== d);
            }
            Yj(a, b, c);
            break;
          case 1:
            if (!U && (Lj(c, b), d = c.stateNode, "function" === typeof d.componentWillUnmount)) try {
              d.props = c.memoizedProps, d.state = c.memoizedState, d.componentWillUnmount();
            } catch (h) {
              W(c, b, h);
            }
            Yj(a, b, c);
            break;
          case 21:
            Yj(a, b, c);
            break;
          case 22:
            c.mode & 1 ? (U = (d = U) || null !== c.memoizedState, Yj(a, b, c), U = d) : Yj(a, b, c);
            break;
          default:
            Yj(a, b, c);
        }
      }
      function ak(a) {
        var b = a.updateQueue;
        if (null !== b) {
          a.updateQueue = null;
          var c = a.stateNode;
          null === c && (c = a.stateNode = new Kj());
          b.forEach(function(b2) {
            var d = bk.bind(null, a, b2);
            c.has(b2) || (c.add(b2), b2.then(d, d));
          });
        }
      }
      function ck(a, b) {
        var c = b.deletions;
        if (null !== c) for (var d = 0; d < c.length; d++) {
          var e = c[d];
          try {
            var f = a, g = b, h = g;
            a: for (; null !== h; ) {
              switch (h.tag) {
                case 5:
                  X = h.stateNode;
                  Xj = false;
                  break a;
                case 3:
                  X = h.stateNode.containerInfo;
                  Xj = true;
                  break a;
                case 4:
                  X = h.stateNode.containerInfo;
                  Xj = true;
                  break a;
              }
              h = h.return;
            }
            if (null === X) throw Error(p(160));
            Zj(f, g, e);
            X = null;
            Xj = false;
            var k = e.alternate;
            null !== k && (k.return = null);
            e.return = null;
          } catch (l) {
            W(e, b, l);
          }
        }
        if (b.subtreeFlags & 12854) for (b = b.child; null !== b; ) dk(b, a), b = b.sibling;
      }
      function dk(a, b) {
        var c = a.alternate, d = a.flags;
        switch (a.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            ck(b, a);
            ek(a);
            if (d & 4) {
              try {
                Pj(3, a, a.return), Qj(3, a);
              } catch (t) {
                W(a, a.return, t);
              }
              try {
                Pj(5, a, a.return);
              } catch (t) {
                W(a, a.return, t);
              }
            }
            break;
          case 1:
            ck(b, a);
            ek(a);
            d & 512 && null !== c && Lj(c, c.return);
            break;
          case 5:
            ck(b, a);
            ek(a);
            d & 512 && null !== c && Lj(c, c.return);
            if (a.flags & 32) {
              var e = a.stateNode;
              try {
                ob(e, "");
              } catch (t) {
                W(a, a.return, t);
              }
            }
            if (d & 4 && (e = a.stateNode, null != e)) {
              var f = a.memoizedProps, g = null !== c ? c.memoizedProps : f, h = a.type, k = a.updateQueue;
              a.updateQueue = null;
              if (null !== k) try {
                "input" === h && "radio" === f.type && null != f.name && ab(e, f);
                vb(h, g);
                var l = vb(h, f);
                for (g = 0; g < k.length; g += 2) {
                  var m = k[g], q = k[g + 1];
                  "style" === m ? sb(e, q) : "dangerouslySetInnerHTML" === m ? nb(e, q) : "children" === m ? ob(e, q) : ta(e, m, q, l);
                }
                switch (h) {
                  case "input":
                    bb(e, f);
                    break;
                  case "textarea":
                    ib(e, f);
                    break;
                  case "select":
                    var r = e._wrapperState.wasMultiple;
                    e._wrapperState.wasMultiple = !!f.multiple;
                    var y = f.value;
                    null != y ? fb(e, !!f.multiple, y, false) : r !== !!f.multiple && (null != f.defaultValue ? fb(
                      e,
                      !!f.multiple,
                      f.defaultValue,
                      true
                    ) : fb(e, !!f.multiple, f.multiple ? [] : "", false));
                }
                e[Pf] = f;
              } catch (t) {
                W(a, a.return, t);
              }
            }
            break;
          case 6:
            ck(b, a);
            ek(a);
            if (d & 4) {
              if (null === a.stateNode) throw Error(p(162));
              e = a.stateNode;
              f = a.memoizedProps;
              try {
                e.nodeValue = f;
              } catch (t) {
                W(a, a.return, t);
              }
            }
            break;
          case 3:
            ck(b, a);
            ek(a);
            if (d & 4 && null !== c && c.memoizedState.isDehydrated) try {
              bd(b.containerInfo);
            } catch (t) {
              W(a, a.return, t);
            }
            break;
          case 4:
            ck(b, a);
            ek(a);
            break;
          case 13:
            ck(b, a);
            ek(a);
            e = a.child;
            e.flags & 8192 && (f = null !== e.memoizedState, e.stateNode.isHidden = f, !f || null !== e.alternate && null !== e.alternate.memoizedState || (fk = B()));
            d & 4 && ak(a);
            break;
          case 22:
            m = null !== c && null !== c.memoizedState;
            a.mode & 1 ? (U = (l = U) || m, ck(b, a), U = l) : ck(b, a);
            ek(a);
            if (d & 8192) {
              l = null !== a.memoizedState;
              if ((a.stateNode.isHidden = l) && !m && 0 !== (a.mode & 1)) for (V = a, m = a.child; null !== m; ) {
                for (q = V = m; null !== V; ) {
                  r = V;
                  y = r.child;
                  switch (r.tag) {
                    case 0:
                    case 11:
                    case 14:
                    case 15:
                      Pj(4, r, r.return);
                      break;
                    case 1:
                      Lj(r, r.return);
                      var n = r.stateNode;
                      if ("function" === typeof n.componentWillUnmount) {
                        d = r;
                        c = r.return;
                        try {
                          b = d, n.props = b.memoizedProps, n.state = b.memoizedState, n.componentWillUnmount();
                        } catch (t) {
                          W(d, c, t);
                        }
                      }
                      break;
                    case 5:
                      Lj(r, r.return);
                      break;
                    case 22:
                      if (null !== r.memoizedState) {
                        gk(q);
                        continue;
                      }
                  }
                  null !== y ? (y.return = r, V = y) : gk(q);
                }
                m = m.sibling;
              }
              a: for (m = null, q = a; ; ) {
                if (5 === q.tag) {
                  if (null === m) {
                    m = q;
                    try {
                      e = q.stateNode, l ? (f = e.style, "function" === typeof f.setProperty ? f.setProperty("display", "none", "important") : f.display = "none") : (h = q.stateNode, k = q.memoizedProps.style, g = void 0 !== k && null !== k && k.hasOwnProperty("display") ? k.display : null, h.style.display = rb("display", g));
                    } catch (t) {
                      W(a, a.return, t);
                    }
                  }
                } else if (6 === q.tag) {
                  if (null === m) try {
                    q.stateNode.nodeValue = l ? "" : q.memoizedProps;
                  } catch (t) {
                    W(a, a.return, t);
                  }
                } else if ((22 !== q.tag && 23 !== q.tag || null === q.memoizedState || q === a) && null !== q.child) {
                  q.child.return = q;
                  q = q.child;
                  continue;
                }
                if (q === a) break a;
                for (; null === q.sibling; ) {
                  if (null === q.return || q.return === a) break a;
                  m === q && (m = null);
                  q = q.return;
                }
                m === q && (m = null);
                q.sibling.return = q.return;
                q = q.sibling;
              }
            }
            break;
          case 19:
            ck(b, a);
            ek(a);
            d & 4 && ak(a);
            break;
          case 21:
            break;
          default:
            ck(
              b,
              a
            ), ek(a);
        }
      }
      function ek(a) {
        var b = a.flags;
        if (b & 2) {
          try {
            a: {
              for (var c = a.return; null !== c; ) {
                if (Tj(c)) {
                  var d = c;
                  break a;
                }
                c = c.return;
              }
              throw Error(p(160));
            }
            switch (d.tag) {
              case 5:
                var e = d.stateNode;
                d.flags & 32 && (ob(e, ""), d.flags &= -33);
                var f = Uj(a);
                Wj(a, f, e);
                break;
              case 3:
              case 4:
                var g = d.stateNode.containerInfo, h = Uj(a);
                Vj(a, h, g);
                break;
              default:
                throw Error(p(161));
            }
          } catch (k) {
            W(a, a.return, k);
          }
          a.flags &= -3;
        }
        b & 4096 && (a.flags &= -4097);
      }
      function hk(a, b, c) {
        V = a;
        ik(a);
      }
      function ik(a, b, c) {
        for (var d = 0 !== (a.mode & 1); null !== V; ) {
          var e = V, f = e.child;
          if (22 === e.tag && d) {
            var g = null !== e.memoizedState || Jj;
            if (!g) {
              var h = e.alternate, k = null !== h && null !== h.memoizedState || U;
              h = Jj;
              var l = U;
              Jj = g;
              if ((U = k) && !l) for (V = e; null !== V; ) g = V, k = g.child, 22 === g.tag && null !== g.memoizedState ? jk(e) : null !== k ? (k.return = g, V = k) : jk(e);
              for (; null !== f; ) V = f, ik(f), f = f.sibling;
              V = e;
              Jj = h;
              U = l;
            }
            kk(a);
          } else 0 !== (e.subtreeFlags & 8772) && null !== f ? (f.return = e, V = f) : kk(a);
        }
      }
      function kk(a) {
        for (; null !== V; ) {
          var b = V;
          if (0 !== (b.flags & 8772)) {
            var c = b.alternate;
            try {
              if (0 !== (b.flags & 8772)) switch (b.tag) {
                case 0:
                case 11:
                case 15:
                  U || Qj(5, b);
                  break;
                case 1:
                  var d = b.stateNode;
                  if (b.flags & 4 && !U) if (null === c) d.componentDidMount();
                  else {
                    var e = b.elementType === b.type ? c.memoizedProps : Ci(b.type, c.memoizedProps);
                    d.componentDidUpdate(e, c.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
                  }
                  var f = b.updateQueue;
                  null !== f && sh(b, f, d);
                  break;
                case 3:
                  var g = b.updateQueue;
                  if (null !== g) {
                    c = null;
                    if (null !== b.child) switch (b.child.tag) {
                      case 5:
                        c = b.child.stateNode;
                        break;
                      case 1:
                        c = b.child.stateNode;
                    }
                    sh(b, g, c);
                  }
                  break;
                case 5:
                  var h = b.stateNode;
                  if (null === c && b.flags & 4) {
                    c = h;
                    var k = b.memoizedProps;
                    switch (b.type) {
                      case "button":
                      case "input":
                      case "select":
                      case "textarea":
                        k.autoFocus && c.focus();
                        break;
                      case "img":
                        k.src && (c.src = k.src);
                    }
                  }
                  break;
                case 6:
                  break;
                case 4:
                  break;
                case 12:
                  break;
                case 13:
                  if (null === b.memoizedState) {
                    var l = b.alternate;
                    if (null !== l) {
                      var m = l.memoizedState;
                      if (null !== m) {
                        var q = m.dehydrated;
                        null !== q && bd(q);
                      }
                    }
                  }
                  break;
                case 19:
                case 17:
                case 21:
                case 22:
                case 23:
                case 25:
                  break;
                default:
                  throw Error(p(163));
              }
              U || b.flags & 512 && Rj(b);
            } catch (r) {
              W(b, b.return, r);
            }
          }
          if (b === a) {
            V = null;
            break;
          }
          c = b.sibling;
          if (null !== c) {
            c.return = b.return;
            V = c;
            break;
          }
          V = b.return;
        }
      }
      function gk(a) {
        for (; null !== V; ) {
          var b = V;
          if (b === a) {
            V = null;
            break;
          }
          var c = b.sibling;
          if (null !== c) {
            c.return = b.return;
            V = c;
            break;
          }
          V = b.return;
        }
      }
      function jk(a) {
        for (; null !== V; ) {
          var b = V;
          try {
            switch (b.tag) {
              case 0:
              case 11:
              case 15:
                var c = b.return;
                try {
                  Qj(4, b);
                } catch (k) {
                  W(b, c, k);
                }
                break;
              case 1:
                var d = b.stateNode;
                if ("function" === typeof d.componentDidMount) {
                  var e = b.return;
                  try {
                    d.componentDidMount();
                  } catch (k) {
                    W(b, e, k);
                  }
                }
                var f = b.return;
                try {
                  Rj(b);
                } catch (k) {
                  W(b, f, k);
                }
                break;
              case 5:
                var g = b.return;
                try {
                  Rj(b);
                } catch (k) {
                  W(b, g, k);
                }
            }
          } catch (k) {
            W(b, b.return, k);
          }
          if (b === a) {
            V = null;
            break;
          }
          var h = b.sibling;
          if (null !== h) {
            h.return = b.return;
            V = h;
            break;
          }
          V = b.return;
        }
      }
      var lk = Math.ceil, mk = ua.ReactCurrentDispatcher, nk = ua.ReactCurrentOwner, ok = ua.ReactCurrentBatchConfig, K = 0, Q = null, Y = null, Z = 0, fj = 0, ej = Uf(0), T = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi = false, Pi = null, Ri = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
      function R() {
        return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
      }
      function yi(a) {
        if (0 === (a.mode & 1)) return 1;
        if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
        if (null !== Kg.transition) return 0 === Bk && (Bk = yc()), Bk;
        a = C;
        if (0 !== a) return a;
        a = window.event;
        a = void 0 === a ? 16 : jd(a.type);
        return a;
      }
      function gi(a, b, c, d) {
        if (50 < yk) throw yk = 0, zk = null, Error(p(185));
        Ac(a, c, d);
        if (0 === (K & 2) || a !== Q) a === Q && (0 === (K & 2) && (qk |= c), 4 === T && Ck(a, Z)), Dk(a, d), 1 === c && 0 === K && 0 === (b.mode & 1) && (Gj = B() + 500, fg && jg());
      }
      function Dk(a, b) {
        var c = a.callbackNode;
        wc(a, b);
        var d = uc(a, a === Q ? Z : 0);
        if (0 === d) null !== c && bc(c), a.callbackNode = null, a.callbackPriority = 0;
        else if (b = d & -d, a.callbackPriority !== b) {
          null != c && bc(c);
          if (1 === b) 0 === a.tag ? ig(Ek.bind(null, a)) : hg(Ek.bind(null, a)), Jf(function() {
            0 === (K & 6) && jg();
          }), c = null;
          else {
            switch (Dc(d)) {
              case 1:
                c = fc;
                break;
              case 4:
                c = gc;
                break;
              case 16:
                c = hc;
                break;
              case 536870912:
                c = jc;
                break;
              default:
                c = hc;
            }
            c = Fk(c, Gk.bind(null, a));
          }
          a.callbackPriority = b;
          a.callbackNode = c;
        }
      }
      function Gk(a, b) {
        Ak = -1;
        Bk = 0;
        if (0 !== (K & 6)) throw Error(p(327));
        var c = a.callbackNode;
        if (Hk() && a.callbackNode !== c) return null;
        var d = uc(a, a === Q ? Z : 0);
        if (0 === d) return null;
        if (0 !== (d & 30) || 0 !== (d & a.expiredLanes) || b) b = Ik(a, d);
        else {
          b = d;
          var e = K;
          K |= 2;
          var f = Jk();
          if (Q !== a || Z !== b) uk = null, Gj = B() + 500, Kk(a, b);
          do
            try {
              Lk();
              break;
            } catch (h) {
              Mk(a, h);
            }
          while (1);
          $g();
          mk.current = f;
          K = e;
          null !== Y ? b = 0 : (Q = null, Z = 0, b = T);
        }
        if (0 !== b) {
          2 === b && (e = xc(a), 0 !== e && (d = e, b = Nk(a, e)));
          if (1 === b) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
          if (6 === b) Ck(a, d);
          else {
            e = a.current.alternate;
            if (0 === (d & 30) && !Ok(e) && (b = Ik(a, d), 2 === b && (f = xc(a), 0 !== f && (d = f, b = Nk(a, f))), 1 === b)) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
            a.finishedWork = e;
            a.finishedLanes = d;
            switch (b) {
              case 0:
              case 1:
                throw Error(p(345));
              case 2:
                Pk(a, tk, uk);
                break;
              case 3:
                Ck(a, d);
                if ((d & 130023424) === d && (b = fk + 500 - B(), 10 < b)) {
                  if (0 !== uc(a, 0)) break;
                  e = a.suspendedLanes;
                  if ((e & d) !== d) {
                    R();
                    a.pingedLanes |= a.suspendedLanes & e;
                    break;
                  }
                  a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), b);
                  break;
                }
                Pk(a, tk, uk);
                break;
              case 4:
                Ck(a, d);
                if ((d & 4194240) === d) break;
                b = a.eventTimes;
                for (e = -1; 0 < d; ) {
                  var g = 31 - oc(d);
                  f = 1 << g;
                  g = b[g];
                  g > e && (e = g);
                  d &= ~f;
                }
                d = e;
                d = B() - d;
                d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * lk(d / 1960)) - d;
                if (10 < d) {
                  a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), d);
                  break;
                }
                Pk(a, tk, uk);
                break;
              case 5:
                Pk(a, tk, uk);
                break;
              default:
                throw Error(p(329));
            }
          }
        }
        Dk(a, B());
        return a.callbackNode === c ? Gk.bind(null, a) : null;
      }
      function Nk(a, b) {
        var c = sk;
        a.current.memoizedState.isDehydrated && (Kk(a, b).flags |= 256);
        a = Ik(a, b);
        2 !== a && (b = tk, tk = c, null !== b && Fj(b));
        return a;
      }
      function Fj(a) {
        null === tk ? tk = a : tk.push.apply(tk, a);
      }
      function Ok(a) {
        for (var b = a; ; ) {
          if (b.flags & 16384) {
            var c = b.updateQueue;
            if (null !== c && (c = c.stores, null !== c)) for (var d = 0; d < c.length; d++) {
              var e = c[d], f = e.getSnapshot;
              e = e.value;
              try {
                if (!He(f(), e)) return false;
              } catch (g) {
                return false;
              }
            }
          }
          c = b.child;
          if (b.subtreeFlags & 16384 && null !== c) c.return = b, b = c;
          else {
            if (b === a) break;
            for (; null === b.sibling; ) {
              if (null === b.return || b.return === a) return true;
              b = b.return;
            }
            b.sibling.return = b.return;
            b = b.sibling;
          }
        }
        return true;
      }
      function Ck(a, b) {
        b &= ~rk;
        b &= ~qk;
        a.suspendedLanes |= b;
        a.pingedLanes &= ~b;
        for (a = a.expirationTimes; 0 < b; ) {
          var c = 31 - oc(b), d = 1 << c;
          a[c] = -1;
          b &= ~d;
        }
      }
      function Ek(a) {
        if (0 !== (K & 6)) throw Error(p(327));
        Hk();
        var b = uc(a, 0);
        if (0 === (b & 1)) return Dk(a, B()), null;
        var c = Ik(a, b);
        if (0 !== a.tag && 2 === c) {
          var d = xc(a);
          0 !== d && (b = d, c = Nk(a, d));
        }
        if (1 === c) throw c = pk, Kk(a, 0), Ck(a, b), Dk(a, B()), c;
        if (6 === c) throw Error(p(345));
        a.finishedWork = a.current.alternate;
        a.finishedLanes = b;
        Pk(a, tk, uk);
        Dk(a, B());
        return null;
      }
      function Qk(a, b) {
        var c = K;
        K |= 1;
        try {
          return a(b);
        } finally {
          K = c, 0 === K && (Gj = B() + 500, fg && jg());
        }
      }
      function Rk(a) {
        null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
        var b = K;
        K |= 1;
        var c = ok.transition, d = C;
        try {
          if (ok.transition = null, C = 1, a) return a();
        } finally {
          C = d, ok.transition = c, K = b, 0 === (K & 6) && jg();
        }
      }
      function Hj() {
        fj = ej.current;
        E(ej);
      }
      function Kk(a, b) {
        a.finishedWork = null;
        a.finishedLanes = 0;
        var c = a.timeoutHandle;
        -1 !== c && (a.timeoutHandle = -1, Gf(c));
        if (null !== Y) for (c = Y.return; null !== c; ) {
          var d = c;
          wg(d);
          switch (d.tag) {
            case 1:
              d = d.type.childContextTypes;
              null !== d && void 0 !== d && $f();
              break;
            case 3:
              zh();
              E(Wf);
              E(H);
              Eh();
              break;
            case 5:
              Bh(d);
              break;
            case 4:
              zh();
              break;
            case 13:
              E(L);
              break;
            case 19:
              E(L);
              break;
            case 10:
              ah(d.type._context);
              break;
            case 22:
            case 23:
              Hj();
          }
          c = c.return;
        }
        Q = a;
        Y = a = Pg(a.current, null);
        Z = fj = b;
        T = 0;
        pk = null;
        rk = qk = rh = 0;
        tk = sk = null;
        if (null !== fh) {
          for (b = 0; b < fh.length; b++) if (c = fh[b], d = c.interleaved, null !== d) {
            c.interleaved = null;
            var e = d.next, f = c.pending;
            if (null !== f) {
              var g = f.next;
              f.next = e;
              d.next = g;
            }
            c.pending = d;
          }
          fh = null;
        }
        return a;
      }
      function Mk(a, b) {
        do {
          var c = Y;
          try {
            $g();
            Fh.current = Rh;
            if (Ih) {
              for (var d = M.memoizedState; null !== d; ) {
                var e = d.queue;
                null !== e && (e.pending = null);
                d = d.next;
              }
              Ih = false;
            }
            Hh = 0;
            O = N = M = null;
            Jh = false;
            Kh = 0;
            nk.current = null;
            if (null === c || null === c.return) {
              T = 1;
              pk = b;
              Y = null;
              break;
            }
            a: {
              var f = a, g = c.return, h = c, k = b;
              b = Z;
              h.flags |= 32768;
              if (null !== k && "object" === typeof k && "function" === typeof k.then) {
                var l = k, m = h, q = m.tag;
                if (0 === (m.mode & 1) && (0 === q || 11 === q || 15 === q)) {
                  var r = m.alternate;
                  r ? (m.updateQueue = r.updateQueue, m.memoizedState = r.memoizedState, m.lanes = r.lanes) : (m.updateQueue = null, m.memoizedState = null);
                }
                var y = Ui(g);
                if (null !== y) {
                  y.flags &= -257;
                  Vi(y, g, h, f, b);
                  y.mode & 1 && Si(f, l, b);
                  b = y;
                  k = l;
                  var n = b.updateQueue;
                  if (null === n) {
                    var t = /* @__PURE__ */ new Set();
                    t.add(k);
                    b.updateQueue = t;
                  } else n.add(k);
                  break a;
                } else {
                  if (0 === (b & 1)) {
                    Si(f, l, b);
                    tj();
                    break a;
                  }
                  k = Error(p(426));
                }
              } else if (I && h.mode & 1) {
                var J = Ui(g);
                if (null !== J) {
                  0 === (J.flags & 65536) && (J.flags |= 256);
                  Vi(J, g, h, f, b);
                  Jg(Ji(k, h));
                  break a;
                }
              }
              f = k = Ji(k, h);
              4 !== T && (T = 2);
              null === sk ? sk = [f] : sk.push(f);
              f = g;
              do {
                switch (f.tag) {
                  case 3:
                    f.flags |= 65536;
                    b &= -b;
                    f.lanes |= b;
                    var x = Ni(f, k, b);
                    ph(f, x);
                    break a;
                  case 1:
                    h = k;
                    var w = f.type, u = f.stateNode;
                    if (0 === (f.flags & 128) && ("function" === typeof w.getDerivedStateFromError || null !== u && "function" === typeof u.componentDidCatch && (null === Ri || !Ri.has(u)))) {
                      f.flags |= 65536;
                      b &= -b;
                      f.lanes |= b;
                      var F = Qi(f, h, b);
                      ph(f, F);
                      break a;
                    }
                }
                f = f.return;
              } while (null !== f);
            }
            Sk(c);
          } catch (na) {
            b = na;
            Y === c && null !== c && (Y = c = c.return);
            continue;
          }
          break;
        } while (1);
      }
      function Jk() {
        var a = mk.current;
        mk.current = Rh;
        return null === a ? Rh : a;
      }
      function tj() {
        if (0 === T || 3 === T || 2 === T) T = 4;
        null === Q || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q, Z);
      }
      function Ik(a, b) {
        var c = K;
        K |= 2;
        var d = Jk();
        if (Q !== a || Z !== b) uk = null, Kk(a, b);
        do
          try {
            Tk();
            break;
          } catch (e) {
            Mk(a, e);
          }
        while (1);
        $g();
        K = c;
        mk.current = d;
        if (null !== Y) throw Error(p(261));
        Q = null;
        Z = 0;
        return T;
      }
      function Tk() {
        for (; null !== Y; ) Uk(Y);
      }
      function Lk() {
        for (; null !== Y && !cc(); ) Uk(Y);
      }
      function Uk(a) {
        var b = Vk(a.alternate, a, fj);
        a.memoizedProps = a.pendingProps;
        null === b ? Sk(a) : Y = b;
        nk.current = null;
      }
      function Sk(a) {
        var b = a;
        do {
          var c = b.alternate;
          a = b.return;
          if (0 === (b.flags & 32768)) {
            if (c = Ej(c, b, fj), null !== c) {
              Y = c;
              return;
            }
          } else {
            c = Ij(c, b);
            if (null !== c) {
              c.flags &= 32767;
              Y = c;
              return;
            }
            if (null !== a) a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
            else {
              T = 6;
              Y = null;
              return;
            }
          }
          b = b.sibling;
          if (null !== b) {
            Y = b;
            return;
          }
          Y = b = a;
        } while (null !== b);
        0 === T && (T = 5);
      }
      function Pk(a, b, c) {
        var d = C, e = ok.transition;
        try {
          ok.transition = null, C = 1, Wk(a, b, c, d);
        } finally {
          ok.transition = e, C = d;
        }
        return null;
      }
      function Wk(a, b, c, d) {
        do
          Hk();
        while (null !== wk);
        if (0 !== (K & 6)) throw Error(p(327));
        c = a.finishedWork;
        var e = a.finishedLanes;
        if (null === c) return null;
        a.finishedWork = null;
        a.finishedLanes = 0;
        if (c === a.current) throw Error(p(177));
        a.callbackNode = null;
        a.callbackPriority = 0;
        var f = c.lanes | c.childLanes;
        Bc(a, f);
        a === Q && (Y = Q = null, Z = 0);
        0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064) || vk || (vk = true, Fk(hc, function() {
          Hk();
          return null;
        }));
        f = 0 !== (c.flags & 15990);
        if (0 !== (c.subtreeFlags & 15990) || f) {
          f = ok.transition;
          ok.transition = null;
          var g = C;
          C = 1;
          var h = K;
          K |= 4;
          nk.current = null;
          Oj(a, c);
          dk(c, a);
          Oe(Df);
          dd = !!Cf;
          Df = Cf = null;
          a.current = c;
          hk(c);
          dc();
          K = h;
          C = g;
          ok.transition = f;
        } else a.current = c;
        vk && (vk = false, wk = a, xk = e);
        f = a.pendingLanes;
        0 === f && (Ri = null);
        mc(c.stateNode);
        Dk(a, B());
        if (null !== b) for (d = a.onRecoverableError, c = 0; c < b.length; c++) e = b[c], d(e.value, { componentStack: e.stack, digest: e.digest });
        if (Oi) throw Oi = false, a = Pi, Pi = null, a;
        0 !== (xk & 1) && 0 !== a.tag && Hk();
        f = a.pendingLanes;
        0 !== (f & 1) ? a === zk ? yk++ : (yk = 0, zk = a) : yk = 0;
        jg();
        return null;
      }
      function Hk() {
        if (null !== wk) {
          var a = Dc(xk), b = ok.transition, c = C;
          try {
            ok.transition = null;
            C = 16 > a ? 16 : a;
            if (null === wk) var d = false;
            else {
              a = wk;
              wk = null;
              xk = 0;
              if (0 !== (K & 6)) throw Error(p(331));
              var e = K;
              K |= 4;
              for (V = a.current; null !== V; ) {
                var f = V, g = f.child;
                if (0 !== (V.flags & 16)) {
                  var h = f.deletions;
                  if (null !== h) {
                    for (var k = 0; k < h.length; k++) {
                      var l = h[k];
                      for (V = l; null !== V; ) {
                        var m = V;
                        switch (m.tag) {
                          case 0:
                          case 11:
                          case 15:
                            Pj(8, m, f);
                        }
                        var q = m.child;
                        if (null !== q) q.return = m, V = q;
                        else for (; null !== V; ) {
                          m = V;
                          var r = m.sibling, y = m.return;
                          Sj(m);
                          if (m === l) {
                            V = null;
                            break;
                          }
                          if (null !== r) {
                            r.return = y;
                            V = r;
                            break;
                          }
                          V = y;
                        }
                      }
                    }
                    var n = f.alternate;
                    if (null !== n) {
                      var t = n.child;
                      if (null !== t) {
                        n.child = null;
                        do {
                          var J = t.sibling;
                          t.sibling = null;
                          t = J;
                        } while (null !== t);
                      }
                    }
                    V = f;
                  }
                }
                if (0 !== (f.subtreeFlags & 2064) && null !== g) g.return = f, V = g;
                else b: for (; null !== V; ) {
                  f = V;
                  if (0 !== (f.flags & 2048)) switch (f.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Pj(9, f, f.return);
                  }
                  var x = f.sibling;
                  if (null !== x) {
                    x.return = f.return;
                    V = x;
                    break b;
                  }
                  V = f.return;
                }
              }
              var w = a.current;
              for (V = w; null !== V; ) {
                g = V;
                var u = g.child;
                if (0 !== (g.subtreeFlags & 2064) && null !== u) u.return = g, V = u;
                else b: for (g = w; null !== V; ) {
                  h = V;
                  if (0 !== (h.flags & 2048)) try {
                    switch (h.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Qj(9, h);
                    }
                  } catch (na) {
                    W(h, h.return, na);
                  }
                  if (h === g) {
                    V = null;
                    break b;
                  }
                  var F = h.sibling;
                  if (null !== F) {
                    F.return = h.return;
                    V = F;
                    break b;
                  }
                  V = h.return;
                }
              }
              K = e;
              jg();
              if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
                lc.onPostCommitFiberRoot(kc, a);
              } catch (na) {
              }
              d = true;
            }
            return d;
          } finally {
            C = c, ok.transition = b;
          }
        }
        return false;
      }
      function Xk(a, b, c) {
        b = Ji(c, b);
        b = Ni(a, b, 1);
        a = nh(a, b, 1);
        b = R();
        null !== a && (Ac(a, 1, b), Dk(a, b));
      }
      function W(a, b, c) {
        if (3 === a.tag) Xk(a, a, c);
        else for (; null !== b; ) {
          if (3 === b.tag) {
            Xk(b, a, c);
            break;
          } else if (1 === b.tag) {
            var d = b.stateNode;
            if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Ri || !Ri.has(d))) {
              a = Ji(c, a);
              a = Qi(b, a, 1);
              b = nh(b, a, 1);
              a = R();
              null !== b && (Ac(b, 1, a), Dk(b, a));
              break;
            }
          }
          b = b.return;
        }
      }
      function Ti(a, b, c) {
        var d = a.pingCache;
        null !== d && d.delete(b);
        b = R();
        a.pingedLanes |= a.suspendedLanes & c;
        Q === a && (Z & c) === c && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a, 0) : rk |= c);
        Dk(a, b);
      }
      function Yk(a, b) {
        0 === b && (0 === (a.mode & 1) ? b = 1 : (b = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
        var c = R();
        a = ih(a, b);
        null !== a && (Ac(a, b, c), Dk(a, c));
      }
      function uj(a) {
        var b = a.memoizedState, c = 0;
        null !== b && (c = b.retryLane);
        Yk(a, c);
      }
      function bk(a, b) {
        var c = 0;
        switch (a.tag) {
          case 13:
            var d = a.stateNode;
            var e = a.memoizedState;
            null !== e && (c = e.retryLane);
            break;
          case 19:
            d = a.stateNode;
            break;
          default:
            throw Error(p(314));
        }
        null !== d && d.delete(b);
        Yk(a, c);
      }
      var Vk;
      Vk = function(a, b, c) {
        if (null !== a) if (a.memoizedProps !== b.pendingProps || Wf.current) dh = true;
        else {
          if (0 === (a.lanes & c) && 0 === (b.flags & 128)) return dh = false, yj(a, b, c);
          dh = 0 !== (a.flags & 131072) ? true : false;
        }
        else dh = false, I && 0 !== (b.flags & 1048576) && ug(b, ng, b.index);
        b.lanes = 0;
        switch (b.tag) {
          case 2:
            var d = b.type;
            ij(a, b);
            a = b.pendingProps;
            var e = Yf(b, H.current);
            ch(b, c);
            e = Nh(null, b, d, a, e, c);
            var f = Sh();
            b.flags |= 1;
            "object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d) ? (f = true, cg(b)) : f = false, b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null, kh(b), e.updater = Ei, b.stateNode = e, e._reactInternals = b, Ii(b, d, a, c), b = jj(null, b, d, true, f, c)) : (b.tag = 0, I && f && vg(b), Xi(null, b, e, c), b = b.child);
            return b;
          case 16:
            d = b.elementType;
            a: {
              ij(a, b);
              a = b.pendingProps;
              e = d._init;
              d = e(d._payload);
              b.type = d;
              e = b.tag = Zk(d);
              a = Ci(d, a);
              switch (e) {
                case 0:
                  b = cj(null, b, d, a, c);
                  break a;
                case 1:
                  b = hj(null, b, d, a, c);
                  break a;
                case 11:
                  b = Yi(null, b, d, a, c);
                  break a;
                case 14:
                  b = $i(null, b, d, Ci(d.type, a), c);
                  break a;
              }
              throw Error(p(
                306,
                d,
                ""
              ));
            }
            return b;
          case 0:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), cj(a, b, d, e, c);
          case 1:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), hj(a, b, d, e, c);
          case 3:
            a: {
              kj(b);
              if (null === a) throw Error(p(387));
              d = b.pendingProps;
              f = b.memoizedState;
              e = f.element;
              lh(a, b);
              qh(b, d, null, c);
              var g = b.memoizedState;
              d = g.element;
              if (f.isDehydrated) if (f = { element: d, isDehydrated: false, cache: g.cache, pendingSuspenseBoundaries: g.pendingSuspenseBoundaries, transitions: g.transitions }, b.updateQueue.baseState = f, b.memoizedState = f, b.flags & 256) {
                e = Ji(Error(p(423)), b);
                b = lj(a, b, d, c, e);
                break a;
              } else if (d !== e) {
                e = Ji(Error(p(424)), b);
                b = lj(a, b, d, c, e);
                break a;
              } else for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I = true, zg = null, c = Vg(b, null, d, c), b.child = c; c; ) c.flags = c.flags & -3 | 4096, c = c.sibling;
              else {
                Ig();
                if (d === e) {
                  b = Zi(a, b, c);
                  break a;
                }
                Xi(a, b, d, c);
              }
              b = b.child;
            }
            return b;
          case 5:
            return Ah(b), null === a && Eg(b), d = b.type, e = b.pendingProps, f = null !== a ? a.memoizedProps : null, g = e.children, Ef(d, e) ? g = null : null !== f && Ef(d, f) && (b.flags |= 32), gj(a, b), Xi(a, b, g, c), b.child;
          case 6:
            return null === a && Eg(b), null;
          case 13:
            return oj(a, b, c);
          case 4:
            return yh(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Ug(b, null, d, c) : Xi(a, b, d, c), b.child;
          case 11:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), Yi(a, b, d, e, c);
          case 7:
            return Xi(a, b, b.pendingProps, c), b.child;
          case 8:
            return Xi(a, b, b.pendingProps.children, c), b.child;
          case 12:
            return Xi(a, b, b.pendingProps.children, c), b.child;
          case 10:
            a: {
              d = b.type._context;
              e = b.pendingProps;
              f = b.memoizedProps;
              g = e.value;
              G(Wg, d._currentValue);
              d._currentValue = g;
              if (null !== f) if (He(f.value, g)) {
                if (f.children === e.children && !Wf.current) {
                  b = Zi(a, b, c);
                  break a;
                }
              } else for (f = b.child, null !== f && (f.return = b); null !== f; ) {
                var h = f.dependencies;
                if (null !== h) {
                  g = f.child;
                  for (var k = h.firstContext; null !== k; ) {
                    if (k.context === d) {
                      if (1 === f.tag) {
                        k = mh(-1, c & -c);
                        k.tag = 2;
                        var l = f.updateQueue;
                        if (null !== l) {
                          l = l.shared;
                          var m = l.pending;
                          null === m ? k.next = k : (k.next = m.next, m.next = k);
                          l.pending = k;
                        }
                      }
                      f.lanes |= c;
                      k = f.alternate;
                      null !== k && (k.lanes |= c);
                      bh(
                        f.return,
                        c,
                        b
                      );
                      h.lanes |= c;
                      break;
                    }
                    k = k.next;
                  }
                } else if (10 === f.tag) g = f.type === b.type ? null : f.child;
                else if (18 === f.tag) {
                  g = f.return;
                  if (null === g) throw Error(p(341));
                  g.lanes |= c;
                  h = g.alternate;
                  null !== h && (h.lanes |= c);
                  bh(g, c, b);
                  g = f.sibling;
                } else g = f.child;
                if (null !== g) g.return = f;
                else for (g = f; null !== g; ) {
                  if (g === b) {
                    g = null;
                    break;
                  }
                  f = g.sibling;
                  if (null !== f) {
                    f.return = g.return;
                    g = f;
                    break;
                  }
                  g = g.return;
                }
                f = g;
              }
              Xi(a, b, e.children, c);
              b = b.child;
            }
            return b;
          case 9:
            return e = b.type, d = b.pendingProps.children, ch(b, c), e = eh(e), d = d(e), b.flags |= 1, Xi(a, b, d, c), b.child;
          case 14:
            return d = b.type, e = Ci(d, b.pendingProps), e = Ci(d.type, e), $i(a, b, d, e, c);
          case 15:
            return bj(a, b, b.type, b.pendingProps, c);
          case 17:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), ij(a, b), b.tag = 1, Zf(d) ? (a = true, cg(b)) : a = false, ch(b, c), Gi(b, d, e), Ii(b, d, e, c), jj(null, b, d, true, a, c);
          case 19:
            return xj(a, b, c);
          case 22:
            return dj(a, b, c);
        }
        throw Error(p(156, b.tag));
      };
      function Fk(a, b) {
        return ac(a, b);
      }
      function $k(a, b, c, d) {
        this.tag = a;
        this.key = c;
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
        this.index = 0;
        this.ref = null;
        this.pendingProps = b;
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
        this.mode = d;
        this.subtreeFlags = this.flags = 0;
        this.deletions = null;
        this.childLanes = this.lanes = 0;
        this.alternate = null;
      }
      function Bg(a, b, c, d) {
        return new $k(a, b, c, d);
      }
      function aj(a) {
        a = a.prototype;
        return !(!a || !a.isReactComponent);
      }
      function Zk(a) {
        if ("function" === typeof a) return aj(a) ? 1 : 0;
        if (void 0 !== a && null !== a) {
          a = a.$$typeof;
          if (a === Da) return 11;
          if (a === Ga) return 14;
        }
        return 2;
      }
      function Pg(a, b) {
        var c = a.alternate;
        null === c ? (c = Bg(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null);
        c.flags = a.flags & 14680064;
        c.childLanes = a.childLanes;
        c.lanes = a.lanes;
        c.child = a.child;
        c.memoizedProps = a.memoizedProps;
        c.memoizedState = a.memoizedState;
        c.updateQueue = a.updateQueue;
        b = a.dependencies;
        c.dependencies = null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
        c.sibling = a.sibling;
        c.index = a.index;
        c.ref = a.ref;
        return c;
      }
      function Rg(a, b, c, d, e, f) {
        var g = 2;
        d = a;
        if ("function" === typeof a) aj(a) && (g = 1);
        else if ("string" === typeof a) g = 5;
        else a: switch (a) {
          case ya:
            return Tg(c.children, e, f, b);
          case za:
            g = 8;
            e |= 8;
            break;
          case Aa:
            return a = Bg(12, c, b, e | 2), a.elementType = Aa, a.lanes = f, a;
          case Ea:
            return a = Bg(13, c, b, e), a.elementType = Ea, a.lanes = f, a;
          case Fa:
            return a = Bg(19, c, b, e), a.elementType = Fa, a.lanes = f, a;
          case Ia:
            return pj(c, e, f, b);
          default:
            if ("object" === typeof a && null !== a) switch (a.$$typeof) {
              case Ba:
                g = 10;
                break a;
              case Ca:
                g = 9;
                break a;
              case Da:
                g = 11;
                break a;
              case Ga:
                g = 14;
                break a;
              case Ha:
                g = 16;
                d = null;
                break a;
            }
            throw Error(p(130, null == a ? a : typeof a, ""));
        }
        b = Bg(g, c, b, e);
        b.elementType = a;
        b.type = d;
        b.lanes = f;
        return b;
      }
      function Tg(a, b, c, d) {
        a = Bg(7, a, d, b);
        a.lanes = c;
        return a;
      }
      function pj(a, b, c, d) {
        a = Bg(22, a, d, b);
        a.elementType = Ia;
        a.lanes = c;
        a.stateNode = { isHidden: false };
        return a;
      }
      function Qg(a, b, c) {
        a = Bg(6, a, null, b);
        a.lanes = c;
        return a;
      }
      function Sg(a, b, c) {
        b = Bg(4, null !== a.children ? a.children : [], a.key, b);
        b.lanes = c;
        b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
        return b;
      }
      function al(a, b, c, d, e) {
        this.tag = b;
        this.containerInfo = a;
        this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
        this.timeoutHandle = -1;
        this.callbackNode = this.pendingContext = this.context = null;
        this.callbackPriority = 0;
        this.eventTimes = zc(0);
        this.expirationTimes = zc(-1);
        this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
        this.entanglements = zc(0);
        this.identifierPrefix = d;
        this.onRecoverableError = e;
        this.mutableSourceEagerHydrationData = null;
      }
      function bl(a, b, c, d, e, f, g, h, k) {
        a = new al(a, b, c, h, k);
        1 === b ? (b = 1, true === f && (b |= 8)) : b = 0;
        f = Bg(3, null, null, b);
        a.current = f;
        f.stateNode = a;
        f.memoizedState = { element: d, isDehydrated: c, cache: null, transitions: null, pendingSuspenseBoundaries: null };
        kh(f);
        return a;
      }
      function cl(a, b, c) {
        var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        return { $$typeof: wa, key: null == d ? null : "" + d, children: a, containerInfo: b, implementation: c };
      }
      function dl(a) {
        if (!a) return Vf;
        a = a._reactInternals;
        a: {
          if (Vb(a) !== a || 1 !== a.tag) throw Error(p(170));
          var b = a;
          do {
            switch (b.tag) {
              case 3:
                b = b.stateNode.context;
                break a;
              case 1:
                if (Zf(b.type)) {
                  b = b.stateNode.__reactInternalMemoizedMergedChildContext;
                  break a;
                }
            }
            b = b.return;
          } while (null !== b);
          throw Error(p(171));
        }
        if (1 === a.tag) {
          var c = a.type;
          if (Zf(c)) return bg(a, c, b);
        }
        return b;
      }
      function el(a, b, c, d, e, f, g, h, k) {
        a = bl(c, d, true, a, e, f, g, h, k);
        a.context = dl(null);
        c = a.current;
        d = R();
        e = yi(c);
        f = mh(d, e);
        f.callback = void 0 !== b && null !== b ? b : null;
        nh(c, f, e);
        a.current.lanes = e;
        Ac(a, e, d);
        Dk(a, d);
        return a;
      }
      function fl(a, b, c, d) {
        var e = b.current, f = R(), g = yi(e);
        c = dl(c);
        null === b.context ? b.context = c : b.pendingContext = c;
        b = mh(f, g);
        b.payload = { element: a };
        d = void 0 === d ? null : d;
        null !== d && (b.callback = d);
        a = nh(e, b, g);
        null !== a && (gi(a, e, g, f), oh(a, e, g));
        return g;
      }
      function gl(a) {
        a = a.current;
        if (!a.child) return null;
        switch (a.child.tag) {
          case 5:
            return a.child.stateNode;
          default:
            return a.child.stateNode;
        }
      }
      function hl(a, b) {
        a = a.memoizedState;
        if (null !== a && null !== a.dehydrated) {
          var c = a.retryLane;
          a.retryLane = 0 !== c && c < b ? c : b;
        }
      }
      function il(a, b) {
        hl(a, b);
        (a = a.alternate) && hl(a, b);
      }
      function jl() {
        return null;
      }
      var kl = "function" === typeof reportError ? reportError : function(a) {
        console.error(a);
      };
      function ll(a) {
        this._internalRoot = a;
      }
      ml.prototype.render = ll.prototype.render = function(a) {
        var b = this._internalRoot;
        if (null === b) throw Error(p(409));
        fl(a, b, null, null);
      };
      ml.prototype.unmount = ll.prototype.unmount = function() {
        var a = this._internalRoot;
        if (null !== a) {
          this._internalRoot = null;
          var b = a.containerInfo;
          Rk(function() {
            fl(null, a, null, null);
          });
          b[uf] = null;
        }
      };
      function ml(a) {
        this._internalRoot = a;
      }
      ml.prototype.unstable_scheduleHydration = function(a) {
        if (a) {
          var b = Hc();
          a = { blockedOn: null, target: a, priority: b };
          for (var c = 0; c < Qc.length && 0 !== b && b < Qc[c].priority; c++) ;
          Qc.splice(c, 0, a);
          0 === c && Vc(a);
        }
      };
      function nl(a) {
        return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
      }
      function ol(a) {
        return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
      }
      function pl() {
      }
      function ql(a, b, c, d, e) {
        if (e) {
          if ("function" === typeof d) {
            var f = d;
            d = function() {
              var a2 = gl(g);
              f.call(a2);
            };
          }
          var g = el(b, d, a, 0, null, false, false, "", pl);
          a._reactRootContainer = g;
          a[uf] = g.current;
          sf(8 === a.nodeType ? a.parentNode : a);
          Rk();
          return g;
        }
        for (; e = a.lastChild; ) a.removeChild(e);
        if ("function" === typeof d) {
          var h = d;
          d = function() {
            var a2 = gl(k);
            h.call(a2);
          };
        }
        var k = bl(a, 0, false, null, null, false, false, "", pl);
        a._reactRootContainer = k;
        a[uf] = k.current;
        sf(8 === a.nodeType ? a.parentNode : a);
        Rk(function() {
          fl(b, k, c, d);
        });
        return k;
      }
      function rl(a, b, c, d, e) {
        var f = c._reactRootContainer;
        if (f) {
          var g = f;
          if ("function" === typeof e) {
            var h = e;
            e = function() {
              var a2 = gl(g);
              h.call(a2);
            };
          }
          fl(b, g, a, e);
        } else g = ql(c, b, a, e, d);
        return gl(g);
      }
      Ec = function(a) {
        switch (a.tag) {
          case 3:
            var b = a.stateNode;
            if (b.current.memoizedState.isDehydrated) {
              var c = tc(b.pendingLanes);
              0 !== c && (Cc(b, c | 1), Dk(b, B()), 0 === (K & 6) && (Gj = B() + 500, jg()));
            }
            break;
          case 13:
            Rk(function() {
              var b2 = ih(a, 1);
              if (null !== b2) {
                var c2 = R();
                gi(b2, a, 1, c2);
              }
            }), il(a, 1);
        }
      };
      Fc = function(a) {
        if (13 === a.tag) {
          var b = ih(a, 134217728);
          if (null !== b) {
            var c = R();
            gi(b, a, 134217728, c);
          }
          il(a, 134217728);
        }
      };
      Gc = function(a) {
        if (13 === a.tag) {
          var b = yi(a), c = ih(a, b);
          if (null !== c) {
            var d = R();
            gi(c, a, b, d);
          }
          il(a, b);
        }
      };
      Hc = function() {
        return C;
      };
      Ic = function(a, b) {
        var c = C;
        try {
          return C = a, b();
        } finally {
          C = c;
        }
      };
      yb = function(a, b, c) {
        switch (b) {
          case "input":
            bb(a, c);
            b = c.name;
            if ("radio" === c.type && null != b) {
              for (c = a; c.parentNode; ) c = c.parentNode;
              c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
              for (b = 0; b < c.length; b++) {
                var d = c[b];
                if (d !== a && d.form === a.form) {
                  var e = Db(d);
                  if (!e) throw Error(p(90));
                  Wa(d);
                  bb(d, e);
                }
              }
            }
            break;
          case "textarea":
            ib(a, c);
            break;
          case "select":
            b = c.value, null != b && fb(a, !!c.multiple, b, false);
        }
      };
      Gb = Qk;
      Hb = Rk;
      var sl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
      var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
        a = Zb(a);
        return null === a ? null : a.stateNode;
      }, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
      if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
        var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!vl.isDisabled && vl.supportsFiber) try {
          kc = vl.inject(ul), lc = vl;
        } catch (a) {
        }
      }
      reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
      reactDom_production_min.createPortal = function(a, b) {
        var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
        if (!nl(b)) throw Error(p(200));
        return cl(a, b, null, c);
      };
      reactDom_production_min.createRoot = function(a, b) {
        if (!nl(a)) throw Error(p(299));
        var c = false, d = "", e = kl;
        null !== b && void 0 !== b && (true === b.unstable_strictMode && (c = true), void 0 !== b.identifierPrefix && (d = b.identifierPrefix), void 0 !== b.onRecoverableError && (e = b.onRecoverableError));
        b = bl(a, 1, false, null, null, c, false, d, e);
        a[uf] = b.current;
        sf(8 === a.nodeType ? a.parentNode : a);
        return new ll(b);
      };
      reactDom_production_min.findDOMNode = function(a) {
        if (null == a) return null;
        if (1 === a.nodeType) return a;
        var b = a._reactInternals;
        if (void 0 === b) {
          if ("function" === typeof a.render) throw Error(p(188));
          a = Object.keys(a).join(",");
          throw Error(p(268, a));
        }
        a = Zb(b);
        a = null === a ? null : a.stateNode;
        return a;
      };
      reactDom_production_min.flushSync = function(a) {
        return Rk(a);
      };
      reactDom_production_min.hydrate = function(a, b, c) {
        if (!ol(b)) throw Error(p(200));
        return rl(null, a, b, true, c);
      };
      reactDom_production_min.hydrateRoot = function(a, b, c) {
        if (!nl(a)) throw Error(p(405));
        var d = null != c && c.hydratedSources || null, e = false, f = "", g = kl;
        null !== c && void 0 !== c && (true === c.unstable_strictMode && (e = true), void 0 !== c.identifierPrefix && (f = c.identifierPrefix), void 0 !== c.onRecoverableError && (g = c.onRecoverableError));
        b = el(b, null, a, 1, null != c ? c : null, e, false, f, g);
        a[uf] = b.current;
        sf(a);
        if (d) for (a = 0; a < d.length; a++) c = d[a], e = c._getVersion, e = e(c._source), null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [c, e] : b.mutableSourceEagerHydrationData.push(
          c,
          e
        );
        return new ml(b);
      };
      reactDom_production_min.render = function(a, b, c) {
        if (!ol(b)) throw Error(p(200));
        return rl(null, a, b, false, c);
      };
      reactDom_production_min.unmountComponentAtNode = function(a) {
        if (!ol(a)) throw Error(p(40));
        return a._reactRootContainer ? (Rk(function() {
          rl(null, null, a, false, function() {
            a._reactRootContainer = null;
            a[uf] = null;
          });
        }), true) : false;
      };
      reactDom_production_min.unstable_batchedUpdates = Qk;
      reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b, c, d) {
        if (!ol(c)) throw Error(p(200));
        if (null == a || void 0 === a._reactInternals) throw Error(p(38));
        return rl(a, b, c, false, d);
      };
      reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
      return reactDom_production_min;
    }
    var hasRequiredReactDom;
    function requireReactDom() {
      if (hasRequiredReactDom) return reactDom.exports;
      hasRequiredReactDom = 1;
      function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
          return;
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
      }
      {
        checkDCE();
        reactDom.exports = requireReactDom_production_min();
      }
      return reactDom.exports;
    }
    var hasRequiredClient;
    function requireClient() {
      if (hasRequiredClient) return client;
      hasRequiredClient = 1;
      var m = requireReactDom();
      {
        client.createRoot = m.createRoot;
        client.hydrateRoot = m.hydrateRoot;
      }
      return client;
    }
    var clientExports = requireClient();
    const ReactDOM$1 = /* @__PURE__ */ getDefaultExportFromCjs(clientExports);
    /**
     * react-router v7.7.1
     *
     * Copyright (c) Remix Software Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     */
    var PopStateEventType = "popstate";
    function createBrowserHistory(options = {}) {
      function createBrowserLocation(window2, globalHistory) {
        let { pathname, search, hash } = window2.location;
        return createLocation(
          "",
          { pathname, search, hash },
          // state defaults to `null` because `window.history.state` does
          globalHistory.state && globalHistory.state.usr || null,
          globalHistory.state && globalHistory.state.key || "default"
        );
      }
      function createBrowserHref(window2, to) {
        return typeof to === "string" ? to : createPath(to);
      }
      return getUrlBasedHistory(
        createBrowserLocation,
        createBrowserHref,
        null,
        options
      );
    }
    function invariant(value, message) {
      if (value === false || value === null || typeof value === "undefined") {
        throw new Error(message);
      }
    }
    function warning(cond, message) {
      if (!cond) {
        if (typeof console !== "undefined") console.warn(message);
        try {
          throw new Error(message);
        } catch (e) {
        }
      }
    }
    function createKey() {
      return Math.random().toString(36).substring(2, 10);
    }
    function getHistoryState(location, index) {
      return {
        usr: location.state,
        key: location.key,
        idx: index
      };
    }
    function createLocation(current2, to, state = null, key) {
      let location = {
        pathname: typeof current2 === "string" ? current2 : current2.pathname,
        search: "",
        hash: "",
        ...typeof to === "string" ? parsePath(to) : to,
        state,
        // TODO: This could be cleaned up.  push/replace should probably just take
        // full Locations now and avoid the need to run through this flow at all
        // But that's a pretty big refactor to the current test suite so going to
        // keep as is for the time being and just let any incoming keys take precedence
        key: to && to.key || key || createKey()
      };
      return location;
    }
    function createPath({
      pathname = "/",
      search = "",
      hash = ""
    }) {
      if (search && search !== "?")
        pathname += search.charAt(0) === "?" ? search : "?" + search;
      if (hash && hash !== "#")
        pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
      return pathname;
    }
    function parsePath(path) {
      let parsedPath = {};
      if (path) {
        let hashIndex = path.indexOf("#");
        if (hashIndex >= 0) {
          parsedPath.hash = path.substring(hashIndex);
          path = path.substring(0, hashIndex);
        }
        let searchIndex = path.indexOf("?");
        if (searchIndex >= 0) {
          parsedPath.search = path.substring(searchIndex);
          path = path.substring(0, searchIndex);
        }
        if (path) {
          parsedPath.pathname = path;
        }
      }
      return parsedPath;
    }
    function getUrlBasedHistory(getLocation, createHref2, validateLocation, options = {}) {
      let { window: window2 = document.defaultView, v5Compat = false } = options;
      let globalHistory = window2.history;
      let action = "POP";
      let listener = null;
      let index = getIndex();
      if (index == null) {
        index = 0;
        globalHistory.replaceState({ ...globalHistory.state, idx: index }, "");
      }
      function getIndex() {
        let state = globalHistory.state || { idx: null };
        return state.idx;
      }
      function handlePop() {
        action = "POP";
        let nextIndex = getIndex();
        let delta = nextIndex == null ? null : nextIndex - index;
        index = nextIndex;
        if (listener) {
          listener({ action, location: history.location, delta });
        }
      }
      function push(to, state) {
        action = "PUSH";
        let location = createLocation(history.location, to, state);
        index = getIndex() + 1;
        let historyState = getHistoryState(location, index);
        let url = history.createHref(location);
        try {
          globalHistory.pushState(historyState, "", url);
        } catch (error) {
          if (error instanceof DOMException && error.name === "DataCloneError") {
            throw error;
          }
          window2.location.assign(url);
        }
        if (v5Compat && listener) {
          listener({ action, location: history.location, delta: 1 });
        }
      }
      function replace2(to, state) {
        action = "REPLACE";
        let location = createLocation(history.location, to, state);
        index = getIndex();
        let historyState = getHistoryState(location, index);
        let url = history.createHref(location);
        globalHistory.replaceState(historyState, "", url);
        if (v5Compat && listener) {
          listener({ action, location: history.location, delta: 0 });
        }
      }
      function createURL(to) {
        return createBrowserURLImpl(to);
      }
      let history = {
        get action() {
          return action;
        },
        get location() {
          return getLocation(window2, globalHistory);
        },
        listen(fn) {
          if (listener) {
            throw new Error("A history only accepts one active listener");
          }
          window2.addEventListener(PopStateEventType, handlePop);
          listener = fn;
          return () => {
            window2.removeEventListener(PopStateEventType, handlePop);
            listener = null;
          };
        },
        createHref(to) {
          return createHref2(window2, to);
        },
        createURL,
        encodeLocation(to) {
          let url = createURL(to);
          return {
            pathname: url.pathname,
            search: url.search,
            hash: url.hash
          };
        },
        push,
        replace: replace2,
        go(n) {
          return globalHistory.go(n);
        }
      };
      return history;
    }
    function createBrowserURLImpl(to, isAbsolute = false) {
      let base = "http://localhost";
      if (typeof window !== "undefined") {
        base = window.location.origin !== "null" ? window.location.origin : window.location.href;
      }
      invariant(base, "No window.location.(origin|href) available to create URL");
      let href = typeof to === "string" ? to : createPath(to);
      href = href.replace(/ $/, "%20");
      if (!isAbsolute && href.startsWith("//")) {
        href = base + href;
      }
      return new URL(href, base);
    }
    function matchRoutes(routes, locationArg, basename = "/") {
      return matchRoutesImpl(routes, locationArg, basename, false);
    }
    function matchRoutesImpl(routes, locationArg, basename, allowPartial) {
      let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
      let pathname = stripBasename(location.pathname || "/", basename);
      if (pathname == null) {
        return null;
      }
      let branches = flattenRoutes(routes);
      rankRouteBranches(branches);
      let matches2 = null;
      for (let i = 0; matches2 == null && i < branches.length; ++i) {
        let decoded = decodePath(pathname);
        matches2 = matchRouteBranch(
          branches[i],
          decoded,
          allowPartial
        );
      }
      return matches2;
    }
    function flattenRoutes(routes, branches = [], parentsMeta = [], parentPath = "") {
      let flattenRoute = (route, index, relativePath) => {
        let meta = {
          relativePath: relativePath === void 0 ? route.path || "" : relativePath,
          caseSensitive: route.caseSensitive === true,
          childrenIndex: index,
          route
        };
        if (meta.relativePath.startsWith("/")) {
          invariant(
            meta.relativePath.startsWith(parentPath),
            `Absolute route path "${meta.relativePath}" nested under path "${parentPath}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`
          );
          meta.relativePath = meta.relativePath.slice(parentPath.length);
        }
        let path = joinPaths([parentPath, meta.relativePath]);
        let routesMeta = parentsMeta.concat(meta);
        if (route.children && route.children.length > 0) {
          invariant(
            // Our types know better, but runtime JS may not!
            // @ts-expect-error
            route.index !== true,
            `Index routes must not have child routes. Please remove all child routes from route path "${path}".`
          );
          flattenRoutes(route.children, branches, routesMeta, path);
        }
        if (route.path == null && !route.index) {
          return;
        }
        branches.push({
          path,
          score: computeScore(path, route.index),
          routesMeta
        });
      };
      routes.forEach((route, index) => {
        var _a;
        if (route.path === "" || !((_a = route.path) == null ? void 0 : _a.includes("?"))) {
          flattenRoute(route, index);
        } else {
          for (let exploded of explodeOptionalSegments(route.path)) {
            flattenRoute(route, index, exploded);
          }
        }
      });
      return branches;
    }
    function explodeOptionalSegments(path) {
      let segments = path.split("/");
      if (segments.length === 0) return [];
      let [first, ...rest] = segments;
      let isOptional = first.endsWith("?");
      let required = first.replace(/\?$/, "");
      if (rest.length === 0) {
        return isOptional ? [required, ""] : [required];
      }
      let restExploded = explodeOptionalSegments(rest.join("/"));
      let result = [];
      result.push(
        ...restExploded.map(
          (subpath) => subpath === "" ? required : [required, subpath].join("/")
        )
      );
      if (isOptional) {
        result.push(...restExploded);
      }
      return result.map(
        (exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded
      );
    }
    function rankRouteBranches(branches) {
      branches.sort(
        (a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(
          a.routesMeta.map((meta) => meta.childrenIndex),
          b.routesMeta.map((meta) => meta.childrenIndex)
        )
      );
    }
    var paramRe = /^:[\w-]+$/;
    var dynamicSegmentValue = 3;
    var indexRouteValue = 2;
    var emptySegmentValue = 1;
    var staticSegmentValue = 10;
    var splatPenalty = -2;
    var isSplat = (s) => s === "*";
    function computeScore(path, index) {
      let segments = path.split("/");
      let initialScore = segments.length;
      if (segments.some(isSplat)) {
        initialScore += splatPenalty;
      }
      if (index) {
        initialScore += indexRouteValue;
      }
      return segments.filter((s) => !isSplat(s)).reduce(
        (score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue),
        initialScore
      );
    }
    function compareIndexes(a, b) {
      let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
      return siblings ? (
        // If two routes are siblings, we should try to match the earlier sibling
        // first. This allows people to have fine-grained control over the matching
        // behavior by simply putting routes with identical paths in the order they
        // want them tried.
        a[a.length - 1] - b[b.length - 1]
      ) : (
        // Otherwise, it doesn't really make sense to rank non-siblings by index,
        // so they sort equally.
        0
      );
    }
    function matchRouteBranch(branch, pathname, allowPartial = false) {
      let { routesMeta } = branch;
      let matchedParams = {};
      let matchedPathname = "/";
      let matches2 = [];
      for (let i = 0; i < routesMeta.length; ++i) {
        let meta = routesMeta[i];
        let end = i === routesMeta.length - 1;
        let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
        let match = matchPath(
          { path: meta.relativePath, caseSensitive: meta.caseSensitive, end },
          remainingPathname
        );
        let route = meta.route;
        if (!match && end && allowPartial && !routesMeta[routesMeta.length - 1].route.index) {
          match = matchPath(
            {
              path: meta.relativePath,
              caseSensitive: meta.caseSensitive,
              end: false
            },
            remainingPathname
          );
        }
        if (!match) {
          return null;
        }
        Object.assign(matchedParams, match.params);
        matches2.push({
          // TODO: Can this as be avoided?
          params: matchedParams,
          pathname: joinPaths([matchedPathname, match.pathname]),
          pathnameBase: normalizePathname(
            joinPaths([matchedPathname, match.pathnameBase])
          ),
          route
        });
        if (match.pathnameBase !== "/") {
          matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
        }
      }
      return matches2;
    }
    function matchPath(pattern, pathname) {
      if (typeof pattern === "string") {
        pattern = { path: pattern, caseSensitive: false, end: true };
      }
      let [matcher, compiledParams] = compilePath(
        pattern.path,
        pattern.caseSensitive,
        pattern.end
      );
      let match = pathname.match(matcher);
      if (!match) return null;
      let matchedPathname = match[0];
      let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
      let captureGroups = match.slice(1);
      let params = compiledParams.reduce(
        (memo2, { paramName, isOptional }, index) => {
          if (paramName === "*") {
            let splatValue = captureGroups[index] || "";
            pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
          }
          const value = captureGroups[index];
          if (isOptional && !value) {
            memo2[paramName] = void 0;
          } else {
            memo2[paramName] = (value || "").replace(/%2F/g, "/");
          }
          return memo2;
        },
        {}
      );
      return {
        params,
        pathname: matchedPathname,
        pathnameBase,
        pattern
      };
    }
    function compilePath(path, caseSensitive = false, end = true) {
      warning(
        path === "*" || !path.endsWith("*") || path.endsWith("/*"),
        `Route path "${path}" will be treated as if it were "${path.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${path.replace(/\*$/, "/*")}".`
      );
      let params = [];
      let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(
        /\/:([\w-]+)(\?)?/g,
        (_, paramName, isOptional) => {
          params.push({ paramName, isOptional: isOptional != null });
          return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
        }
      );
      if (path.endsWith("*")) {
        params.push({ paramName: "*" });
        regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
      } else if (end) {
        regexpSource += "\\/*$";
      } else if (path !== "" && path !== "/") {
        regexpSource += "(?:(?=\\/|$))";
      } else ;
      let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
      return [matcher, params];
    }
    function decodePath(value) {
      try {
        return value.split("/").map((v) => decodeURIComponent(v).replace(/\//g, "%2F")).join("/");
      } catch (error) {
        warning(
          false,
          `The URL path "${value}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${error}).`
        );
        return value;
      }
    }
    function stripBasename(pathname, basename) {
      if (basename === "/") return pathname;
      if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
        return null;
      }
      let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
      let nextChar = pathname.charAt(startIndex);
      if (nextChar && nextChar !== "/") {
        return null;
      }
      return pathname.slice(startIndex) || "/";
    }
    function resolvePath(to, fromPathname = "/") {
      let {
        pathname: toPathname,
        search = "",
        hash = ""
      } = typeof to === "string" ? parsePath(to) : to;
      let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
      return {
        pathname,
        search: normalizeSearch(search),
        hash: normalizeHash(hash)
      };
    }
    function resolvePathname(relativePath, fromPathname) {
      let segments = fromPathname.replace(/\/+$/, "").split("/");
      let relativeSegments = relativePath.split("/");
      relativeSegments.forEach((segment) => {
        if (segment === "..") {
          if (segments.length > 1) segments.pop();
        } else if (segment !== ".") {
          segments.push(segment);
        }
      });
      return segments.length > 1 ? segments.join("/") : "/";
    }
    function getInvalidPathError(char, field, dest, path) {
      return `Cannot include a '${char}' character in a manually specified \`to.${field}\` field [${JSON.stringify(
        path
      )}].  Please separate it out to the \`to.${dest}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`;
    }
    function getPathContributingMatches(matches2) {
      return matches2.filter(
        (match, index) => index === 0 || match.route.path && match.route.path.length > 0
      );
    }
    function getResolveToMatches(matches2) {
      let pathMatches = getPathContributingMatches(matches2);
      return pathMatches.map(
        (match, idx) => idx === pathMatches.length - 1 ? match.pathname : match.pathnameBase
      );
    }
    function resolveTo(toArg, routePathnames, locationPathname, isPathRelative = false) {
      let to;
      if (typeof toArg === "string") {
        to = parsePath(toArg);
      } else {
        to = { ...toArg };
        invariant(
          !to.pathname || !to.pathname.includes("?"),
          getInvalidPathError("?", "pathname", "search", to)
        );
        invariant(
          !to.pathname || !to.pathname.includes("#"),
          getInvalidPathError("#", "pathname", "hash", to)
        );
        invariant(
          !to.search || !to.search.includes("#"),
          getInvalidPathError("#", "search", "hash", to)
        );
      }
      let isEmptyPath = toArg === "" || to.pathname === "";
      let toPathname = isEmptyPath ? "/" : to.pathname;
      let from;
      if (toPathname == null) {
        from = locationPathname;
      } else {
        let routePathnameIndex = routePathnames.length - 1;
        if (!isPathRelative && toPathname.startsWith("..")) {
          let toSegments = toPathname.split("/");
          while (toSegments[0] === "..") {
            toSegments.shift();
            routePathnameIndex -= 1;
          }
          to.pathname = toSegments.join("/");
        }
        from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
      }
      let path = resolvePath(to, from);
      let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
      let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
      if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
        path.pathname += "/";
      }
      return path;
    }
    var joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
    var normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
    var normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
    var normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
    function isRouteErrorResponse(error) {
      return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
    }
    var validMutationMethodsArr = [
      "POST",
      "PUT",
      "PATCH",
      "DELETE"
    ];
    new Set(
      validMutationMethodsArr
    );
    var validRequestMethodsArr = [
      "GET",
      ...validMutationMethodsArr
    ];
    new Set(validRequestMethodsArr);
    var DataRouterContext = reactExports.createContext(null);
    DataRouterContext.displayName = "DataRouter";
    var DataRouterStateContext = reactExports.createContext(null);
    DataRouterStateContext.displayName = "DataRouterState";
    reactExports.createContext(false);
    var ViewTransitionContext = reactExports.createContext({
      isTransitioning: false
    });
    ViewTransitionContext.displayName = "ViewTransition";
    var FetchersContext = reactExports.createContext(
      /* @__PURE__ */ new Map()
    );
    FetchersContext.displayName = "Fetchers";
    var AwaitContext = reactExports.createContext(null);
    AwaitContext.displayName = "Await";
    var NavigationContext = reactExports.createContext(
      null
    );
    NavigationContext.displayName = "Navigation";
    var LocationContext = reactExports.createContext(
      null
    );
    LocationContext.displayName = "Location";
    var RouteContext = reactExports.createContext({
      outlet: null,
      matches: [],
      isDataRoute: false
    });
    RouteContext.displayName = "Route";
    var RouteErrorContext = reactExports.createContext(null);
    RouteErrorContext.displayName = "RouteError";
    function useHref(to, { relative } = {}) {
      invariant(
        useInRouterContext(),
        // TODO: This error is probably because they somehow have 2 versions of the
        // router loaded. We can help them understand how to avoid that.
        `useHref() may be used only in the context of a <Router> component.`
      );
      let { basename, navigator: navigator2 } = reactExports.useContext(NavigationContext);
      let { hash, pathname, search } = useResolvedPath(to, { relative });
      let joinedPathname = pathname;
      if (basename !== "/") {
        joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
      }
      return navigator2.createHref({ pathname: joinedPathname, search, hash });
    }
    function useInRouterContext() {
      return reactExports.useContext(LocationContext) != null;
    }
    function useLocation() {
      invariant(
        useInRouterContext(),
        // TODO: This error is probably because they somehow have 2 versions of the
        // router loaded. We can help them understand how to avoid that.
        `useLocation() may be used only in the context of a <Router> component.`
      );
      return reactExports.useContext(LocationContext).location;
    }
    var navigateEffectWarning = `You should call navigate() in a React.useEffect(), not when your component is first rendered.`;
    function useIsomorphicLayoutEffect$3(cb) {
      let isStatic = reactExports.useContext(NavigationContext).static;
      if (!isStatic) {
        reactExports.useLayoutEffect(cb);
      }
    }
    function useNavigate() {
      let { isDataRoute } = reactExports.useContext(RouteContext);
      return isDataRoute ? useNavigateStable() : useNavigateUnstable();
    }
    function useNavigateUnstable() {
      invariant(
        useInRouterContext(),
        // TODO: This error is probably because they somehow have 2 versions of the
        // router loaded. We can help them understand how to avoid that.
        `useNavigate() may be used only in the context of a <Router> component.`
      );
      let dataRouterContext = reactExports.useContext(DataRouterContext);
      let { basename, navigator: navigator2 } = reactExports.useContext(NavigationContext);
      let { matches: matches2 } = reactExports.useContext(RouteContext);
      let { pathname: locationPathname } = useLocation();
      let routePathnamesJson = JSON.stringify(getResolveToMatches(matches2));
      let activeRef = reactExports.useRef(false);
      useIsomorphicLayoutEffect$3(() => {
        activeRef.current = true;
      });
      let navigate = reactExports.useCallback(
        (to, options = {}) => {
          warning(activeRef.current, navigateEffectWarning);
          if (!activeRef.current) return;
          if (typeof to === "number") {
            navigator2.go(to);
            return;
          }
          let path = resolveTo(
            to,
            JSON.parse(routePathnamesJson),
            locationPathname,
            options.relative === "path"
          );
          if (dataRouterContext == null && basename !== "/") {
            path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
          }
          (!!options.replace ? navigator2.replace : navigator2.push)(
            path,
            options.state,
            options
          );
        },
        [
          basename,
          navigator2,
          routePathnamesJson,
          locationPathname,
          dataRouterContext
        ]
      );
      return navigate;
    }
    reactExports.createContext(null);
    function useResolvedPath(to, { relative } = {}) {
      let { matches: matches2 } = reactExports.useContext(RouteContext);
      let { pathname: locationPathname } = useLocation();
      let routePathnamesJson = JSON.stringify(getResolveToMatches(matches2));
      return reactExports.useMemo(
        () => resolveTo(
          to,
          JSON.parse(routePathnamesJson),
          locationPathname,
          relative === "path"
        ),
        [to, routePathnamesJson, locationPathname, relative]
      );
    }
    function useRoutes(routes, locationArg) {
      return useRoutesImpl(routes, locationArg);
    }
    function useRoutesImpl(routes, locationArg, dataRouterState, future) {
      var _a;
      invariant(
        useInRouterContext(),
        // TODO: This error is probably because they somehow have 2 versions of the
        // router loaded. We can help them understand how to avoid that.
        `useRoutes() may be used only in the context of a <Router> component.`
      );
      let { navigator: navigator2 } = reactExports.useContext(NavigationContext);
      let { matches: parentMatches } = reactExports.useContext(RouteContext);
      let routeMatch = parentMatches[parentMatches.length - 1];
      let parentParams = routeMatch ? routeMatch.params : {};
      let parentPathname = routeMatch ? routeMatch.pathname : "/";
      let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
      let parentRoute = routeMatch && routeMatch.route;
      {
        let parentPath = parentRoute && parentRoute.path || "";
        warningOnce(
          parentPathname,
          !parentRoute || parentPath.endsWith("*") || parentPath.endsWith("*?"),
          `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${parentPathname}" (under <Route path="${parentPath}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${parentPath}"> to <Route path="${parentPath === "/" ? "*" : `${parentPath}/*`}">.`
        );
      }
      let locationFromContext = useLocation();
      let location;
      if (locationArg) {
        let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
        invariant(
          parentPathnameBase === "/" || ((_a = parsedLocationArg.pathname) == null ? void 0 : _a.startsWith(parentPathnameBase)),
          `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${parentPathnameBase}" but pathname "${parsedLocationArg.pathname}" was given in the \`location\` prop.`
        );
        location = parsedLocationArg;
      } else {
        location = locationFromContext;
      }
      let pathname = location.pathname || "/";
      let remainingPathname = pathname;
      if (parentPathnameBase !== "/") {
        let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
        let segments = pathname.replace(/^\//, "").split("/");
        remainingPathname = "/" + segments.slice(parentSegments.length).join("/");
      }
      let matches2 = matchRoutes(routes, { pathname: remainingPathname });
      {
        warning(
          parentRoute || matches2 != null,
          `No routes matched location "${location.pathname}${location.search}${location.hash}" `
        );
        warning(
          matches2 == null || matches2[matches2.length - 1].route.element !== void 0 || matches2[matches2.length - 1].route.Component !== void 0 || matches2[matches2.length - 1].route.lazy !== void 0,
          `Matched leaf route at location "${location.pathname}${location.search}${location.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`
        );
      }
      let renderedMatches = _renderMatches(
        matches2 && matches2.map(
          (match) => Object.assign({}, match, {
            params: Object.assign({}, parentParams, match.params),
            pathname: joinPaths([
              parentPathnameBase,
              // Re-encode pathnames that were decoded inside matchRoutes
              navigator2.encodeLocation ? navigator2.encodeLocation(match.pathname).pathname : match.pathname
            ]),
            pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([
              parentPathnameBase,
              // Re-encode pathnames that were decoded inside matchRoutes
              navigator2.encodeLocation ? navigator2.encodeLocation(match.pathnameBase).pathname : match.pathnameBase
            ])
          })
        ),
        parentMatches,
        dataRouterState,
        future
      );
      if (locationArg && renderedMatches) {
        return /* @__PURE__ */ reactExports.createElement(
          LocationContext.Provider,
          {
            value: {
              location: {
                pathname: "/",
                search: "",
                hash: "",
                state: null,
                key: "default",
                ...location
              },
              navigationType: "POP"
              /* Pop */
            }
          },
          renderedMatches
        );
      }
      return renderedMatches;
    }
    function DefaultErrorComponent() {
      let error = useRouteError();
      let message = isRouteErrorResponse(error) ? `${error.status} ${error.statusText}` : error instanceof Error ? error.message : JSON.stringify(error);
      let stack = error instanceof Error ? error.stack : null;
      let lightgrey = "rgba(200,200,200, 0.5)";
      let preStyles = { padding: "0.5rem", backgroundColor: lightgrey };
      let codeStyles = { padding: "2px 4px", backgroundColor: lightgrey };
      let devInfo = null;
      {
        console.error(
          "Error handled by React Router default ErrorBoundary:",
          error
        );
        devInfo = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("p", null, " Hey developer "), /* @__PURE__ */ reactExports.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */ reactExports.createElement("code", { style: codeStyles }, "ErrorBoundary"), " or", " ", /* @__PURE__ */ reactExports.createElement("code", { style: codeStyles }, "errorElement"), " prop on your route."));
      }
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ reactExports.createElement("h3", { style: { fontStyle: "italic" } }, message), stack ? /* @__PURE__ */ reactExports.createElement("pre", { style: preStyles }, stack) : null, devInfo);
    }
    var defaultErrorElement = /* @__PURE__ */ reactExports.createElement(DefaultErrorComponent, null);
    var RenderErrorBoundary = class extends reactExports.Component {
      constructor(props) {
        super(props);
        this.state = {
          location: props.location,
          revalidation: props.revalidation,
          error: props.error
        };
      }
      static getDerivedStateFromError(error) {
        return { error };
      }
      static getDerivedStateFromProps(props, state) {
        if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
          return {
            error: props.error,
            location: props.location,
            revalidation: props.revalidation
          };
        }
        return {
          error: props.error !== void 0 ? props.error : state.error,
          location: state.location,
          revalidation: props.revalidation || state.revalidation
        };
      }
      componentDidCatch(error, errorInfo) {
        console.error(
          "React Router caught the following error during render",
          error,
          errorInfo
        );
      }
      render() {
        return this.state.error !== void 0 ? /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, { value: this.props.routeContext }, /* @__PURE__ */ reactExports.createElement(
          RouteErrorContext.Provider,
          {
            value: this.state.error,
            children: this.props.component
          }
        )) : this.props.children;
      }
    };
    function RenderedRoute({ routeContext, match, children }) {
      let dataRouterContext = reactExports.useContext(DataRouterContext);
      if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {
        dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;
      }
      return /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, { value: routeContext }, children);
    }
    function _renderMatches(matches2, parentMatches = [], dataRouterState = null, future = null) {
      if (matches2 == null) {
        if (!dataRouterState) {
          return null;
        }
        if (dataRouterState.errors) {
          matches2 = dataRouterState.matches;
        } else if (parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {
          matches2 = dataRouterState.matches;
        } else {
          return null;
        }
      }
      let renderedMatches = matches2;
      let errors = dataRouterState == null ? void 0 : dataRouterState.errors;
      if (errors != null) {
        let errorIndex = renderedMatches.findIndex(
          (m) => m.route.id && (errors == null ? void 0 : errors[m.route.id]) !== void 0
        );
        invariant(
          errorIndex >= 0,
          `Could not find a matching route for errors on route IDs: ${Object.keys(
            errors
          ).join(",")}`
        );
        renderedMatches = renderedMatches.slice(
          0,
          Math.min(renderedMatches.length, errorIndex + 1)
        );
      }
      let renderFallback = false;
      let fallbackIndex = -1;
      if (dataRouterState) {
        for (let i = 0; i < renderedMatches.length; i++) {
          let match = renderedMatches[i];
          if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {
            fallbackIndex = i;
          }
          if (match.route.id) {
            let { loaderData, errors: errors2 } = dataRouterState;
            let needsToRunLoader = match.route.loader && !loaderData.hasOwnProperty(match.route.id) && (!errors2 || errors2[match.route.id] === void 0);
            if (match.route.lazy || needsToRunLoader) {
              renderFallback = true;
              if (fallbackIndex >= 0) {
                renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
              } else {
                renderedMatches = [renderedMatches[0]];
              }
              break;
            }
          }
        }
      }
      return renderedMatches.reduceRight(
        (outlet, match, index) => {
          let error;
          let shouldRenderHydrateFallback = false;
          let errorElement = null;
          let hydrateFallbackElement = null;
          if (dataRouterState) {
            error = errors && match.route.id ? errors[match.route.id] : void 0;
            errorElement = match.route.errorElement || defaultErrorElement;
            if (renderFallback) {
              if (fallbackIndex < 0 && index === 0) {
                warningOnce(
                  "route-fallback",
                  false,
                  "No `HydrateFallback` element provided to render during initial hydration"
                );
                shouldRenderHydrateFallback = true;
                hydrateFallbackElement = null;
              } else if (fallbackIndex === index) {
                shouldRenderHydrateFallback = true;
                hydrateFallbackElement = match.route.hydrateFallbackElement || null;
              }
            }
          }
          let matches22 = parentMatches.concat(renderedMatches.slice(0, index + 1));
          let getChildren = () => {
            let children;
            if (error) {
              children = errorElement;
            } else if (shouldRenderHydrateFallback) {
              children = hydrateFallbackElement;
            } else if (match.route.Component) {
              children = /* @__PURE__ */ reactExports.createElement(match.route.Component, null);
            } else if (match.route.element) {
              children = match.route.element;
            } else {
              children = outlet;
            }
            return /* @__PURE__ */ reactExports.createElement(
              RenderedRoute,
              {
                match,
                routeContext: {
                  outlet,
                  matches: matches22,
                  isDataRoute: dataRouterState != null
                },
                children
              }
            );
          };
          return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /* @__PURE__ */ reactExports.createElement(
            RenderErrorBoundary,
            {
              location: dataRouterState.location,
              revalidation: dataRouterState.revalidation,
              component: errorElement,
              error,
              children: getChildren(),
              routeContext: { outlet: null, matches: matches22, isDataRoute: true }
            }
          ) : getChildren();
        },
        null
      );
    }
    function getDataRouterConsoleError(hookName) {
      return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
    }
    function useDataRouterContext(hookName) {
      let ctx = reactExports.useContext(DataRouterContext);
      invariant(ctx, getDataRouterConsoleError(hookName));
      return ctx;
    }
    function useDataRouterState(hookName) {
      let state = reactExports.useContext(DataRouterStateContext);
      invariant(state, getDataRouterConsoleError(hookName));
      return state;
    }
    function useRouteContext(hookName) {
      let route = reactExports.useContext(RouteContext);
      invariant(route, getDataRouterConsoleError(hookName));
      return route;
    }
    function useCurrentRouteId(hookName) {
      let route = useRouteContext(hookName);
      let thisRoute = route.matches[route.matches.length - 1];
      invariant(
        thisRoute.route.id,
        `${hookName} can only be used on routes that contain a unique "id"`
      );
      return thisRoute.route.id;
    }
    function useRouteId() {
      return useCurrentRouteId(
        "useRouteId"
        /* UseRouteId */
      );
    }
    function useRouteError() {
      var _a;
      let error = reactExports.useContext(RouteErrorContext);
      let state = useDataRouterState(
        "useRouteError"
        /* UseRouteError */
      );
      let routeId = useCurrentRouteId(
        "useRouteError"
        /* UseRouteError */
      );
      if (error !== void 0) {
        return error;
      }
      return (_a = state.errors) == null ? void 0 : _a[routeId];
    }
    function useNavigateStable() {
      let { router } = useDataRouterContext(
        "useNavigate"
        /* UseNavigateStable */
      );
      let id = useCurrentRouteId(
        "useNavigate"
        /* UseNavigateStable */
      );
      let activeRef = reactExports.useRef(false);
      useIsomorphicLayoutEffect$3(() => {
        activeRef.current = true;
      });
      let navigate = reactExports.useCallback(
        async (to, options = {}) => {
          warning(activeRef.current, navigateEffectWarning);
          if (!activeRef.current) return;
          if (typeof to === "number") {
            router.navigate(to);
          } else {
            await router.navigate(to, { fromRouteId: id, ...options });
          }
        },
        [router, id]
      );
      return navigate;
    }
    var alreadyWarned = {};
    function warningOnce(key, cond, message) {
      if (!cond && !alreadyWarned[key]) {
        alreadyWarned[key] = true;
        warning(false, message);
      }
    }
    reactExports.memo(DataRoutes);
    function DataRoutes({
      routes,
      future,
      state
    }) {
      return useRoutesImpl(routes, void 0, state, future);
    }
    function Route(props) {
      invariant(
        false,
        `A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.`
      );
    }
    function Router({
      basename: basenameProp = "/",
      children = null,
      location: locationProp,
      navigationType = "POP",
      navigator: navigator2,
      static: staticProp = false
    }) {
      invariant(
        !useInRouterContext(),
        `You cannot render a <Router> inside another <Router>. You should never have more than one in your app.`
      );
      let basename = basenameProp.replace(/^\/*/, "/");
      let navigationContext = reactExports.useMemo(
        () => ({
          basename,
          navigator: navigator2,
          static: staticProp,
          future: {}
        }),
        [basename, navigator2, staticProp]
      );
      if (typeof locationProp === "string") {
        locationProp = parsePath(locationProp);
      }
      let {
        pathname = "/",
        search = "",
        hash = "",
        state = null,
        key = "default"
      } = locationProp;
      let locationContext = reactExports.useMemo(() => {
        let trailingPathname = stripBasename(pathname, basename);
        if (trailingPathname == null) {
          return null;
        }
        return {
          location: {
            pathname: trailingPathname,
            search,
            hash,
            state,
            key
          },
          navigationType
        };
      }, [basename, pathname, search, hash, state, key, navigationType]);
      warning(
        locationContext != null,
        `<Router basename="${basename}"> is not able to match the URL "${pathname}${search}${hash}" because it does not start with the basename, so the <Router> won't render anything.`
      );
      if (locationContext == null) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, { value: navigationContext }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, { children, value: locationContext }));
    }
    function Routes({
      children,
      location
    }) {
      return useRoutes(createRoutesFromChildren(children), location);
    }
    function createRoutesFromChildren(children, parentPath = []) {
      let routes = [];
      reactExports.Children.forEach(children, (element, index) => {
        if (!reactExports.isValidElement(element)) {
          return;
        }
        let treePath = [...parentPath, index];
        if (element.type === reactExports.Fragment) {
          routes.push.apply(
            routes,
            createRoutesFromChildren(element.props.children, treePath)
          );
          return;
        }
        invariant(
          element.type === Route,
          `[${typeof element.type === "string" ? element.type : element.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`
        );
        invariant(
          !element.props.index || !element.props.children,
          "An index route cannot have child routes."
        );
        let route = {
          id: element.props.id || treePath.join("-"),
          caseSensitive: element.props.caseSensitive,
          element: element.props.element,
          Component: element.props.Component,
          index: element.props.index,
          path: element.props.path,
          loader: element.props.loader,
          action: element.props.action,
          hydrateFallbackElement: element.props.hydrateFallbackElement,
          HydrateFallback: element.props.HydrateFallback,
          errorElement: element.props.errorElement,
          ErrorBoundary: element.props.ErrorBoundary,
          hasErrorBoundary: element.props.hasErrorBoundary === true || element.props.ErrorBoundary != null || element.props.errorElement != null,
          shouldRevalidate: element.props.shouldRevalidate,
          handle: element.props.handle,
          lazy: element.props.lazy
        };
        if (element.props.children) {
          route.children = createRoutesFromChildren(
            element.props.children,
            treePath
          );
        }
        routes.push(route);
      });
      return routes;
    }
    var defaultMethod = "get";
    var defaultEncType = "application/x-www-form-urlencoded";
    function isHtmlElement(object2) {
      return object2 != null && typeof object2.tagName === "string";
    }
    function isButtonElement(object2) {
      return isHtmlElement(object2) && object2.tagName.toLowerCase() === "button";
    }
    function isFormElement(object2) {
      return isHtmlElement(object2) && object2.tagName.toLowerCase() === "form";
    }
    function isInputElement(object2) {
      return isHtmlElement(object2) && object2.tagName.toLowerCase() === "input";
    }
    function isModifiedEvent(event) {
      return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
    }
    function shouldProcessLinkClick(event, target) {
      return event.button === 0 && // Ignore everything but left clicks
      (!target || target === "_self") && // Let browser handle "target=_blank" etc.
      !isModifiedEvent(event);
    }
    var _formDataSupportsSubmitter = null;
    function isFormDataSubmitterSupported() {
      if (_formDataSupportsSubmitter === null) {
        try {
          new FormData(
            document.createElement("form"),
            // @ts-expect-error if FormData supports the submitter parameter, this will throw
            0
          );
          _formDataSupportsSubmitter = false;
        } catch (e) {
          _formDataSupportsSubmitter = true;
        }
      }
      return _formDataSupportsSubmitter;
    }
    var supportedFormEncTypes = /* @__PURE__ */ new Set([
      "application/x-www-form-urlencoded",
      "multipart/form-data",
      "text/plain"
    ]);
    function getFormEncType(encType) {
      if (encType != null && !supportedFormEncTypes.has(encType)) {
        warning(
          false,
          `"${encType}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${defaultEncType}"`
        );
        return null;
      }
      return encType;
    }
    function getFormSubmissionInfo(target, basename) {
      let method;
      let action;
      let encType;
      let formData;
      let body;
      if (isFormElement(target)) {
        let attr = target.getAttribute("action");
        action = attr ? stripBasename(attr, basename) : null;
        method = target.getAttribute("method") || defaultMethod;
        encType = getFormEncType(target.getAttribute("enctype")) || defaultEncType;
        formData = new FormData(target);
      } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
        let form = target.form;
        if (form == null) {
          throw new Error(
            `Cannot submit a <button> or <input type="submit"> without a <form>`
          );
        }
        let attr = target.getAttribute("formaction") || form.getAttribute("action");
        action = attr ? stripBasename(attr, basename) : null;
        method = target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
        encType = getFormEncType(target.getAttribute("formenctype")) || getFormEncType(form.getAttribute("enctype")) || defaultEncType;
        formData = new FormData(form, target);
        if (!isFormDataSubmitterSupported()) {
          let { name, type, value } = target;
          if (type === "image") {
            let prefix = name ? `${name}.` : "";
            formData.append(`${prefix}x`, "0");
            formData.append(`${prefix}y`, "0");
          } else if (name) {
            formData.append(name, value);
          }
        }
      } else if (isHtmlElement(target)) {
        throw new Error(
          `Cannot submit element that is not <form>, <button>, or <input type="submit|image">`
        );
      } else {
        method = defaultMethod;
        action = null;
        encType = defaultEncType;
        body = target;
      }
      if (formData && encType === "text/plain") {
        body = formData;
        formData = void 0;
      }
      return { action, method: method.toLowerCase(), encType, formData, body };
    }
    Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
    function invariant2(value, message) {
      if (value === false || value === null || typeof value === "undefined") {
        throw new Error(message);
      }
    }
    function singleFetchUrl(reqUrl, basename, extension) {
      let url = typeof reqUrl === "string" ? new URL(
        reqUrl,
        // This can be called during the SSR flow via PrefetchPageLinksImpl so
        // don't assume window is available
        typeof window === "undefined" ? "server://singlefetch/" : window.location.origin
      ) : reqUrl;
      if (url.pathname === "/") {
        url.pathname = `_root.${extension}`;
      } else if (basename && stripBasename(url.pathname, basename) === "/") {
        url.pathname = `${basename.replace(/\/$/, "")}/_root.${extension}`;
      } else {
        url.pathname = `${url.pathname.replace(/\/$/, "")}.${extension}`;
      }
      return url;
    }
    async function loadRouteModule(route, routeModulesCache) {
      if (route.id in routeModulesCache) {
        return routeModulesCache[route.id];
      }
      try {
        let routeModule = await import(
          /* @vite-ignore */
          /* webpackIgnore: true */
          route.module
        );
        routeModulesCache[route.id] = routeModule;
        return routeModule;
      } catch (error) {
        console.error(
          `Error loading route module \`${route.module}\`, reloading page...`
        );
        console.error(error);
        if (window.__reactRouterContext && window.__reactRouterContext.isSpaMode && // @ts-expect-error
        void 0) ;
        window.location.reload();
        return new Promise(() => {
        });
      }
    }
    function isHtmlLinkDescriptor(object2) {
      if (object2 == null) {
        return false;
      }
      if (object2.href == null) {
        return object2.rel === "preload" && typeof object2.imageSrcSet === "string" && typeof object2.imageSizes === "string";
      }
      return typeof object2.rel === "string" && typeof object2.href === "string";
    }
    async function getKeyedPrefetchLinks(matches2, manifest, routeModules) {
      let links = await Promise.all(
        matches2.map(async (match) => {
          let route = manifest.routes[match.route.id];
          if (route) {
            let mod = await loadRouteModule(route, routeModules);
            return mod.links ? mod.links() : [];
          }
          return [];
        })
      );
      return dedupeLinkDescriptors(
        links.flat(1).filter(isHtmlLinkDescriptor).filter((link) => link.rel === "stylesheet" || link.rel === "preload").map(
          (link) => link.rel === "stylesheet" ? { ...link, rel: "prefetch", as: "style" } : { ...link, rel: "prefetch" }
        )
      );
    }
    function getNewMatchesForLinks(page, nextMatches, currentMatches, manifest, location, mode) {
      let isNew = (match, index) => {
        if (!currentMatches[index]) return true;
        return match.route.id !== currentMatches[index].route.id;
      };
      let matchPathChanged = (match, index) => {
        var _a;
        return (
          // param change, /users/123 -> /users/456
          currentMatches[index].pathname !== match.pathname || // splat param changed, which is not present in match.path
          // e.g. /files/images/avatar.jpg -> files/finances.xls
          ((_a = currentMatches[index].route.path) == null ? void 0 : _a.endsWith("*")) && currentMatches[index].params["*"] !== match.params["*"]
        );
      };
      if (mode === "assets") {
        return nextMatches.filter(
          (match, index) => isNew(match, index) || matchPathChanged(match, index)
        );
      }
      if (mode === "data") {
        return nextMatches.filter((match, index) => {
          var _a;
          let manifestRoute = manifest.routes[match.route.id];
          if (!manifestRoute || !manifestRoute.hasLoader) {
            return false;
          }
          if (isNew(match, index) || matchPathChanged(match, index)) {
            return true;
          }
          if (match.route.shouldRevalidate) {
            let routeChoice = match.route.shouldRevalidate({
              currentUrl: new URL(
                location.pathname + location.search + location.hash,
                window.origin
              ),
              currentParams: ((_a = currentMatches[0]) == null ? void 0 : _a.params) || {},
              nextUrl: new URL(page, window.origin),
              nextParams: match.params,
              defaultShouldRevalidate: true
            });
            if (typeof routeChoice === "boolean") {
              return routeChoice;
            }
          }
          return true;
        });
      }
      return [];
    }
    function getModuleLinkHrefs(matches2, manifest, { includeHydrateFallback } = {}) {
      return dedupeHrefs(
        matches2.map((match) => {
          let route = manifest.routes[match.route.id];
          if (!route) return [];
          let hrefs = [route.module];
          if (route.clientActionModule) {
            hrefs = hrefs.concat(route.clientActionModule);
          }
          if (route.clientLoaderModule) {
            hrefs = hrefs.concat(route.clientLoaderModule);
          }
          if (includeHydrateFallback && route.hydrateFallbackModule) {
            hrefs = hrefs.concat(route.hydrateFallbackModule);
          }
          if (route.imports) {
            hrefs = hrefs.concat(route.imports);
          }
          return hrefs;
        }).flat(1)
      );
    }
    function dedupeHrefs(hrefs) {
      return [...new Set(hrefs)];
    }
    function sortKeys(obj) {
      let sorted = {};
      let keys2 = Object.keys(obj).sort();
      for (let key of keys2) {
        sorted[key] = obj[key];
      }
      return sorted;
    }
    function dedupeLinkDescriptors(descriptors, preloads) {
      let set2 = /* @__PURE__ */ new Set();
      new Set(preloads);
      return descriptors.reduce((deduped, descriptor) => {
        let key = JSON.stringify(sortKeys(descriptor));
        if (!set2.has(key)) {
          set2.add(key);
          deduped.push({ key, link: descriptor });
        }
        return deduped;
      }, []);
    }
    function useDataRouterContext2() {
      let context = reactExports.useContext(DataRouterContext);
      invariant2(
        context,
        "You must render this element inside a <DataRouterContext.Provider> element"
      );
      return context;
    }
    function useDataRouterStateContext() {
      let context = reactExports.useContext(DataRouterStateContext);
      invariant2(
        context,
        "You must render this element inside a <DataRouterStateContext.Provider> element"
      );
      return context;
    }
    var FrameworkContext = reactExports.createContext(void 0);
    FrameworkContext.displayName = "FrameworkContext";
    function useFrameworkContext() {
      let context = reactExports.useContext(FrameworkContext);
      invariant2(
        context,
        "You must render this element inside a <HydratedRouter> element"
      );
      return context;
    }
    function usePrefetchBehavior(prefetch, theirElementProps) {
      let frameworkContext = reactExports.useContext(FrameworkContext);
      let [maybePrefetch, setMaybePrefetch] = reactExports.useState(false);
      let [shouldPrefetch, setShouldPrefetch] = reactExports.useState(false);
      let { onFocus: onFocus2, onBlur, onMouseEnter, onMouseLeave, onTouchStart } = theirElementProps;
      let ref = reactExports.useRef(null);
      reactExports.useEffect(() => {
        if (prefetch === "render") {
          setShouldPrefetch(true);
        }
        if (prefetch === "viewport") {
          let callback = (entries) => {
            entries.forEach((entry) => {
              setShouldPrefetch(entry.isIntersecting);
            });
          };
          let observer = new IntersectionObserver(callback, { threshold: 0.5 });
          if (ref.current) observer.observe(ref.current);
          return () => {
            observer.disconnect();
          };
        }
      }, [prefetch]);
      reactExports.useEffect(() => {
        if (maybePrefetch) {
          let id = setTimeout(() => {
            setShouldPrefetch(true);
          }, 100);
          return () => {
            clearTimeout(id);
          };
        }
      }, [maybePrefetch]);
      let setIntent = () => {
        setMaybePrefetch(true);
      };
      let cancelIntent = () => {
        setMaybePrefetch(false);
        setShouldPrefetch(false);
      };
      if (!frameworkContext) {
        return [false, ref, {}];
      }
      if (prefetch !== "intent") {
        return [shouldPrefetch, ref, {}];
      }
      return [
        shouldPrefetch,
        ref,
        {
          onFocus: composeEventHandlers(onFocus2, setIntent),
          onBlur: composeEventHandlers(onBlur, cancelIntent),
          onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),
          onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),
          onTouchStart: composeEventHandlers(onTouchStart, setIntent)
        }
      ];
    }
    function composeEventHandlers(theirHandler, ourHandler) {
      return (event) => {
        theirHandler && theirHandler(event);
        if (!event.defaultPrevented) {
          ourHandler(event);
        }
      };
    }
    function PrefetchPageLinks({ page, ...linkProps }) {
      let { router } = useDataRouterContext2();
      let matches2 = reactExports.useMemo(
        () => matchRoutes(router.routes, page, router.basename),
        [router.routes, page, router.basename]
      );
      if (!matches2) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(PrefetchPageLinksImpl, { page, matches: matches2, ...linkProps });
    }
    function useKeyedPrefetchLinks(matches2) {
      let { manifest, routeModules } = useFrameworkContext();
      let [keyedPrefetchLinks, setKeyedPrefetchLinks] = reactExports.useState([]);
      reactExports.useEffect(() => {
        let interrupted = false;
        void getKeyedPrefetchLinks(matches2, manifest, routeModules).then(
          (links) => {
            if (!interrupted) {
              setKeyedPrefetchLinks(links);
            }
          }
        );
        return () => {
          interrupted = true;
        };
      }, [matches2, manifest, routeModules]);
      return keyedPrefetchLinks;
    }
    function PrefetchPageLinksImpl({
      page,
      matches: nextMatches,
      ...linkProps
    }) {
      let location = useLocation();
      let { manifest, routeModules } = useFrameworkContext();
      let { basename } = useDataRouterContext2();
      let { loaderData, matches: matches2 } = useDataRouterStateContext();
      let newMatchesForData = reactExports.useMemo(
        () => getNewMatchesForLinks(
          page,
          nextMatches,
          matches2,
          manifest,
          location,
          "data"
        ),
        [page, nextMatches, matches2, manifest, location]
      );
      let newMatchesForAssets = reactExports.useMemo(
        () => getNewMatchesForLinks(
          page,
          nextMatches,
          matches2,
          manifest,
          location,
          "assets"
        ),
        [page, nextMatches, matches2, manifest, location]
      );
      let dataHrefs = reactExports.useMemo(() => {
        if (page === location.pathname + location.search + location.hash) {
          return [];
        }
        let routesParams = /* @__PURE__ */ new Set();
        let foundOptOutRoute = false;
        nextMatches.forEach((m) => {
          var _a;
          let manifestRoute = manifest.routes[m.route.id];
          if (!manifestRoute || !manifestRoute.hasLoader) {
            return;
          }
          if (!newMatchesForData.some((m2) => m2.route.id === m.route.id) && m.route.id in loaderData && ((_a = routeModules[m.route.id]) == null ? void 0 : _a.shouldRevalidate)) {
            foundOptOutRoute = true;
          } else if (manifestRoute.hasClientLoader) {
            foundOptOutRoute = true;
          } else {
            routesParams.add(m.route.id);
          }
        });
        if (routesParams.size === 0) {
          return [];
        }
        let url = singleFetchUrl(page, basename, "data");
        if (foundOptOutRoute && routesParams.size > 0) {
          url.searchParams.set(
            "_routes",
            nextMatches.filter((m) => routesParams.has(m.route.id)).map((m) => m.route.id).join(",")
          );
        }
        return [url.pathname + url.search];
      }, [
        basename,
        loaderData,
        location,
        manifest,
        newMatchesForData,
        nextMatches,
        page,
        routeModules
      ]);
      let moduleHrefs = reactExports.useMemo(
        () => getModuleLinkHrefs(newMatchesForAssets, manifest),
        [newMatchesForAssets, manifest]
      );
      let keyedPrefetchLinks = useKeyedPrefetchLinks(newMatchesForAssets);
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, dataHrefs.map((href) => /* @__PURE__ */ reactExports.createElement("link", { key: href, rel: "prefetch", as: "fetch", href, ...linkProps })), moduleHrefs.map((href) => /* @__PURE__ */ reactExports.createElement("link", { key: href, rel: "modulepreload", href, ...linkProps })), keyedPrefetchLinks.map(({ key, link }) => (
        // these don't spread `linkProps` because they are full link descriptors
        // already with their own props
        /* @__PURE__ */ reactExports.createElement("link", { key, ...link })
      )));
    }
    function mergeRefs(...refs) {
      return (value) => {
        refs.forEach((ref) => {
          if (typeof ref === "function") {
            ref(value);
          } else if (ref != null) {
            ref.current = value;
          }
        });
      };
    }
    var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
    try {
      if (isBrowser) {
        window.__reactRouterVersion = // @ts-expect-error
        "7.7.1";
      }
    } catch (e) {
    }
    function BrowserRouter({
      basename,
      children,
      window: window2
    }) {
      let historyRef = reactExports.useRef();
      if (historyRef.current == null) {
        historyRef.current = createBrowserHistory({ window: window2, v5Compat: true });
      }
      let history = historyRef.current;
      let [state, setStateImpl] = reactExports.useState({
        action: history.action,
        location: history.location
      });
      let setState = reactExports.useCallback(
        (newState) => {
          reactExports.startTransition(() => setStateImpl(newState));
        },
        [setStateImpl]
      );
      reactExports.useLayoutEffect(() => history.listen(setState), [history, setState]);
      return /* @__PURE__ */ reactExports.createElement(
        Router,
        {
          basename,
          children,
          location: state.location,
          navigationType: state.action,
          navigator: history
        }
      );
    }
    var ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
    var Link = reactExports.forwardRef(
      function LinkWithRef({
        onClick,
        discover = "render",
        prefetch = "none",
        relative,
        reloadDocument,
        replace: replace2,
        state,
        target,
        to,
        preventScrollReset,
        viewTransition,
        ...rest
      }, forwardedRef) {
        let { basename } = reactExports.useContext(NavigationContext);
        let isAbsolute = typeof to === "string" && ABSOLUTE_URL_REGEX2.test(to);
        let absoluteHref;
        let isExternal = false;
        if (typeof to === "string" && isAbsolute) {
          absoluteHref = to;
          if (isBrowser) {
            try {
              let currentUrl = new URL(window.location.href);
              let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
              let path = stripBasename(targetUrl.pathname, basename);
              if (targetUrl.origin === currentUrl.origin && path != null) {
                to = path + targetUrl.search + targetUrl.hash;
              } else {
                isExternal = true;
              }
            } catch (e) {
              warning(
                false,
                `<Link to="${to}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`
              );
            }
          }
        }
        let href = useHref(to, { relative });
        let [shouldPrefetch, prefetchRef, prefetchHandlers] = usePrefetchBehavior(
          prefetch,
          rest
        );
        let internalOnClick = useLinkClickHandler(to, {
          replace: replace2,
          state,
          target,
          preventScrollReset,
          relative,
          viewTransition
        });
        function handleClick(event) {
          if (onClick) onClick(event);
          if (!event.defaultPrevented) {
            internalOnClick(event);
          }
        }
        let link = (
          // eslint-disable-next-line jsx-a11y/anchor-has-content
          /* @__PURE__ */ reactExports.createElement(
            "a",
            {
              ...rest,
              ...prefetchHandlers,
              href: absoluteHref || href,
              onClick: isExternal || reloadDocument ? onClick : handleClick,
              ref: mergeRefs(forwardedRef, prefetchRef),
              target,
              "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
            }
          )
        );
        return shouldPrefetch && !isAbsolute ? /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, link, /* @__PURE__ */ reactExports.createElement(PrefetchPageLinks, { page: href })) : link;
      }
    );
    Link.displayName = "Link";
    var NavLink = reactExports.forwardRef(
      function NavLinkWithRef({
        "aria-current": ariaCurrentProp = "page",
        caseSensitive = false,
        className: classNameProp = "",
        end = false,
        style: styleProp,
        to,
        viewTransition,
        children,
        ...rest
      }, ref) {
        let path = useResolvedPath(to, { relative: rest.relative });
        let location = useLocation();
        let routerState = reactExports.useContext(DataRouterStateContext);
        let { navigator: navigator2, basename } = reactExports.useContext(NavigationContext);
        let isTransitioning = routerState != null && // Conditional usage is OK here because the usage of a data router is static
        // eslint-disable-next-line react-hooks/rules-of-hooks
        useViewTransitionState(path) && viewTransition === true;
        let toPathname = navigator2.encodeLocation ? navigator2.encodeLocation(path).pathname : path.pathname;
        let locationPathname = location.pathname;
        let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
        if (!caseSensitive) {
          locationPathname = locationPathname.toLowerCase();
          nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
          toPathname = toPathname.toLowerCase();
        }
        if (nextLocationPathname && basename) {
          nextLocationPathname = stripBasename(nextLocationPathname, basename) || nextLocationPathname;
        }
        const endSlashPosition = toPathname !== "/" && toPathname.endsWith("/") ? toPathname.length - 1 : toPathname.length;
        let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === "/";
        let isPending2 = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
        let renderProps = {
          isActive,
          isPending: isPending2,
          isTransitioning
        };
        let ariaCurrent = isActive ? ariaCurrentProp : void 0;
        let className;
        if (typeof classNameProp === "function") {
          className = classNameProp(renderProps);
        } else {
          className = [
            classNameProp,
            isActive ? "active" : null,
            isPending2 ? "pending" : null,
            isTransitioning ? "transitioning" : null
          ].filter(Boolean).join(" ");
        }
        let style = typeof styleProp === "function" ? styleProp(renderProps) : styleProp;
        return /* @__PURE__ */ reactExports.createElement(
          Link,
          {
            ...rest,
            "aria-current": ariaCurrent,
            className,
            ref,
            style,
            to,
            viewTransition
          },
          typeof children === "function" ? children(renderProps) : children
        );
      }
    );
    NavLink.displayName = "NavLink";
    var Form$1 = reactExports.forwardRef(
      ({
        discover = "render",
        fetcherKey,
        navigate,
        reloadDocument,
        replace: replace2,
        state,
        method = defaultMethod,
        action,
        onSubmit,
        relative,
        preventScrollReset,
        viewTransition,
        ...props
      }, forwardedRef) => {
        let submit = useSubmit();
        let formAction = useFormAction(action, { relative });
        let formMethod = method.toLowerCase() === "get" ? "get" : "post";
        let isAbsolute = typeof action === "string" && ABSOLUTE_URL_REGEX2.test(action);
        let submitHandler = (event) => {
          onSubmit && onSubmit(event);
          if (event.defaultPrevented) return;
          event.preventDefault();
          let submitter = event.nativeEvent.submitter;
          let submitMethod = (submitter == null ? void 0 : submitter.getAttribute("formmethod")) || method;
          submit(submitter || event.currentTarget, {
            fetcherKey,
            method: submitMethod,
            navigate,
            replace: replace2,
            state,
            relative,
            preventScrollReset,
            viewTransition
          });
        };
        return /* @__PURE__ */ reactExports.createElement(
          "form",
          {
            ref: forwardedRef,
            method: formMethod,
            action: formAction,
            onSubmit: reloadDocument ? onSubmit : submitHandler,
            ...props,
            "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
          }
        );
      }
    );
    Form$1.displayName = "Form";
    function getDataRouterConsoleError2(hookName) {
      return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
    }
    function useDataRouterContext3(hookName) {
      let ctx = reactExports.useContext(DataRouterContext);
      invariant(ctx, getDataRouterConsoleError2(hookName));
      return ctx;
    }
    function useLinkClickHandler(to, {
      target,
      replace: replaceProp,
      state,
      preventScrollReset,
      relative,
      viewTransition
    } = {}) {
      let navigate = useNavigate();
      let location = useLocation();
      let path = useResolvedPath(to, { relative });
      return reactExports.useCallback(
        (event) => {
          if (shouldProcessLinkClick(event, target)) {
            event.preventDefault();
            let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);
            navigate(to, {
              replace: replace2,
              state,
              preventScrollReset,
              relative,
              viewTransition
            });
          }
        },
        [
          location,
          navigate,
          path,
          replaceProp,
          state,
          target,
          to,
          preventScrollReset,
          relative,
          viewTransition
        ]
      );
    }
    var fetcherId = 0;
    var getUniqueFetcherId = () => `__${String(++fetcherId)}__`;
    function useSubmit() {
      let { router } = useDataRouterContext3(
        "useSubmit"
        /* UseSubmit */
      );
      let { basename } = reactExports.useContext(NavigationContext);
      let currentRouteId = useRouteId();
      return reactExports.useCallback(
        async (target, options = {}) => {
          let { action, method, encType, formData, body } = getFormSubmissionInfo(
            target,
            basename
          );
          if (options.navigate === false) {
            let key = options.fetcherKey || getUniqueFetcherId();
            await router.fetch(key, currentRouteId, options.action || action, {
              preventScrollReset: options.preventScrollReset,
              formData,
              body,
              formMethod: options.method || method,
              formEncType: options.encType || encType,
              flushSync: options.flushSync
            });
          } else {
            await router.navigate(options.action || action, {
              preventScrollReset: options.preventScrollReset,
              formData,
              body,
              formMethod: options.method || method,
              formEncType: options.encType || encType,
              replace: options.replace,
              state: options.state,
              fromRouteId: currentRouteId,
              flushSync: options.flushSync,
              viewTransition: options.viewTransition
            });
          }
        },
        [router, basename, currentRouteId]
      );
    }
    function useFormAction(action, { relative } = {}) {
      let { basename } = reactExports.useContext(NavigationContext);
      let routeContext = reactExports.useContext(RouteContext);
      invariant(routeContext, "useFormAction must be used inside a RouteContext");
      let [match] = routeContext.matches.slice(-1);
      let path = { ...useResolvedPath(action ? action : ".", { relative }) };
      let location = useLocation();
      if (action == null) {
        path.search = location.search;
        let params = new URLSearchParams(path.search);
        let indexValues = params.getAll("index");
        let hasNakedIndexParam = indexValues.some((v) => v === "");
        if (hasNakedIndexParam) {
          params.delete("index");
          indexValues.filter((v) => v).forEach((v) => params.append("index", v));
          let qs = params.toString();
          path.search = qs ? `?${qs}` : "";
        }
      }
      if ((!action || action === ".") && match.route.index) {
        path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
      }
      if (basename !== "/") {
        path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
      }
      return createPath(path);
    }
    function useViewTransitionState(to, { relative } = {}) {
      let vtContext = reactExports.useContext(ViewTransitionContext);
      invariant(
        vtContext != null,
        "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?"
      );
      let { basename } = useDataRouterContext3(
        "useViewTransitionState"
        /* useViewTransitionState */
      );
      let path = useResolvedPath(to, { relative });
      if (!vtContext.isTransitioning) {
        return false;
      }
      let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;
      let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;
      return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;
    }
    var reactDomExports = requireReactDom();
    const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
    const MobileNav = ({ isOpen, toggleMenu, handleNavClick }) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: `mobile-menu ${isOpen ? "active" : ""}`,
          onClick: toggleMenu,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mobile-menu-container", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: "logo", src: "./assets/images/roushan-logo.png", alt: "" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "span",
                {
                  className: "menu-item",
                  onClick: () => handleNavClick("home"),
                  children: "Home"
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "span",
                {
                  className: "menu-item",
                  onClick: () => handleNavClick("skills"),
                  children: "Skills"
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "span",
                {
                  className: "menu-item",
                  onClick: () => handleNavClick("work-experience"),
                  children: "Work Experience"
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { className: "menu-item", to: "/projects", children: "Projects" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "span",
                {
                  className: "menu-item",
                  onClick: () => handleNavClick("contact"),
                  children: "Contact Me"
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: "contact-btn",
                  onClick: () => {
                    const link = document.createElement("a");
                    link.href = "/assets/resume/RoushanBhadaniResume.pdf";
                    link.download = "Roushan_Resume.pdf";
                    link.click();
                  },
                  children: "Resume"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "contact-btn", onClick: () => {
                handleNavClick("contact");
              }, children: "Hire Me" })
            ] })
          ] })
        }
      );
    };
    var define_process_env_default = {};
    function _arrayWithHoles$5(r) {
      if (Array.isArray(r)) return r;
    }
    function _iterableToArrayLimit$5(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) ;
          else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _arrayLikeToArray$2$1(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function _unsupportedIterableToArray$2$1(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray$2$1(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$2$1(r, a) : void 0;
      }
    }
    function _nonIterableRest$5() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _slicedToArray$5(r, e) {
      return _arrayWithHoles$5(r) || _iterableToArrayLimit$5(r, e) || _unsupportedIterableToArray$2$1(r, e) || _nonIterableRest$5();
    }
    function _typeof$6(o) {
      "@babel/helpers - typeof";
      return _typeof$6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof$6(o);
    }
    function classNames() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (args) {
        var classes2 = [];
        for (var i = 0; i < args.length; i++) {
          var className = args[i];
          if (!className) {
            continue;
          }
          var type = _typeof$6(className);
          if (type === "string" || type === "number") {
            classes2.push(className);
          } else if (type === "object") {
            var _classes = Array.isArray(className) ? className : Object.entries(className).map(function(_ref) {
              var _ref2 = _slicedToArray$5(_ref, 2), key = _ref2[0], value = _ref2[1];
              return value ? key : null;
            });
            classes2 = _classes.length ? classes2.concat(_classes.filter(function(c) {
              return !!c;
            })) : classes2;
          }
        }
        return classes2.join(" ").trim();
      }
      return void 0;
    }
    function _arrayWithoutHoles$4(r) {
      if (Array.isArray(r)) return _arrayLikeToArray$2$1(r);
    }
    function _iterableToArray$4(r) {
      if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
    }
    function _nonIterableSpread$4() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _toConsumableArray$4(r) {
      return _arrayWithoutHoles$4(r) || _iterableToArray$4(r) || _unsupportedIterableToArray$2$1(r) || _nonIterableSpread$4();
    }
    function _classCallCheck$1(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function toPrimitive$6(t, r) {
      if ("object" != _typeof$6(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r);
        if ("object" != _typeof$6(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return String(t);
    }
    function toPropertyKey$6(t) {
      var i = toPrimitive$6(t, "string");
      return "symbol" == _typeof$6(i) ? i : i + "";
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, toPropertyKey$6(o.key), o);
      }
    }
    function _createClass$1(e, r, t) {
      return t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
        writable: false
      }), e;
    }
    function _defineProperty$6(e, r, t) {
      return (r = toPropertyKey$6(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
      }) : e[r] = t, e;
    }
    function _createForOfIteratorHelper$1(r, e) {
      var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (!t) {
        if (Array.isArray(r) || (t = _unsupportedIterableToArray$1$1(r)) || e) {
          t && (r = t);
          var _n = 0, F = function F2() {
          };
          return { s: F, n: function n() {
            return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
          }, e: function e2(r2) {
            throw r2;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var o, a = true, u = false;
      return { s: function s() {
        t = t.call(r);
      }, n: function n() {
        var r2 = t.next();
        return a = r2.done, r2;
      }, e: function e2(r2) {
        u = true, o = r2;
      }, f: function f() {
        try {
          a || null == t["return"] || t["return"]();
        } finally {
          if (u) throw o;
        }
      } };
    }
    function _unsupportedIterableToArray$1$1(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray$1$1(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$1$1(r, a) : void 0;
      }
    }
    function _arrayLikeToArray$1$1(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    var DomHandler = /* @__PURE__ */ function() {
      function DomHandler2() {
        _classCallCheck$1(this, DomHandler2);
      }
      return _createClass$1(DomHandler2, null, [{
        key: "innerWidth",
        value: function innerWidth(el) {
          if (el) {
            var width = el.offsetWidth;
            var style = getComputedStyle(el);
            width = width + (parseFloat(style.paddingLeft) + parseFloat(style.paddingRight));
            return width;
          }
          return 0;
        }
      }, {
        key: "width",
        value: function width(el) {
          if (el) {
            var _width = el.offsetWidth;
            var style = getComputedStyle(el);
            _width = _width - (parseFloat(style.paddingLeft) + parseFloat(style.paddingRight));
            return _width;
          }
          return 0;
        }
      }, {
        key: "getBrowserLanguage",
        value: function getBrowserLanguage() {
          return navigator.userLanguage || navigator.languages && navigator.languages.length && navigator.languages[0] || navigator.language || navigator.browserLanguage || navigator.systemLanguage || "en";
        }
      }, {
        key: "getWindowScrollTop",
        value: function getWindowScrollTop() {
          var doc = document.documentElement;
          return (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);
        }
      }, {
        key: "getWindowScrollLeft",
        value: function getWindowScrollLeft() {
          var doc = document.documentElement;
          return (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);
        }
      }, {
        key: "getOuterWidth",
        value: function getOuterWidth(el, margin) {
          if (el) {
            var width = el.getBoundingClientRect().width || el.offsetWidth;
            if (margin) {
              var style = getComputedStyle(el);
              width = width + (parseFloat(style.marginLeft) + parseFloat(style.marginRight));
            }
            return width;
          }
          return 0;
        }
      }, {
        key: "getOuterHeight",
        value: function getOuterHeight(el, margin) {
          if (el) {
            var height = el.getBoundingClientRect().height || el.offsetHeight;
            if (margin) {
              var style = getComputedStyle(el);
              height = height + (parseFloat(style.marginTop) + parseFloat(style.marginBottom));
            }
            return height;
          }
          return 0;
        }
      }, {
        key: "getClientHeight",
        value: function getClientHeight(el, margin) {
          if (el) {
            var height = el.clientHeight;
            if (margin) {
              var style = getComputedStyle(el);
              height = height + (parseFloat(style.marginTop) + parseFloat(style.marginBottom));
            }
            return height;
          }
          return 0;
        }
      }, {
        key: "getClientWidth",
        value: function getClientWidth(el, margin) {
          if (el) {
            var width = el.clientWidth;
            if (margin) {
              var style = getComputedStyle(el);
              width = width + (parseFloat(style.marginLeft) + parseFloat(style.marginRight));
            }
            return width;
          }
          return 0;
        }
      }, {
        key: "getViewport",
        value: function getViewport() {
          var win = window;
          var d = document;
          var e = d.documentElement;
          var g = d.getElementsByTagName("body")[0];
          var w = win.innerWidth || e.clientWidth || g.clientWidth;
          var h = win.innerHeight || e.clientHeight || g.clientHeight;
          return {
            width: w,
            height: h
          };
        }
      }, {
        key: "getOffset",
        value: function getOffset(el) {
          if (el) {
            var rect = el.getBoundingClientRect();
            return {
              top: rect.top + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0),
              left: rect.left + (window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0)
            };
          }
          return {
            top: "auto",
            left: "auto"
          };
        }
      }, {
        key: "index",
        value: function index(element) {
          if (element) {
            var children = element.parentNode.childNodes;
            var num = 0;
            for (var i = 0; i < children.length; i++) {
              if (children[i] === element) {
                return num;
              }
              if (children[i].nodeType === 1) {
                num++;
              }
            }
          }
          return -1;
        }
      }, {
        key: "addMultipleClasses",
        value: function addMultipleClasses(element, className) {
          if (element && className) {
            if (element.classList) {
              var styles2 = className.split(" ");
              for (var i = 0; i < styles2.length; i++) {
                element.classList.add(styles2[i]);
              }
            } else {
              var _styles = className.split(" ");
              for (var _i = 0; _i < _styles.length; _i++) {
                element.className = element.className + (" " + _styles[_i]);
              }
            }
          }
        }
      }, {
        key: "removeMultipleClasses",
        value: function removeMultipleClasses(element, className) {
          if (element && className) {
            if (element.classList) {
              var styles2 = className.split(" ");
              for (var i = 0; i < styles2.length; i++) {
                element.classList.remove(styles2[i]);
              }
            } else {
              var _styles2 = className.split(" ");
              for (var _i2 = 0; _i2 < _styles2.length; _i2++) {
                element.className = element.className.replace(new RegExp("(^|\\b)" + _styles2[_i2].split(" ").join("|") + "(\\b|$)", "gi"), " ");
              }
            }
          }
        }
      }, {
        key: "addClass",
        value: function addClass(element, className) {
          if (element && className) {
            if (element.classList) {
              element.classList.add(className);
            } else {
              element.className = element.className + (" " + className);
            }
          }
        }
      }, {
        key: "removeClass",
        value: function removeClass(element, className) {
          if (element && className) {
            if (element.classList) {
              element.classList.remove(className);
            } else {
              element.className = element.className.replace(new RegExp("(^|\\b)" + className.split(" ").join("|") + "(\\b|$)", "gi"), " ");
            }
          }
        }
      }, {
        key: "hasClass",
        value: function hasClass(element, className) {
          if (element) {
            if (element.classList) {
              return element.classList.contains(className);
            }
            return new RegExp("(^| )" + className + "( |$)", "gi").test(element.className);
          }
          return false;
        }
      }, {
        key: "addStyles",
        value: function addStyles(element) {
          var styles2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          if (element) {
            Object.entries(styles2).forEach(function(_ref) {
              var _ref2 = _slicedToArray$5(_ref, 2), key = _ref2[0], value = _ref2[1];
              return element.style[key] = value;
            });
          }
        }
      }, {
        key: "find",
        value: function find(element, selector) {
          return element ? Array.from(element.querySelectorAll(selector)) : [];
        }
      }, {
        key: "findSingle",
        value: function findSingle(element, selector) {
          if (element) {
            return element.querySelector(selector);
          }
          return null;
        }
      }, {
        key: "setAttributes",
        value: function setAttributes(element) {
          var _this = this;
          var attributes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          if (element) {
            var _computedStyles = function computedStyles(rule, value) {
              var _element$$attrs, _element$$attrs2;
              var styles2 = element !== null && element !== void 0 && (_element$$attrs = element.$attrs) !== null && _element$$attrs !== void 0 && _element$$attrs[rule] ? [element === null || element === void 0 || (_element$$attrs2 = element.$attrs) === null || _element$$attrs2 === void 0 ? void 0 : _element$$attrs2[rule]] : [];
              return [value].flat().reduce(function(cv, v) {
                if (v !== null && v !== void 0) {
                  var type = _typeof$6(v);
                  if (type === "string" || type === "number") {
                    cv.push(v);
                  } else if (type === "object") {
                    var _cv = Array.isArray(v) ? _computedStyles(rule, v) : Object.entries(v).map(function(_ref3) {
                      var _ref4 = _slicedToArray$5(_ref3, 2), _k = _ref4[0], _v = _ref4[1];
                      return rule === "style" && (!!_v || _v === 0) ? "".concat(_k.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), ":").concat(_v) : _v ? _k : void 0;
                    });
                    cv = _cv.length ? cv.concat(_cv.filter(function(c) {
                      return !!c;
                    })) : cv;
                  }
                }
                return cv;
              }, styles2);
            };
            Object.entries(attributes).forEach(function(_ref5) {
              var _ref6 = _slicedToArray$5(_ref5, 2), key = _ref6[0], value = _ref6[1];
              if (value !== void 0 && value !== null) {
                var matchedEvent = key.match(/^on(.+)/);
                if (matchedEvent) {
                  element.addEventListener(matchedEvent[1].toLowerCase(), value);
                } else if (key === "p-bind") {
                  _this.setAttributes(element, value);
                } else {
                  value = key === "class" ? _toConsumableArray$4(new Set(_computedStyles("class", value))).join(" ").trim() : key === "style" ? _computedStyles("style", value).join(";").trim() : value;
                  (element.$attrs = element.$attrs || {}) && (element.$attrs[key] = value);
                  element.setAttribute(key, value);
                }
              }
            });
          }
        }
      }, {
        key: "getAttribute",
        value: function getAttribute(element, name) {
          if (element) {
            var value = element.getAttribute(name);
            if (!isNaN(value)) {
              return +value;
            }
            if (value === "true" || value === "false") {
              return value === "true";
            }
            return value;
          }
          return void 0;
        }
      }, {
        key: "isAttributeEquals",
        value: function isAttributeEquals(element, name, value) {
          return element ? this.getAttribute(element, name) === value : false;
        }
      }, {
        key: "isAttributeNotEquals",
        value: function isAttributeNotEquals(element, name, value) {
          return !this.isAttributeEquals(element, name, value);
        }
      }, {
        key: "getHeight",
        value: function getHeight(el) {
          if (el) {
            var height = el.offsetHeight;
            var style = getComputedStyle(el);
            height = height - (parseFloat(style.paddingTop) + parseFloat(style.paddingBottom) + parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth));
            return height;
          }
          return 0;
        }
      }, {
        key: "getWidth",
        value: function getWidth(el) {
          if (el) {
            var width = el.offsetWidth;
            var style = getComputedStyle(el);
            width = width - (parseFloat(style.paddingLeft) + parseFloat(style.paddingRight) + parseFloat(style.borderLeftWidth) + parseFloat(style.borderRightWidth));
            return width;
          }
          return 0;
        }
      }, {
        key: "alignOverlay",
        value: function alignOverlay(overlay, target, appendTo) {
          var calculateMinWidth = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
          if (overlay && target) {
            if (appendTo === "self") {
              this.relativePosition(overlay, target);
            } else {
              calculateMinWidth && (overlay.style.minWidth = DomHandler2.getOuterWidth(target) + "px");
              this.absolutePosition(overlay, target);
            }
          }
        }
      }, {
        key: "absolutePosition",
        value: function absolutePosition(element, target) {
          var align = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "left";
          if (element && target) {
            var elementDimensions = element.offsetParent ? {
              width: element.offsetWidth,
              height: element.offsetHeight
            } : this.getHiddenElementDimensions(element);
            var elementOuterHeight = elementDimensions.height;
            var elementOuterWidth = elementDimensions.width;
            var targetOuterHeight = target.offsetHeight;
            var targetOuterWidth = target.offsetWidth;
            var targetOffset = target.getBoundingClientRect();
            var windowScrollTop = this.getWindowScrollTop();
            var windowScrollLeft = this.getWindowScrollLeft();
            var viewport = this.getViewport();
            var top;
            var left;
            if (targetOffset.top + targetOuterHeight + elementOuterHeight > viewport.height) {
              top = targetOffset.top + windowScrollTop - elementOuterHeight;
              if (top < 0) {
                top = windowScrollTop;
              }
              element.style.transformOrigin = "bottom";
            } else {
              top = targetOuterHeight + targetOffset.top + windowScrollTop;
              element.style.transformOrigin = "top";
            }
            var targetOffsetPx = targetOffset.left;
            if (align === "left") {
              if (targetOffsetPx + elementOuterWidth > viewport.width) {
                left = Math.max(0, targetOffsetPx + windowScrollLeft + targetOuterWidth - elementOuterWidth);
              } else {
                left = targetOffsetPx + windowScrollLeft;
              }
            } else {
              if (targetOffsetPx + targetOuterWidth - elementOuterWidth < 0) {
                left = windowScrollLeft;
              } else {
                left = targetOffsetPx + targetOuterWidth - elementOuterWidth + windowScrollLeft;
              }
            }
            element.style.top = top + "px";
            element.style.left = left + "px";
          }
        }
      }, {
        key: "relativePosition",
        value: function relativePosition(element, target) {
          if (element && target) {
            var elementDimensions = element.offsetParent ? {
              width: element.offsetWidth,
              height: element.offsetHeight
            } : this.getHiddenElementDimensions(element);
            var targetHeight = target.offsetHeight;
            var targetOffset = target.getBoundingClientRect();
            var viewport = this.getViewport();
            var top;
            var left;
            if (targetOffset.top + targetHeight + elementDimensions.height > viewport.height) {
              top = -1 * elementDimensions.height;
              if (targetOffset.top + top < 0) {
                top = -1 * targetOffset.top;
              }
              element.style.transformOrigin = "bottom";
            } else {
              top = targetHeight;
              element.style.transformOrigin = "top";
            }
            if (elementDimensions.width > viewport.width) {
              left = targetOffset.left * -1;
            } else if (targetOffset.left + elementDimensions.width > viewport.width) {
              left = (targetOffset.left + elementDimensions.width - viewport.width) * -1;
            } else {
              left = 0;
            }
            element.style.top = top + "px";
            element.style.left = left + "px";
          }
        }
      }, {
        key: "flipfitCollision",
        value: function flipfitCollision(element, target) {
          var _this2 = this;
          var my = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "left top";
          var at = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "left bottom";
          var callback = arguments.length > 4 ? arguments[4] : void 0;
          if (element && target) {
            var targetOffset = target.getBoundingClientRect();
            var viewport = this.getViewport();
            var myArr = my.split(" ");
            var atArr = at.split(" ");
            var getPositionValue = function getPositionValue2(arr, isOffset) {
              return isOffset ? +arr.substring(arr.search(/(\+|-)/g)) || 0 : arr.substring(0, arr.search(/(\+|-)/g)) || arr;
            };
            var position = {
              my: {
                x: getPositionValue(myArr[0]),
                y: getPositionValue(myArr[1] || myArr[0]),
                offsetX: getPositionValue(myArr[0], true),
                offsetY: getPositionValue(myArr[1] || myArr[0], true)
              },
              at: {
                x: getPositionValue(atArr[0]),
                y: getPositionValue(atArr[1] || atArr[0]),
                offsetX: getPositionValue(atArr[0], true),
                offsetY: getPositionValue(atArr[1] || atArr[0], true)
              }
            };
            var myOffset = {
              left: function left() {
                var totalOffset = position.my.offsetX + position.at.offsetX;
                return totalOffset + targetOffset.left + (position.my.x === "left" ? 0 : -1 * (position.my.x === "center" ? _this2.getOuterWidth(element) / 2 : _this2.getOuterWidth(element)));
              },
              top: function top() {
                var totalOffset = position.my.offsetY + position.at.offsetY;
                return totalOffset + targetOffset.top + (position.my.y === "top" ? 0 : -1 * (position.my.y === "center" ? _this2.getOuterHeight(element) / 2 : _this2.getOuterHeight(element)));
              }
            };
            var alignWithAt = {
              count: {
                x: 0,
                y: 0
              },
              left: function left() {
                var left2 = myOffset.left();
                var scrollLeft = DomHandler2.getWindowScrollLeft();
                element.style.left = left2 + scrollLeft + "px";
                if (this.count.x === 2) {
                  element.style.left = scrollLeft + "px";
                  this.count.x = 0;
                } else if (left2 < 0) {
                  this.count.x++;
                  position.my.x = "left";
                  position.at.x = "right";
                  position.my.offsetX *= -1;
                  position.at.offsetX *= -1;
                  this.right();
                }
              },
              right: function right() {
                var left = myOffset.left() + DomHandler2.getOuterWidth(target);
                var scrollLeft = DomHandler2.getWindowScrollLeft();
                element.style.left = left + scrollLeft + "px";
                if (this.count.x === 2) {
                  element.style.left = viewport.width - DomHandler2.getOuterWidth(element) + scrollLeft + "px";
                  this.count.x = 0;
                } else if (left + DomHandler2.getOuterWidth(element) > viewport.width) {
                  this.count.x++;
                  position.my.x = "right";
                  position.at.x = "left";
                  position.my.offsetX *= -1;
                  position.at.offsetX *= -1;
                  this.left();
                }
              },
              top: function top() {
                var top2 = myOffset.top();
                var scrollTop = DomHandler2.getWindowScrollTop();
                element.style.top = top2 + scrollTop + "px";
                if (this.count.y === 2) {
                  element.style.left = scrollTop + "px";
                  this.count.y = 0;
                } else if (top2 < 0) {
                  this.count.y++;
                  position.my.y = "top";
                  position.at.y = "bottom";
                  position.my.offsetY *= -1;
                  position.at.offsetY *= -1;
                  this.bottom();
                }
              },
              bottom: function bottom() {
                var top = myOffset.top() + DomHandler2.getOuterHeight(target);
                var scrollTop = DomHandler2.getWindowScrollTop();
                element.style.top = top + scrollTop + "px";
                if (this.count.y === 2) {
                  element.style.left = viewport.height - DomHandler2.getOuterHeight(element) + scrollTop + "px";
                  this.count.y = 0;
                } else if (top + DomHandler2.getOuterHeight(target) > viewport.height) {
                  this.count.y++;
                  position.my.y = "bottom";
                  position.at.y = "top";
                  position.my.offsetY *= -1;
                  position.at.offsetY *= -1;
                  this.top();
                }
              },
              center: function center(axis) {
                if (axis === "y") {
                  var top = myOffset.top() + DomHandler2.getOuterHeight(target) / 2;
                  element.style.top = top + DomHandler2.getWindowScrollTop() + "px";
                  if (top < 0) {
                    this.bottom();
                  } else if (top + DomHandler2.getOuterHeight(target) > viewport.height) {
                    this.top();
                  }
                } else {
                  var left = myOffset.left() + DomHandler2.getOuterWidth(target) / 2;
                  element.style.left = left + DomHandler2.getWindowScrollLeft() + "px";
                  if (left < 0) {
                    this.left();
                  } else if (left + DomHandler2.getOuterWidth(element) > viewport.width) {
                    this.right();
                  }
                }
              }
            };
            alignWithAt[position.at.x]("x");
            alignWithAt[position.at.y]("y");
            if (this.isFunction(callback)) {
              callback(position);
            }
          }
        }
      }, {
        key: "findCollisionPosition",
        value: function findCollisionPosition(position) {
          if (position) {
            var isAxisY = position === "top" || position === "bottom";
            var myXPosition = position === "left" ? "right" : "left";
            var myYPosition = position === "top" ? "bottom" : "top";
            if (isAxisY) {
              return {
                axis: "y",
                my: "center ".concat(myYPosition),
                at: "center ".concat(position)
              };
            }
            return {
              axis: "x",
              my: "".concat(myXPosition, " center"),
              at: "".concat(position, " center")
            };
          }
        }
      }, {
        key: "getParents",
        value: function getParents(element) {
          var parents = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
          return element.parentNode === null ? parents : this.getParents(element.parentNode, parents.concat([element.parentNode]));
        }
        /**
         * Gets all scrollable parent elements of a given element
         * @param {HTMLElement} element - The element to find scrollable parents for
         * @returns {Array} Array of scrollable parent elements
         */
      }, {
        key: "getScrollableParents",
        value: function getScrollableParents(element) {
          var _this3 = this;
          var scrollableParents = [];
          if (element) {
            var parents = this.getParents(element);
            var overflowRegex = /(auto|scroll)/;
            var overflowCheck = function overflowCheck2(node) {
              var styleDeclaration = node ? getComputedStyle(node) : null;
              return styleDeclaration && (overflowRegex.test(styleDeclaration.getPropertyValue("overflow")) || overflowRegex.test(styleDeclaration.getPropertyValue("overflow-x")) || overflowRegex.test(styleDeclaration.getPropertyValue("overflow-y")));
            };
            var addScrollableParent = function addScrollableParent2(node) {
              scrollableParents.push(node.nodeName === "BODY" || node.nodeName === "HTML" || _this3.isDocument(node) ? window : node);
            };
            var _iterator = _createForOfIteratorHelper$1(parents), _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                var _parent$dataset;
                var parent = _step.value;
                var scrollSelectors = parent.nodeType === 1 && ((_parent$dataset = parent.dataset) === null || _parent$dataset === void 0 ? void 0 : _parent$dataset.scrollselectors);
                if (scrollSelectors) {
                  var selectors = scrollSelectors.split(",");
                  var _iterator2 = _createForOfIteratorHelper$1(selectors), _step2;
                  try {
                    for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                      var selector = _step2.value;
                      var el = this.findSingle(parent, selector);
                      if (el && overflowCheck(el)) {
                        addScrollableParent(el);
                      }
                    }
                  } catch (err) {
                    _iterator2.e(err);
                  } finally {
                    _iterator2.f();
                  }
                }
                if (parent.nodeType === 1 && overflowCheck(parent)) {
                  addScrollableParent(parent);
                }
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
          }
          return scrollableParents;
        }
      }, {
        key: "getHiddenElementOuterHeight",
        value: function getHiddenElementOuterHeight(element) {
          if (element) {
            element.style.visibility = "hidden";
            element.style.display = "block";
            var elementHeight = element.offsetHeight;
            element.style.display = "none";
            element.style.visibility = "visible";
            return elementHeight;
          }
          return 0;
        }
      }, {
        key: "getHiddenElementOuterWidth",
        value: function getHiddenElementOuterWidth(element) {
          if (element) {
            element.style.visibility = "hidden";
            element.style.display = "block";
            var elementWidth = element.offsetWidth;
            element.style.display = "none";
            element.style.visibility = "visible";
            return elementWidth;
          }
          return 0;
        }
      }, {
        key: "getHiddenElementDimensions",
        value: function getHiddenElementDimensions(element) {
          var dimensions = {};
          if (element) {
            element.style.visibility = "hidden";
            element.style.display = "block";
            dimensions.width = element.offsetWidth;
            dimensions.height = element.offsetHeight;
            element.style.display = "none";
            element.style.visibility = "visible";
          }
          return dimensions;
        }
      }, {
        key: "fadeIn",
        value: function fadeIn(element, duration) {
          if (element) {
            element.style.opacity = 0;
            var last = +/* @__PURE__ */ new Date();
            var opacity = 0;
            var _tick = function tick() {
              opacity = +element.style.opacity + ((/* @__PURE__ */ new Date()).getTime() - last) / duration;
              element.style.opacity = opacity;
              last = +/* @__PURE__ */ new Date();
              if (+opacity < 1) {
                window.requestAnimationFrame && requestAnimationFrame(_tick) || setTimeout(_tick, 16);
              }
            };
            _tick();
          }
        }
      }, {
        key: "fadeOut",
        value: function fadeOut(element, duration) {
          if (element) {
            var opacity = 1;
            var interval = 50;
            var gap = interval / duration;
            var fading = setInterval(function() {
              opacity = opacity - gap;
              if (opacity <= 0) {
                opacity = 0;
                clearInterval(fading);
              }
              element.style.opacity = opacity;
            }, interval);
          }
        }
      }, {
        key: "getUserAgent",
        value: function getUserAgent() {
          return navigator.userAgent;
        }
      }, {
        key: "isIOS",
        value: function isIOS() {
          return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        }
      }, {
        key: "isAndroid",
        value: function isAndroid() {
          return /(android)/i.test(navigator.userAgent);
        }
      }, {
        key: "isChrome",
        value: function isChrome() {
          return /(chrome)/i.test(navigator.userAgent);
        }
      }, {
        key: "isClient",
        value: function isClient() {
          return !!(typeof window !== "undefined" && window.document && window.document.createElement);
        }
      }, {
        key: "isTouchDevice",
        value: function isTouchDevice() {
          return "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
        }
      }, {
        key: "isFunction",
        value: function isFunction2(obj) {
          return !!(obj && obj.constructor && obj.call && obj.apply);
        }
      }, {
        key: "appendChild",
        value: function appendChild(element, target) {
          if (this.isElement(target)) {
            target.appendChild(element);
          } else if (target.el && target.el.nativeElement) {
            target.el.nativeElement.appendChild(element);
          } else {
            throw new Error("Cannot append " + target + " to " + element);
          }
        }
      }, {
        key: "removeChild",
        value: function removeChild(element, target) {
          if (this.isElement(target)) {
            target.removeChild(element);
          } else if (target.el && target.el.nativeElement) {
            target.el.nativeElement.removeChild(element);
          } else {
            throw new Error("Cannot remove " + element + " from " + target);
          }
        }
      }, {
        key: "isElement",
        value: function isElement(obj) {
          return (typeof HTMLElement === "undefined" ? "undefined" : _typeof$6(HTMLElement)) === "object" ? obj instanceof HTMLElement : obj && _typeof$6(obj) === "object" && obj !== null && obj.nodeType === 1 && typeof obj.nodeName === "string";
        }
      }, {
        key: "isDocument",
        value: function isDocument(obj) {
          return (typeof Document === "undefined" ? "undefined" : _typeof$6(Document)) === "object" ? obj instanceof Document : obj && _typeof$6(obj) === "object" && obj !== null && obj.nodeType === 9;
        }
      }, {
        key: "scrollInView",
        value: function scrollInView(container, item) {
          var borderTopValue = getComputedStyle(container).getPropertyValue("border-top-width");
          var borderTop = borderTopValue ? parseFloat(borderTopValue) : 0;
          var paddingTopValue = getComputedStyle(container).getPropertyValue("padding-top");
          var paddingTop = paddingTopValue ? parseFloat(paddingTopValue) : 0;
          var containerRect = container.getBoundingClientRect();
          var itemRect = item.getBoundingClientRect();
          var offset = itemRect.top + document.body.scrollTop - (containerRect.top + document.body.scrollTop) - borderTop - paddingTop;
          var scroll = container.scrollTop;
          var elementHeight = container.clientHeight;
          var itemHeight = this.getOuterHeight(item);
          if (offset < 0) {
            container.scrollTop = scroll + offset;
          } else if (offset + itemHeight > elementHeight) {
            container.scrollTop = scroll + offset - elementHeight + itemHeight;
          }
        }
      }, {
        key: "clearSelection",
        value: function clearSelection() {
          if (window.getSelection) {
            if (window.getSelection().empty) {
              window.getSelection().empty();
            } else if (window.getSelection().removeAllRanges && window.getSelection().rangeCount > 0 && window.getSelection().getRangeAt(0).getClientRects().length > 0) {
              window.getSelection().removeAllRanges();
            }
          } else if (document.selection && document.selection.empty) {
            try {
              document.selection.empty();
            } catch (error) {
            }
          }
        }
      }, {
        key: "calculateScrollbarWidth",
        value: function calculateScrollbarWidth(el) {
          if (el) {
            var style = getComputedStyle(el);
            return el.offsetWidth - el.clientWidth - parseFloat(style.borderLeftWidth) - parseFloat(style.borderRightWidth);
          }
          if (this.calculatedScrollbarWidth != null) {
            return this.calculatedScrollbarWidth;
          }
          var scrollDiv = document.createElement("div");
          scrollDiv.className = "p-scrollbar-measure";
          document.body.appendChild(scrollDiv);
          var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
          document.body.removeChild(scrollDiv);
          this.calculatedScrollbarWidth = scrollbarWidth;
          return scrollbarWidth;
        }
      }, {
        key: "calculateBodyScrollbarWidth",
        value: function calculateBodyScrollbarWidth() {
          return window.innerWidth - document.documentElement.offsetWidth;
        }
      }, {
        key: "getBrowser",
        value: function getBrowser() {
          if (!this.browser) {
            var matched = this.resolveUserAgent();
            this.browser = {};
            if (matched.browser) {
              this.browser[matched.browser] = true;
              this.browser.version = matched.version;
            }
            if (this.browser.chrome) {
              this.browser.webkit = true;
            } else if (this.browser.webkit) {
              this.browser.safari = true;
            }
          }
          return this.browser;
        }
      }, {
        key: "resolveUserAgent",
        value: function resolveUserAgent() {
          var ua = navigator.userAgent.toLowerCase();
          var match = /(chrome)[ ]([\w.]+)/.exec(ua) || /(webkit)[ ]([\w.]+)/.exec(ua) || /(opera)(?:.*version|)[ ]([\w.]+)/.exec(ua) || /(msie) ([\w.]+)/.exec(ua) || ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) || [];
          return {
            browser: match[1] || "",
            version: match[2] || "0"
          };
        }
      }, {
        key: "blockBodyScroll",
        value: function blockBodyScroll() {
          var className = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "p-overflow-hidden";
          var hasScrollbarWidth = !!document.body.style.getPropertyValue("--scrollbar-width");
          !hasScrollbarWidth && document.body.style.setProperty("--scrollbar-width", this.calculateBodyScrollbarWidth() + "px");
          this.addClass(document.body, className);
        }
      }, {
        key: "unblockBodyScroll",
        value: function unblockBodyScroll() {
          var className = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "p-overflow-hidden";
          document.body.style.removeProperty("--scrollbar-width");
          this.removeClass(document.body, className);
        }
      }, {
        key: "isVisible",
        value: function isVisible(element) {
          return element && (element.clientHeight !== 0 || element.getClientRects().length !== 0 || getComputedStyle(element).display !== "none");
        }
      }, {
        key: "isExist",
        value: function isExist(element) {
          return !!(element !== null && typeof element !== "undefined" && element.nodeName && element.parentNode);
        }
      }, {
        key: "getFocusableElements",
        value: function getFocusableElements(element) {
          var selector = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
          var focusableElements = DomHandler2.find(element, 'button:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])'.concat(selector, ',\n                [href][clientHeight][clientWidth]:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])').concat(selector, ',\n                input:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])').concat(selector, ',\n                select:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])').concat(selector, ',\n                textarea:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])').concat(selector, ',\n                [tabIndex]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])').concat(selector, ',\n                [contenteditable]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])').concat(selector));
          var visibleFocusableElements = [];
          var _iterator3 = _createForOfIteratorHelper$1(focusableElements), _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
              var focusableElement = _step3.value;
              if (getComputedStyle(focusableElement).display !== "none" && getComputedStyle(focusableElement).visibility !== "hidden") {
                visibleFocusableElements.push(focusableElement);
              }
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
          return visibleFocusableElements;
        }
      }, {
        key: "getFirstFocusableElement",
        value: function getFirstFocusableElement(element, selector) {
          var focusableElements = DomHandler2.getFocusableElements(element, selector);
          return focusableElements.length > 0 ? focusableElements[0] : null;
        }
      }, {
        key: "getLastFocusableElement",
        value: function getLastFocusableElement(element, selector) {
          var focusableElements = DomHandler2.getFocusableElements(element, selector);
          return focusableElements.length > 0 ? focusableElements[focusableElements.length - 1] : null;
        }
        /**
         * Focus an input element if it does not already have focus.
         *
         * @param {HTMLElement} el a HTML element
         * @param {boolean} scrollTo flag to control whether to scroll to the element, false by default
         */
      }, {
        key: "focus",
        value: function focus(el, scrollTo) {
          var preventScroll = scrollTo === void 0 ? true : !scrollTo;
          el && document.activeElement !== el && el.focus({
            preventScroll
          });
        }
        /**
         * Focus the first focusable element if it does not already have focus.
         *
         * @param {HTMLElement} el a HTML element
         * @param {boolean} scrollTo flag to control whether to scroll to the element, false by default
         * @return {HTMLElement | undefined} the first focusable HTML element found
         */
      }, {
        key: "focusFirstElement",
        value: function focusFirstElement(el, scrollTo) {
          if (!el) {
            return;
          }
          var firstFocusableElement = DomHandler2.getFirstFocusableElement(el);
          firstFocusableElement && DomHandler2.focus(firstFocusableElement, scrollTo);
          return firstFocusableElement;
        }
      }, {
        key: "getCursorOffset",
        value: function getCursorOffset(el, prevText, nextText, currentText) {
          if (el) {
            var style = getComputedStyle(el);
            var ghostDiv = document.createElement("div");
            ghostDiv.style.position = "absolute";
            ghostDiv.style.top = "0px";
            ghostDiv.style.left = "0px";
            ghostDiv.style.visibility = "hidden";
            ghostDiv.style.pointerEvents = "none";
            ghostDiv.style.overflow = style.overflow;
            ghostDiv.style.width = style.width;
            ghostDiv.style.height = style.height;
            ghostDiv.style.padding = style.padding;
            ghostDiv.style.border = style.border;
            ghostDiv.style.overflowWrap = style.overflowWrap;
            ghostDiv.style.whiteSpace = style.whiteSpace;
            ghostDiv.style.lineHeight = style.lineHeight;
            ghostDiv.innerHTML = prevText.replace(/\r\n|\r|\n/g, "<br />");
            var ghostSpan = document.createElement("span");
            ghostSpan.textContent = currentText;
            ghostDiv.appendChild(ghostSpan);
            var text = document.createTextNode(nextText);
            ghostDiv.appendChild(text);
            document.body.appendChild(ghostDiv);
            var offsetLeft = ghostSpan.offsetLeft, offsetTop = ghostSpan.offsetTop, clientHeight = ghostSpan.clientHeight;
            document.body.removeChild(ghostDiv);
            return {
              left: Math.abs(offsetLeft - el.scrollLeft),
              top: Math.abs(offsetTop - el.scrollTop) + clientHeight
            };
          }
          return {
            top: "auto",
            left: "auto"
          };
        }
      }, {
        key: "invokeElementMethod",
        value: function invokeElementMethod(element, methodName, args) {
          element[methodName].apply(element, args);
        }
      }, {
        key: "isClickable",
        value: function isClickable(element) {
          var targetNode = element.nodeName;
          var parentNode = element.parentElement && element.parentElement.nodeName;
          return targetNode === "INPUT" || targetNode === "TEXTAREA" || targetNode === "BUTTON" || targetNode === "A" || parentNode === "INPUT" || parentNode === "TEXTAREA" || parentNode === "BUTTON" || parentNode === "A" || this.hasClass(element, "p-button") || this.hasClass(element.parentElement, "p-button") || this.hasClass(element.parentElement, "p-checkbox") || this.hasClass(element.parentElement, "p-radiobutton");
        }
      }, {
        key: "applyStyle",
        value: function applyStyle(element, style) {
          if (typeof style === "string") {
            element.style.cssText = style;
          } else {
            for (var prop in style) {
              element.style[prop] = style[prop];
            }
          }
        }
      }, {
        key: "exportCSV",
        value: function exportCSV(csv, filename) {
          var blob = new Blob([csv], {
            type: "application/csv;charset=utf-8;"
          });
          if (window.navigator.msSaveOrOpenBlob) {
            navigator.msSaveOrOpenBlob(blob, filename + ".csv");
          } else {
            var isDownloaded = DomHandler2.saveAs({
              name: filename + ".csv",
              src: URL.createObjectURL(blob)
            });
            if (!isDownloaded) {
              csv = "data:text/csv;charset=utf-8," + csv;
              window.open(encodeURI(csv));
            }
          }
        }
      }, {
        key: "saveAs",
        value: function saveAs(file) {
          if (file) {
            var link = document.createElement("a");
            if (link.download !== void 0) {
              var name = file.name, src = file.src;
              link.setAttribute("href", src);
              link.setAttribute("download", name);
              link.style.display = "none";
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
              return true;
            }
          }
          return false;
        }
      }, {
        key: "createInlineStyle",
        value: function createInlineStyle(nonce, styleContainer) {
          var styleElement = document.createElement("style");
          DomHandler2.addNonce(styleElement, nonce);
          if (!styleContainer) {
            styleContainer = document.head;
          }
          styleContainer.appendChild(styleElement);
          return styleElement;
        }
      }, {
        key: "removeInlineStyle",
        value: function removeInlineStyle(styleElement) {
          if (this.isExist(styleElement)) {
            try {
              styleElement.parentNode.removeChild(styleElement);
            } catch (error) {
            }
            styleElement = null;
          }
          return styleElement;
        }
      }, {
        key: "addNonce",
        value: function addNonce(styleElement, nonce) {
          try {
            if (!nonce) {
              nonce = define_process_env_default.REACT_APP_CSS_NONCE;
            }
          } catch (error) {
          }
          nonce && styleElement.setAttribute("nonce", nonce);
        }
      }, {
        key: "getTargetElement",
        value: function getTargetElement(target) {
          if (!target) {
            return null;
          }
          if (target === "document") {
            return document;
          } else if (target === "window") {
            return window;
          } else if (_typeof$6(target) === "object" && target.hasOwnProperty("current")) {
            return this.isExist(target.current) ? target.current : null;
          }
          var isFunction2 = function isFunction22(obj) {
            return !!(obj && obj.constructor && obj.call && obj.apply);
          };
          var element = isFunction2(target) ? target() : target;
          return this.isDocument(element) || this.isExist(element) ? element : null;
        }
        /**
         * Get the attribute names for an element and sorts them alpha for comparison
         */
      }, {
        key: "getAttributeNames",
        value: function getAttributeNames(node) {
          var index;
          var rv;
          var attrs;
          rv = [];
          attrs = node.attributes;
          for (index = 0; index < attrs.length; ++index) {
            rv.push(attrs[index].nodeName);
          }
          rv.sort();
          return rv;
        }
        /**
         * Compare two elements for equality.  Even will compare if the style element
         * is out of order for example:
         *
         * elem1 = style="color: red; font-size: 28px"
         * elem2 = style="font-size: 28px; color: red"
         */
      }, {
        key: "isEqualElement",
        value: function isEqualElement(elm1, elm2) {
          var attrs1;
          var attrs2;
          var name;
          var node1;
          var node2;
          attrs1 = DomHandler2.getAttributeNames(elm1);
          attrs2 = DomHandler2.getAttributeNames(elm2);
          if (attrs1.join(",") !== attrs2.join(",")) {
            return false;
          }
          for (var index = 0; index < attrs1.length; ++index) {
            name = attrs1[index];
            if (name === "style") {
              var astyle = elm1.style;
              var bstyle = elm2.style;
              var rexDigitsOnly = /^\d+$/;
              for (var _i3 = 0, _Object$keys = Object.keys(astyle); _i3 < _Object$keys.length; _i3++) {
                var key = _Object$keys[_i3];
                if (!rexDigitsOnly.test(key) && astyle[key] !== bstyle[key]) {
                  return false;
                }
              }
            } else if (elm1.getAttribute(name) !== elm2.getAttribute(name)) {
              return false;
            }
          }
          for (node1 = elm1.firstChild, node2 = elm2.firstChild; node1 && node2; node1 = node1.nextSibling, node2 = node2.nextSibling) {
            if (node1.nodeType !== node2.nodeType) {
              return false;
            }
            if (node1.nodeType === 1) {
              if (!DomHandler2.isEqualElement(node1, node2)) {
                return false;
              }
            } else if (node1.nodeValue !== node2.nodeValue) {
              return false;
            }
          }
          if (node1 || node2) {
            return false;
          }
          return true;
        }
      }, {
        key: "hasCSSAnimation",
        value: function hasCSSAnimation(element) {
          if (element) {
            var style = getComputedStyle(element);
            var animationDuration = parseFloat(style.getPropertyValue("animation-duration") || "0");
            return animationDuration > 0;
          }
          return false;
        }
      }, {
        key: "hasCSSTransition",
        value: function hasCSSTransition(element) {
          if (element) {
            var style = getComputedStyle(element);
            var transitionDuration = parseFloat(style.getPropertyValue("transition-duration") || "0");
            return transitionDuration > 0;
          }
          return false;
        }
      }]);
    }();
    _defineProperty$6(DomHandler, "DATA_PROPS", ["data-"]);
    _defineProperty$6(DomHandler, "ARIA_PROPS", ["aria", "focus-target"]);
    function _extends$a() {
      return _extends$a = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
          var t = arguments[e];
          for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
        }
        return n;
      }, _extends$a.apply(null, arguments);
    }
    function _createForOfIteratorHelper(r, e) {
      var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (!t) {
        if (Array.isArray(r) || (t = _unsupportedIterableToArray$6(r)) || e) {
          t && (r = t);
          var _n = 0, F = function F2() {
          };
          return { s: F, n: function n() {
            return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
          }, e: function e2(r2) {
            throw r2;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var o, a = true, u = false;
      return { s: function s() {
        t = t.call(r);
      }, n: function n() {
        var r2 = t.next();
        return a = r2.done, r2;
      }, e: function e2(r2) {
        u = true, o = r2;
      }, f: function f() {
        try {
          a || null == t["return"] || t["return"]();
        } finally {
          if (u) throw o;
        }
      } };
    }
    function _unsupportedIterableToArray$6(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray$6(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$6(r, a) : void 0;
      }
    }
    function _arrayLikeToArray$6(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    var ObjectUtils = /* @__PURE__ */ function() {
      function ObjectUtils2() {
        _classCallCheck$1(this, ObjectUtils2);
      }
      return _createClass$1(ObjectUtils2, null, [{
        key: "equals",
        value: function equals(obj1, obj2, field) {
          if (field && obj1 && _typeof$6(obj1) === "object" && obj2 && _typeof$6(obj2) === "object") {
            return this.deepEquals(this.resolveFieldData(obj1, field), this.resolveFieldData(obj2, field));
          }
          return this.deepEquals(obj1, obj2);
        }
        /**
         * Compares two JSON objects for deep equality recursively comparing both objects.
         * @param {*} a the first JSON object
         * @param {*} b the second JSON object
         * @returns true if equals, false it not
         */
      }, {
        key: "deepEquals",
        value: function deepEquals(a, b) {
          if (a === b) {
            return true;
          }
          if (a && b && _typeof$6(a) === "object" && _typeof$6(b) === "object") {
            var arrA = Array.isArray(a);
            var arrB = Array.isArray(b);
            var i;
            var length;
            var key;
            if (arrA && arrB) {
              length = a.length;
              if (length !== b.length) {
                return false;
              }
              for (i = length; i-- !== 0; ) {
                if (!this.deepEquals(a[i], b[i])) {
                  return false;
                }
              }
              return true;
            }
            if (arrA !== arrB) {
              return false;
            }
            var dateA = a instanceof Date;
            var dateB = b instanceof Date;
            if (dateA !== dateB) {
              return false;
            }
            if (dateA && dateB) {
              return a.getTime() === b.getTime();
            }
            var regexpA = a instanceof RegExp;
            var regexpB = b instanceof RegExp;
            if (regexpA !== regexpB) {
              return false;
            }
            if (regexpA && regexpB) {
              return a.toString() === b.toString();
            }
            var keys2 = Object.keys(a);
            length = keys2.length;
            if (length !== Object.keys(b).length) {
              return false;
            }
            for (i = length; i-- !== 0; ) {
              if (!Object.prototype.hasOwnProperty.call(b, keys2[i])) {
                return false;
              }
            }
            for (i = length; i-- !== 0; ) {
              key = keys2[i];
              if (!this.deepEquals(a[key], b[key])) {
                return false;
              }
            }
            return true;
          }
          return a !== a && b !== b;
        }
      }, {
        key: "resolveFieldData",
        value: function resolveFieldData(data, field) {
          if (!data || !field) {
            return null;
          }
          try {
            var value = data[field];
            if (this.isNotEmpty(value)) {
              return value;
            }
          } catch (_unused) {
          }
          if (Object.keys(data).length) {
            if (this.isFunction(field)) {
              return field(data);
            } else if (this.isNotEmpty(data[field])) {
              return data[field];
            } else if (field.indexOf(".") === -1) {
              return data[field];
            }
            var fields = field.split(".");
            var _value = data;
            for (var i = 0, len = fields.length; i < len; ++i) {
              if (_value == null) {
                return null;
              }
              _value = _value[fields[i]];
            }
            return _value;
          }
          return null;
        }
      }, {
        key: "findDiffKeys",
        value: function findDiffKeys(obj1, obj2) {
          if (!obj1 || !obj2) {
            return {};
          }
          return Object.keys(obj1).filter(function(key) {
            return !obj2.hasOwnProperty(key);
          }).reduce(function(result, current2) {
            result[current2] = obj1[current2];
            return result;
          }, {});
        }
        /**
         * Removes keys from a JSON object that start with a string such as "data" to get all "data-id" type properties.
         *
         * @param {any} obj the JSON object to reduce
         * @param {string[]} startsWiths the string(s) to check if the property starts with this key
         * @returns the JSON object containing only the key/values that match the startsWith string
         */
      }, {
        key: "reduceKeys",
        value: function reduceKeys(obj, startsWiths) {
          var result = {};
          if (!obj || !startsWiths || startsWiths.length === 0) {
            return result;
          }
          Object.keys(obj).filter(function(key) {
            return startsWiths.some(function(value) {
              return key.startsWith(value);
            });
          }).forEach(function(key) {
            result[key] = obj[key];
            delete obj[key];
          });
          return result;
        }
      }, {
        key: "reorderArray",
        value: function reorderArray(value, from, to) {
          if (value && from !== to) {
            if (to >= value.length) {
              to = to % value.length;
              from = from % value.length;
            }
            value.splice(to, 0, value.splice(from, 1)[0]);
          }
        }
      }, {
        key: "findIndexInList",
        value: function findIndexInList(value, list, dataKey) {
          var _this = this;
          if (list) {
            return dataKey ? list.findIndex(function(item) {
              return _this.equals(item, value, dataKey);
            }) : list.findIndex(function(item) {
              return item === value;
            });
          }
          return -1;
        }
      }, {
        key: "getJSXElement",
        value: function getJSXElement(obj) {
          for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            params[_key - 1] = arguments[_key];
          }
          return this.isFunction(obj) ? obj.apply(void 0, params) : obj;
        }
      }, {
        key: "getItemValue",
        value: function getItemValue(obj) {
          for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            params[_key2 - 1] = arguments[_key2];
          }
          return this.isFunction(obj) ? obj.apply(void 0, params) : obj;
        }
      }, {
        key: "getProp",
        value: function getProp(props) {
          var prop = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
          var defaultProps = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          var value = props ? props[prop] : void 0;
          return value === void 0 ? defaultProps[prop] : value;
        }
      }, {
        key: "getPropCaseInsensitive",
        value: function getPropCaseInsensitive(props, prop) {
          var defaultProps = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          var fkey = this.toFlatCase(prop);
          for (var key in props) {
            if (props.hasOwnProperty(key) && this.toFlatCase(key) === fkey) {
              return props[key];
            }
          }
          for (var _key3 in defaultProps) {
            if (defaultProps.hasOwnProperty(_key3) && this.toFlatCase(_key3) === fkey) {
              return defaultProps[_key3];
            }
          }
          return void 0;
        }
      }, {
        key: "getMergedProps",
        value: function getMergedProps(props, defaultProps) {
          return Object.assign({}, defaultProps, props);
        }
      }, {
        key: "getDiffProps",
        value: function getDiffProps(props, defaultProps) {
          return this.findDiffKeys(props, defaultProps);
        }
        /**
         * Gets the value of a property which can be a function or a direct value.
         * If the property is a function, it will be invoked with the provided parameters.
         * @param {*} obj - The object to get the value from
         * @param {...*} params - Parameters to pass to the function if obj is a function
         * @returns {*} The resolved value
         */
      }, {
        key: "getPropValue",
        value: function getPropValue(obj) {
          if (!this.isFunction(obj)) {
            return obj;
          }
          for (var _len3 = arguments.length, params = new Array(_len3 > 1 ? _len3 - 1 : 0), _key4 = 1; _key4 < _len3; _key4++) {
            params[_key4 - 1] = arguments[_key4];
          }
          if (params.length === 1) {
            var param = params[0];
            return obj(Array.isArray(param) ? param[0] : param);
          }
          return obj.apply(void 0, params);
        }
      }, {
        key: "getComponentProp",
        value: function getComponentProp(component) {
          var prop = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
          var defaultProps = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          return this.isNotEmpty(component) ? this.getProp(component.props, prop, defaultProps) : void 0;
        }
      }, {
        key: "getComponentProps",
        value: function getComponentProps(component, defaultProps) {
          return this.isNotEmpty(component) ? this.getMergedProps(component.props, defaultProps) : void 0;
        }
      }, {
        key: "getComponentDiffProps",
        value: function getComponentDiffProps(component, defaultProps) {
          return this.isNotEmpty(component) ? this.getDiffProps(component.props, defaultProps) : void 0;
        }
      }, {
        key: "isValidChild",
        value: function isValidChild(child, type, validTypes) {
          if (child) {
            var _child$type;
            var childType = this.getComponentProp(child, "__TYPE") || (child.type ? child.type.displayName : void 0);
            if (!childType && child !== null && child !== void 0 && (_child$type = child.type) !== null && _child$type !== void 0 && (_child$type = _child$type._payload) !== null && _child$type !== void 0 && _child$type.value) {
              childType = child.type._payload.value.find(function(v) {
                return v === type;
              });
            }
            var isValid = childType === type;
            try {
              var messageTypes;
              if (false) ;
            } catch (error) {
            }
            return isValid;
          }
          return false;
        }
      }, {
        key: "getRefElement",
        value: function getRefElement(ref) {
          if (ref) {
            return _typeof$6(ref) === "object" && ref.hasOwnProperty("current") ? ref.current : ref;
          }
          return null;
        }
      }, {
        key: "combinedRefs",
        value: function combinedRefs(innerRef, forwardRef) {
          if (innerRef && forwardRef) {
            if (typeof forwardRef === "function") {
              forwardRef(innerRef.current);
            } else {
              forwardRef.current = innerRef.current;
            }
          }
        }
      }, {
        key: "removeAccents",
        value: function removeAccents(str) {
          if (str && str.search(/[\xC0-\xFF]/g) > -1) {
            str = str.replace(/[\xC0-\xC5]/g, "A").replace(/[\xC6]/g, "AE").replace(/[\xC7]/g, "C").replace(/[\xC8-\xCB]/g, "E").replace(/[\xCC-\xCF]/g, "I").replace(/[\xD0]/g, "D").replace(/[\xD1]/g, "N").replace(/[\xD2-\xD6\xD8]/g, "O").replace(/[\xD9-\xDC]/g, "U").replace(/[\xDD]/g, "Y").replace(/[\xDE]/g, "P").replace(/[\xE0-\xE5]/g, "a").replace(/[\xE6]/g, "ae").replace(/[\xE7]/g, "c").replace(/[\xE8-\xEB]/g, "e").replace(/[\xEC-\xEF]/g, "i").replace(/[\xF1]/g, "n").replace(/[\xF2-\xF6\xF8]/g, "o").replace(/[\xF9-\xFC]/g, "u").replace(/[\xFE]/g, "p").replace(/[\xFD\xFF]/g, "y");
          }
          return str;
        }
      }, {
        key: "toFlatCase",
        value: function toFlatCase(str) {
          return this.isNotEmpty(str) && this.isString(str) ? str.replace(/(-|_)/g, "").toLowerCase() : str;
        }
      }, {
        key: "toCapitalCase",
        value: function toCapitalCase(str) {
          return this.isNotEmpty(str) && this.isString(str) ? str[0].toUpperCase() + str.slice(1) : str;
        }
      }, {
        key: "trim",
        value: function trim(value) {
          return this.isNotEmpty(value) && this.isString(value) ? value.trim() : value;
        }
      }, {
        key: "isEmpty",
        value: function isEmpty(value) {
          return value === null || value === void 0 || value === "" || Array.isArray(value) && value.length === 0 || !(value instanceof Date) && _typeof$6(value) === "object" && Object.keys(value).length === 0;
        }
      }, {
        key: "isNotEmpty",
        value: function isNotEmpty(value) {
          return !this.isEmpty(value);
        }
      }, {
        key: "isFunction",
        value: function isFunction2(value) {
          return !!(value && value.constructor && value.call && value.apply);
        }
      }, {
        key: "isObject",
        value: function isObject2(value) {
          return value !== null && value instanceof Object && value.constructor === Object;
        }
      }, {
        key: "isDate",
        value: function isDate2(value) {
          return value !== null && value instanceof Date && value.constructor === Date;
        }
      }, {
        key: "isArray",
        value: function isArray2(value) {
          return value !== null && Array.isArray(value);
        }
      }, {
        key: "isString",
        value: function isString2(value) {
          return value !== null && typeof value === "string";
        }
      }, {
        key: "isPrintableCharacter",
        value: function isPrintableCharacter() {
          var _char = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          return this.isNotEmpty(_char) && _char.length === 1 && _char.match(/\S| /);
        }
      }, {
        key: "isLetter",
        value: function isLetter(_char2) {
          return /^[a-zA-Z\u00C0-\u017F]$/.test(_char2);
        }
      }, {
        key: "isScalar",
        value: function isScalar(value) {
          return value != null && (typeof value === "string" || typeof value === "number" || typeof value === "bigint" || typeof value === "boolean");
        }
        /**
         * Firefox-v103 does not currently support the "findLast" method. It is stated that this method will be supported with Firefox-v104.
         * https://caniuse.com/mdn-javascript_builtins_array_findlast
         */
      }, {
        key: "findLast",
        value: function findLast(arr, callback) {
          var item;
          if (this.isNotEmpty(arr)) {
            try {
              item = arr.findLast(callback);
            } catch (_unused2) {
              item = _toConsumableArray$4(arr).reverse().find(callback);
            }
          }
          return item;
        }
        /**
         * Firefox-v103 does not currently support the "findLastIndex" method. It is stated that this method will be supported with Firefox-v104.
         * https://caniuse.com/mdn-javascript_builtins_array_findlastindex
         */
      }, {
        key: "findLastIndex",
        value: function findLastIndex(arr, callback) {
          var index = -1;
          if (this.isNotEmpty(arr)) {
            try {
              index = arr.findLastIndex(callback);
            } catch (_unused3) {
              index = arr.lastIndexOf(_toConsumableArray$4(arr).reverse().find(callback));
            }
          }
          return index;
        }
      }, {
        key: "sort",
        value: function sort(value1, value2) {
          var order = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          var comparator = arguments.length > 3 ? arguments[3] : void 0;
          var nullSortOrder = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1;
          var result = this.compare(value1, value2, comparator, order);
          var finalSortOrder = order;
          if (this.isEmpty(value1) || this.isEmpty(value2)) {
            finalSortOrder = nullSortOrder === 1 ? order : nullSortOrder;
          }
          return finalSortOrder * result;
        }
      }, {
        key: "compare",
        value: function compare(value1, value2, comparator) {
          var order = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
          var result = -1;
          var emptyValue1 = this.isEmpty(value1);
          var emptyValue2 = this.isEmpty(value2);
          if (emptyValue1 && emptyValue2) {
            result = 0;
          } else if (emptyValue1) {
            result = order;
          } else if (emptyValue2) {
            result = -order;
          } else if (typeof value1 === "string" && typeof value2 === "string") {
            result = comparator(value1, value2);
          } else {
            result = value1 < value2 ? -1 : value1 > value2 ? 1 : 0;
          }
          return result;
        }
      }, {
        key: "localeComparator",
        value: function localeComparator(locale2) {
          return new Intl.Collator(locale2, {
            numeric: true
          }).compare;
        }
      }, {
        key: "findChildrenByKey",
        value: function findChildrenByKey(data, key) {
          var _iterator = _createForOfIteratorHelper(data), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var item = _step.value;
              if (item.key === key) {
                return item.children || [];
              } else if (item.children) {
                var result = this.findChildrenByKey(item.children, key);
                if (result.length > 0) {
                  return result;
                }
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          return [];
        }
        /**
         * This function takes mutates and object with a new value given
         * a specific field. This will handle deeply nested fields that
         * need to be modified or created.
         *
         * e.g:
         * data = {
         *  nested: {
         *      foo: "bar"
         *  }
         * }
         *
         * field = "nested.foo"
         * value = "baz"
         *
         * The function will mutate data to be
         * e.g:
         * data = {
         *  nested: {
         *      foo: "baz"
         *  }
         * }
         *
         * @param {object} data the object to be modified
         * @param {string} field the field in the object to replace
         * @param {any} value the value to have replaced in the field
         */
      }, {
        key: "mutateFieldData",
        value: function mutateFieldData(data, field, value) {
          if (_typeof$6(data) !== "object" || typeof field !== "string") {
            return;
          }
          var fields = field.split(".");
          var obj = data;
          for (var i = 0, len = fields.length; i < len; ++i) {
            if (i + 1 - len === 0) {
              obj[fields[i]] = value;
              break;
            }
            if (!obj[fields[i]]) {
              obj[fields[i]] = {};
            }
            obj = obj[fields[i]];
          }
        }
        /**
         * This helper function takes an object and a dot-separated key path. It traverses the object based on the path,
         * returning the value at the specified depth. If any part of the path is missing or undefined, it returns undefined.
         *
         * Example:
         * const obj = { name: 'Alice', address: { city: 'Wonderland', zip: 12345 } };
         * const path = 'address.city';
         * const result = ObjectUtils.getNestedValue(obj, path);
         * console.log(result); // Output: "Wonderland"
         *
         * @param {object} obj - The object to traverse.
         * @param {string} path - The dot-separated key path.
         * @returns {*} The value at the specified depth, or undefined if any part of the path is missing or undefined.
         */
      }, {
        key: "getNestedValue",
        value: function getNestedValue(obj, path) {
          return path.split(".").reduce(function(acc, part) {
            return acc && acc[part] !== void 0 ? acc[part] : void 0;
          }, obj);
        }
        /**
         * This function takes an object and a dot-separated key path. It traverses the object based on the path,
         * returning the value at the specified depth. If any part of the path is missing or undefined, it returns undefined.
         *
         * Example:
         * const objA = { name: 'Alice', address: { city: 'Wonderland', zip: 12345 } };
         * const objB = { name: 'Alice', address: { city: 'Wonderland', zip: 12345 } };
         * const result = ObjectUtils.absoluteCompare(objA, objB);
         * console.log(result); // Output: true
         *
         * const objC = { name: 'Alice', address: { city: 'Wonderland', zip: 12346 } };
         * const result2 = ObjectUtils.absoluteCompare(objA, objC);
         * console.log(result2); // Output: false
         *
         * @param {object} objA - The first object to compare.
         * @param {object} objB - The second object to compare.
         * @param {number} [maxDepth=1] - The maximum depth to compare.
         * @param {number} [currentDepth=0] - The current depth (used internally for recursion).
         * @returns {boolean} True if the objects are equal within the specified depth, false otherwise.
         *
         */
      }, {
        key: "absoluteCompare",
        value: function absoluteCompare(objA, objB) {
          var maxDepth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          var currentDepth = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
          if (!objA || !objB) return true;
          if (currentDepth > maxDepth) return true;
          if (_typeof$6(objA) !== _typeof$6(objB)) return false;
          var aKeys = Object.keys(objA);
          var bKeys = Object.keys(objB);
          if (aKeys.length !== bKeys.length) return false;
          for (var _i = 0, _aKeys = aKeys; _i < _aKeys.length; _i++) {
            var key = _aKeys[_i];
            var aValue = objA[key];
            var bValue = objB[key];
            var isObject2 = ObjectUtils2.isObject(aValue) && ObjectUtils2.isObject(bValue);
            var isFunction2 = ObjectUtils2.isFunction(aValue) && ObjectUtils2.isFunction(bValue);
            if ((isObject2 || isFunction2) && !this.absoluteCompare(aValue, bValue, maxDepth, currentDepth + 1)) return false;
            if (!isObject2 && aValue !== bValue) return false;
          }
          return true;
        }
        /**
         * This helper function takes two objects and a list of keys to compare. It compares the values of the specified keys
         * in both objects. If any comparison fails, it returns false. If all specified properties are equal, it returns true.
         * It performs a shallow comparison using absoluteCompare if no keys are provided.
         *
         * Example:
         * const objA = { name: 'Alice', address: { city: 'Wonderland', zip: 12345 } };
         * const objB = { name: 'Alice', address: { city: 'Wonderland', zip: 12345 } };
         * const keysToCompare = ['name', 'address.city', 'address.zip'];
         * const result = ObjectUtils.selectiveCompare(objA, objB, keysToCompare);
         * console.log(result); // Output: true
         *
         * const objC = { name: 'Alice', address: { city: 'Wonderland', zip: 12346 } };
         * const result2 = ObjectUtils.selectiveCompare(objA, objC, keysToCompare);
         * console.log(result2); // Output: false
         *
         * @param {object} a - The first object to compare.
         * @param {object} b - The second object to compare.
         * @param {string[]} [keysToCompare] - The keys to compare. If not provided, performs a shallow comparison using absoluteCompare.
         * @param {number} [maxDepth=1] - The maximum depth to compare if the variables are objects.
         * @returns {boolean} True if all specified properties are equal, false otherwise.
         */
      }, {
        key: "selectiveCompare",
        value: function selectiveCompare(a, b, keysToCompare) {
          var maxDepth = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
          if (a === b) return true;
          if (!a || !b || _typeof$6(a) !== "object" || _typeof$6(b) !== "object") return false;
          if (!keysToCompare) return this.absoluteCompare(a, b, 1);
          var _iterator2 = _createForOfIteratorHelper(keysToCompare), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var key = _step2.value;
              var aValue = this.getNestedValue(a, key);
              var bValue = this.getNestedValue(b, key);
              var isObject2 = _typeof$6(aValue) === "object" && aValue !== null && _typeof$6(bValue) === "object" && bValue !== null;
              if (isObject2 && !this.absoluteCompare(aValue, bValue, maxDepth)) return false;
              if (!isObject2 && aValue !== bValue) return false;
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
          return true;
        }
      }]);
    }();
    var lastId = 0;
    function UniqueComponentId() {
      var prefix = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "pr_id_";
      lastId++;
      return "".concat(prefix).concat(lastId);
    }
    function ownKeys$2$1(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread$2$1(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys$2$1(Object(t), true).forEach(function(r2) {
          _defineProperty$6(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2$1(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    var IconUtils = /* @__PURE__ */ function() {
      function IconUtils2() {
        _classCallCheck$1(this, IconUtils2);
      }
      return _createClass$1(IconUtils2, null, [{
        key: "getJSXIcon",
        value: function getJSXIcon(icon) {
          var iconProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          var content = null;
          if (icon !== null) {
            var iconType = _typeof$6(icon);
            var className = classNames(iconProps.className, iconType === "string" && icon);
            content = /* @__PURE__ */ reactExports.createElement("span", _extends$a({}, iconProps, {
              className,
              key: UniqueComponentId("icon")
            }));
            if (iconType !== "string") {
              var defaultContentOptions = _objectSpread$2$1({
                iconProps,
                element: content
              }, options);
              return ObjectUtils.getJSXElement(icon, defaultContentOptions);
            }
          }
          return content;
        }
      }]);
    }();
    function ownKeys$6(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread$6(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys$6(Object(t), true).forEach(function(r2) {
          _defineProperty$6(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$6(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function mergeProps(props) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!props) {
        return void 0;
      }
      var isFunction2 = function isFunction22(obj) {
        return typeof obj === "function";
      };
      var classNameMergeFunction = options.classNameMergeFunction;
      var hasMergeFunction = isFunction2(classNameMergeFunction);
      return props.reduce(function(merged, ps) {
        if (!ps) {
          return merged;
        }
        var _loop = function _loop2() {
          var value = ps[key];
          if (key === "style") {
            merged.style = _objectSpread$6(_objectSpread$6({}, merged.style), ps.style);
          } else if (key === "className") {
            var newClassName = "";
            if (hasMergeFunction) {
              newClassName = classNameMergeFunction(merged.className, ps.className);
            } else {
              newClassName = [merged.className, ps.className].join(" ").trim();
            }
            merged.className = newClassName || void 0;
          } else if (isFunction2(value)) {
            var existingFn = merged[key];
            merged[key] = existingFn ? function() {
              existingFn.apply(void 0, arguments);
              value.apply(void 0, arguments);
            } : value;
          } else {
            merged[key] = value;
          }
        };
        for (var key in ps) {
          _loop();
        }
        return merged;
      }, {});
    }
    function handler() {
      var zIndexes = [];
      var generateZIndex = function generateZIndex2(key, autoZIndex) {
        var baseZIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 999;
        var lastZIndex = getLastZIndex(key, autoZIndex, baseZIndex);
        var newZIndex = lastZIndex.value + (lastZIndex.key === key ? 0 : baseZIndex) + 1;
        zIndexes.push({
          key,
          value: newZIndex
        });
        return newZIndex;
      };
      var revertZIndex = function revertZIndex2(zIndex) {
        zIndexes = zIndexes.filter(function(obj) {
          return obj.value !== zIndex;
        });
      };
      var getCurrentZIndex = function getCurrentZIndex2(key, autoZIndex) {
        return getLastZIndex(key, autoZIndex).value;
      };
      var getLastZIndex = function getLastZIndex2(key, autoZIndex) {
        var baseZIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        return _toConsumableArray$4(zIndexes).reverse().find(function(obj) {
          return autoZIndex ? true : obj.key === key;
        }) || {
          key,
          value: baseZIndex
        };
      };
      var getZIndex = function getZIndex2(el) {
        return el ? parseInt(el.style.zIndex, 10) || 0 : 0;
      };
      return {
        get: getZIndex,
        set: function set2(key, el, autoZIndex, baseZIndex) {
          if (el) {
            el.style.zIndex = String(generateZIndex(key, autoZIndex, baseZIndex));
          }
        },
        clear: function clear(el) {
          if (el) {
            revertZIndex(ZIndexUtils.get(el));
            el.style.zIndex = "";
          }
        },
        getCurrent: function getCurrent(key, autoZIndex) {
          return getCurrentZIndex(key, autoZIndex);
        }
      };
    }
    var ZIndexUtils = handler();
    var FilterMatchMode = Object.freeze({
      STARTS_WITH: "startsWith",
      CONTAINS: "contains",
      NOT_CONTAINS: "notContains",
      ENDS_WITH: "endsWith",
      EQUALS: "equals",
      NOT_EQUALS: "notEquals",
      IN: "in",
      NOT_IN: "notIn",
      LESS_THAN: "lt",
      LESS_THAN_OR_EQUAL_TO: "lte",
      GREATER_THAN: "gt",
      GREATER_THAN_OR_EQUAL_TO: "gte",
      BETWEEN: "between",
      DATE_IS: "dateIs",
      DATE_IS_NOT: "dateIsNot",
      DATE_BEFORE: "dateBefore",
      DATE_AFTER: "dateAfter",
      CUSTOM: "custom"
    });
    function _typeof$5(o) {
      "@babel/helpers - typeof";
      return _typeof$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof$5(o);
    }
    function toPrimitive$5(t, r) {
      if ("object" != _typeof$5(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r);
        if ("object" != _typeof$5(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function toPropertyKey$5(t) {
      var i = toPrimitive$5(t, "string");
      return "symbol" == _typeof$5(i) ? i : i + "";
    }
    function _defineProperty$5(e, r, t) {
      return (r = toPropertyKey$5(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
      }) : e[r] = t, e;
    }
    function _createClass(e, r, t) {
      return Object.defineProperty(e, "prototype", {
        writable: false
      }), e;
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    var PrimeReact$1 = /* @__PURE__ */ _createClass(function PrimeReact2() {
      _classCallCheck(this, PrimeReact2);
    });
    _defineProperty$5(PrimeReact$1, "ripple", false);
    _defineProperty$5(PrimeReact$1, "inputStyle", "outlined");
    _defineProperty$5(PrimeReact$1, "locale", "en");
    _defineProperty$5(PrimeReact$1, "appendTo", null);
    _defineProperty$5(PrimeReact$1, "cssTransition", true);
    _defineProperty$5(PrimeReact$1, "autoZIndex", true);
    _defineProperty$5(PrimeReact$1, "hideOverlaysOnDocumentScrolling", false);
    _defineProperty$5(PrimeReact$1, "nonce", null);
    _defineProperty$5(PrimeReact$1, "nullSortOrder", 1);
    _defineProperty$5(PrimeReact$1, "zIndex", {
      modal: 1100,
      overlay: 1e3,
      menu: 1e3,
      tooltip: 1100,
      toast: 1200
    });
    _defineProperty$5(PrimeReact$1, "pt", void 0);
    _defineProperty$5(PrimeReact$1, "filterMatchModeOptions", {
      text: [FilterMatchMode.STARTS_WITH, FilterMatchMode.CONTAINS, FilterMatchMode.NOT_CONTAINS, FilterMatchMode.ENDS_WITH, FilterMatchMode.EQUALS, FilterMatchMode.NOT_EQUALS],
      numeric: [FilterMatchMode.EQUALS, FilterMatchMode.NOT_EQUALS, FilterMatchMode.LESS_THAN, FilterMatchMode.LESS_THAN_OR_EQUAL_TO, FilterMatchMode.GREATER_THAN, FilterMatchMode.GREATER_THAN_OR_EQUAL_TO],
      date: [FilterMatchMode.DATE_IS, FilterMatchMode.DATE_IS_NOT, FilterMatchMode.DATE_BEFORE, FilterMatchMode.DATE_AFTER]
    });
    _defineProperty$5(PrimeReact$1, "changeTheme", function(currentTheme, newTheme, linkElementId, callback) {
      var _linkElement$parentNo;
      var linkElement = document.getElementById(linkElementId);
      if (!linkElement) {
        throw Error("Element with id ".concat(linkElementId, " not found."));
      }
      var newThemeUrl = linkElement.getAttribute("href").replace(currentTheme, newTheme);
      var newLinkElement = document.createElement("link");
      newLinkElement.setAttribute("rel", "stylesheet");
      newLinkElement.setAttribute("id", linkElementId);
      newLinkElement.setAttribute("href", newThemeUrl);
      newLinkElement.addEventListener("load", function() {
        if (callback) {
          callback();
        }
      });
      (_linkElement$parentNo = linkElement.parentNode) === null || _linkElement$parentNo === void 0 || _linkElement$parentNo.replaceChild(newLinkElement, linkElement);
    });
    var locales = {
      en: {
        accept: "Yes",
        addRule: "Add Rule",
        am: "AM",
        apply: "Apply",
        cancel: "Cancel",
        choose: "Choose",
        chooseDate: "Choose Date",
        chooseMonth: "Choose Month",
        chooseYear: "Choose Year",
        clear: "Clear",
        completed: "Completed",
        contains: "Contains",
        custom: "Custom",
        dateAfter: "Date is after",
        dateBefore: "Date is before",
        dateFormat: "mm/dd/yy",
        dateIs: "Date is",
        dateIsNot: "Date is not",
        dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
        dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        emptyFilterMessage: "No results found",
        emptyMessage: "No available options",
        emptySearchMessage: "No results found",
        emptySelectionMessage: "No selected item",
        endsWith: "Ends with",
        equals: "Equals",
        fileChosenMessage: "{0} files",
        fileSizeTypes: ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"],
        filter: "Filter",
        firstDayOfWeek: 0,
        gt: "Greater than",
        gte: "Greater than or equal to",
        lt: "Less than",
        lte: "Less than or equal to",
        matchAll: "Match All",
        matchAny: "Match Any",
        medium: "Medium",
        monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
        nextDecade: "Next Decade",
        nextHour: "Next Hour",
        nextMinute: "Next Minute",
        nextMonth: "Next Month",
        nextSecond: "Next Second",
        nextYear: "Next Year",
        noFileChosenMessage: "No file chosen",
        noFilter: "No Filter",
        notContains: "Not contains",
        notEquals: "Not equals",
        now: "Now",
        passwordPrompt: "Enter a password",
        pending: "Pending",
        pm: "PM",
        prevDecade: "Previous Decade",
        prevHour: "Previous Hour",
        prevMinute: "Previous Minute",
        prevMonth: "Previous Month",
        prevSecond: "Previous Second",
        prevYear: "Previous Year",
        reject: "No",
        removeRule: "Remove Rule",
        searchMessage: "{0} results are available",
        selectionMessage: "{0} items selected",
        showMonthAfterYear: false,
        startsWith: "Starts with",
        strong: "Strong",
        today: "Today",
        upload: "Upload",
        weak: "Weak",
        weekHeader: "Wk",
        aria: {
          cancelEdit: "Cancel Edit",
          close: "Close",
          collapseLabel: "Collapse",
          collapseRow: "Row Collapsed",
          editRow: "Edit Row",
          expandLabel: "Expand",
          expandRow: "Row Expanded",
          falseLabel: "False",
          filterConstraint: "Filter Constraint",
          filterOperator: "Filter Operator",
          firstPageLabel: "First Page",
          gridView: "Grid View",
          hideFilterMenu: "Hide Filter Menu",
          jumpToPageDropdownLabel: "Jump to Page Dropdown",
          jumpToPageInputLabel: "Jump to Page Input",
          lastPageLabel: "Last Page",
          listLabel: "Option List",
          listView: "List View",
          moveAllToSource: "Move All to Source",
          moveAllToTarget: "Move All to Target",
          moveBottom: "Move Bottom",
          moveDown: "Move Down",
          moveToSource: "Move to Source",
          moveToTarget: "Move to Target",
          moveTop: "Move Top",
          moveUp: "Move Up",
          navigation: "Navigation",
          next: "Next",
          nextPageLabel: "Next Page",
          nullLabel: "Not Selected",
          otpLabel: "Please enter one time password character {0}",
          pageLabel: "Page {page}",
          passwordHide: "Hide Password",
          passwordShow: "Show Password",
          previous: "Previous",
          prevPageLabel: "Previous Page",
          removeLabel: "Remove",
          rotateLeft: "Rotate Left",
          rotateRight: "Rotate Right",
          rowsPerPageLabel: "Rows per page",
          saveEdit: "Save Edit",
          scrollTop: "Scroll Top",
          selectAll: "All items selected",
          selectLabel: "Select",
          selectRow: "Row Selected",
          showFilterMenu: "Show Filter Menu",
          slide: "Slide",
          slideNumber: "{slideNumber}",
          star: "1 star",
          stars: "{star} stars",
          trueLabel: "True",
          unselectAll: "All items unselected",
          unselectLabel: "Unselect",
          unselectRow: "Row Unselected",
          zoomImage: "Zoom Image",
          zoomIn: "Zoom In",
          zoomOut: "Zoom Out"
        }
      }
    };
    function localeOption(key, locale2) {
      if (key.includes("__proto__") || key.includes("prototype")) {
        throw new Error("Unsafe key detected");
      }
      var _locale = PrimeReact$1.locale;
      try {
        return localeOptions(_locale)[key];
      } catch (error) {
        throw new Error("The ".concat(key, " option is not found in the current locale('").concat(_locale, "')."));
      }
    }
    function ariaLabel(ariaKey, options) {
      if (ariaKey.includes("__proto__") || ariaKey.includes("prototype")) {
        throw new Error("Unsafe ariaKey detected");
      }
      var _locale = PrimeReact$1.locale;
      try {
        var _ariaLabel = localeOptions(_locale).aria[ariaKey];
        if (_ariaLabel) {
          for (var key in options) {
            if (options.hasOwnProperty(key)) {
              _ariaLabel = _ariaLabel.replace("{".concat(key, "}"), options[key]);
            }
          }
        }
        return _ariaLabel;
      } catch (error) {
        throw new Error("The ".concat(ariaKey, " option is not found in the current locale('").concat(_locale, "')."));
      }
    }
    function localeOptions(locale2) {
      var _locale = locale2 || PrimeReact$1.locale;
      if (_locale.includes("__proto__") || _locale.includes("prototype")) {
        throw new Error("Unsafe locale detected");
      }
      return locales[_locale];
    }
    var PrimeReactContext = /* @__PURE__ */ React.createContext();
    var PrimeReact = PrimeReact$1;
    function _arrayWithHoles$4(r) {
      if (Array.isArray(r)) return r;
    }
    function _iterableToArrayLimit$4(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _arrayLikeToArray$5(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function _unsupportedIterableToArray$5(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray$5(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$5(r, a) : void 0;
      }
    }
    function _nonIterableRest$4() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _slicedToArray$4(r, e) {
      return _arrayWithHoles$4(r) || _iterableToArrayLimit$4(r, e) || _unsupportedIterableToArray$5(r, e) || _nonIterableRest$4();
    }
    var usePrevious = function usePrevious2(newValue) {
      var ref = reactExports.useRef(null);
      reactExports.useEffect(function() {
        ref.current = newValue;
        return function() {
          ref.current = null;
        };
      }, [newValue]);
      return ref.current;
    };
    var useUnmountEffect = function useUnmountEffect2(fn) {
      return reactExports.useEffect(function() {
        return fn;
      }, []);
    };
    var useEventListener = function useEventListener2(_ref) {
      var _ref$target = _ref.target, target = _ref$target === void 0 ? "document" : _ref$target, type = _ref.type, listener = _ref.listener, options = _ref.options, _ref$when = _ref.when, when = _ref$when === void 0 ? true : _ref$when;
      var targetRef = reactExports.useRef(null);
      var listenerRef = reactExports.useRef(null);
      var prevListener = usePrevious(listener);
      var prevOptions = usePrevious(options);
      var bind = function bind2() {
        var bindOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var bindTarget = bindOptions.target;
        if (ObjectUtils.isNotEmpty(bindTarget)) {
          unbind();
          (bindOptions.when || when) && (targetRef.current = DomHandler.getTargetElement(bindTarget));
        }
        if (!listenerRef.current && targetRef.current) {
          listenerRef.current = function(event) {
            return listener && listener(event);
          };
          targetRef.current.addEventListener(type, listenerRef.current, options);
        }
      };
      var unbind = function unbind2() {
        if (listenerRef.current) {
          targetRef.current.removeEventListener(type, listenerRef.current, options);
          listenerRef.current = null;
        }
      };
      var dispose = function dispose2() {
        unbind();
        prevListener = null;
        prevOptions = null;
      };
      var updateTarget = reactExports.useCallback(function() {
        if (when) {
          targetRef.current = DomHandler.getTargetElement(target);
        } else {
          unbind();
          targetRef.current = null;
        }
      }, [target, when]);
      reactExports.useEffect(function() {
        updateTarget();
      }, [updateTarget]);
      reactExports.useEffect(function() {
        var listenerChanged = "".concat(prevListener) !== "".concat(listener);
        var optionsChanged = prevOptions !== options;
        var listenerExists = listenerRef.current;
        if (listenerExists && (listenerChanged || optionsChanged)) {
          unbind();
          when && bind();
        } else if (!listenerExists) {
          dispose();
        }
      }, [listener, options, when]);
      useUnmountEffect(function() {
        dispose();
      });
      return [bind, unbind];
    };
    var groupToDisplayedElements = {};
    var useDisplayOrder = function useDisplayOrder2(group) {
      var isVisible = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var _React$useState = reactExports.useState(function() {
        return UniqueComponentId();
      }), _React$useState2 = _slicedToArray$4(_React$useState, 1), uid = _React$useState2[0];
      var _React$useState3 = reactExports.useState(0), _React$useState4 = _slicedToArray$4(_React$useState3, 2), displayOrder = _React$useState4[0], setDisplayOrder = _React$useState4[1];
      reactExports.useEffect(function() {
        if (isVisible) {
          if (!groupToDisplayedElements[group]) {
            groupToDisplayedElements[group] = [];
          }
          var newDisplayOrder = groupToDisplayedElements[group].push(uid);
          setDisplayOrder(newDisplayOrder);
          return function() {
            delete groupToDisplayedElements[group][newDisplayOrder - 1];
            var lastIndex = groupToDisplayedElements[group].length - 1;
            var lastOrder = ObjectUtils.findLastIndex(groupToDisplayedElements[group], function(el) {
              return el !== void 0;
            });
            if (lastOrder !== lastIndex) {
              groupToDisplayedElements[group].splice(lastOrder + 1);
            }
            setDisplayOrder(void 0);
          };
        }
      }, [group, uid, isVisible]);
      return displayOrder;
    };
    function _arrayWithoutHoles$3(r) {
      if (Array.isArray(r)) return _arrayLikeToArray$5(r);
    }
    function _iterableToArray$3(r) {
      if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
    }
    function _nonIterableSpread$3() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _toConsumableArray$3(r) {
      return _arrayWithoutHoles$3(r) || _iterableToArray$3(r) || _unsupportedIterableToArray$5(r) || _nonIterableSpread$3();
    }
    var ESC_KEY_HANDLING_PRIORITIES = {
      TOOLTIP: 1200
    };
    var globalEscKeyHandlingLogic = {
      /**
       * Mapping from ESC_KEY_HANDLING_PRIORITY to array of related listeners, grouped by priority
       * @example
       * Map<{
       *     [ESC_KEY_HANDLING_PRIORITIES.SIDEBAR]: Map<{
       *         1: () => {...},
       *         2: () => {...}
       *     }>,
       *     [ESC_KEY_HANDLING_PRIORITIES.DIALOG]: Map<{
       *         1: () => {...},
       *         2: () => {...}
       *     }>
       * }>;
       */
      escKeyListeners: /* @__PURE__ */ new Map(),
      /**
       * Keydown handler (attached to any keydown)
       */
      onGlobalKeyDown: function onGlobalKeyDown(event) {
        if (event.code !== "Escape") {
          return;
        }
        var escKeyListeners = globalEscKeyHandlingLogic.escKeyListeners;
        var maxPrimaryPriority = Math.max.apply(Math, _toConsumableArray$3(escKeyListeners.keys()));
        var theMostImportantEscHandlersSet = escKeyListeners.get(maxPrimaryPriority);
        var maxSecondaryPriority = Math.max.apply(Math, _toConsumableArray$3(theMostImportantEscHandlersSet.keys()));
        var theMostImportantEscHandler = theMostImportantEscHandlersSet.get(maxSecondaryPriority);
        theMostImportantEscHandler(event);
      },
      /**
       * Attach global keydown listener if there are any "esc" key handlers assigned,
       * otherwise detach.
       */
      refreshGlobalKeyDownListener: function refreshGlobalKeyDownListener() {
        var document2 = DomHandler.getTargetElement("document");
        if (this.escKeyListeners.size > 0) {
          document2.addEventListener("keydown", this.onGlobalKeyDown);
        } else {
          document2.removeEventListener("keydown", this.onGlobalKeyDown);
        }
      },
      /**
       * Add "Esc" key handler
       */
      addListener: function addListener(callback, _ref) {
        var _this = this;
        var _ref2 = _slicedToArray$4(_ref, 2), primaryPriority = _ref2[0], secondaryPriority = _ref2[1];
        var escKeyListeners = this.escKeyListeners;
        if (!escKeyListeners.has(primaryPriority)) {
          escKeyListeners.set(primaryPriority, /* @__PURE__ */ new Map());
        }
        var primaryPriorityListeners = escKeyListeners.get(primaryPriority);
        if (primaryPriorityListeners.has(secondaryPriority)) {
          throw new Error("Unexpected: global esc key listener with priority [".concat(primaryPriority, ", ").concat(secondaryPriority, "] already exists."));
        }
        primaryPriorityListeners.set(secondaryPriority, callback);
        this.refreshGlobalKeyDownListener();
        return function() {
          primaryPriorityListeners["delete"](secondaryPriority);
          if (primaryPriorityListeners.size === 0) {
            escKeyListeners["delete"](primaryPriority);
          }
          _this.refreshGlobalKeyDownListener();
        };
      }
    };
    var useGlobalOnEscapeKey = function useGlobalOnEscapeKey2(_ref3) {
      var callback = _ref3.callback, when = _ref3.when, priority = _ref3.priority;
      reactExports.useEffect(function() {
        if (!when) {
          return;
        }
        return globalEscKeyHandlingLogic.addListener(callback, priority);
      }, [callback, when, priority]);
    };
    var useMergeProps = function useMergeProps2() {
      var context = reactExports.useContext(PrimeReactContext);
      return function() {
        for (var _len = arguments.length, props = new Array(_len), _key = 0; _key < _len; _key++) {
          props[_key] = arguments[_key];
        }
        return mergeProps(props, context === null || context === void 0 ? void 0 : context.ptOptions);
      };
    };
    var useMountEffect = function useMountEffect2(fn) {
      var mounted = reactExports.useRef(false);
      return reactExports.useEffect(function() {
        if (!mounted.current) {
          mounted.current = true;
          return fn && fn();
        }
      }, []);
    };
    var useOverlayScrollListener = function useOverlayScrollListener2(_ref) {
      var target = _ref.target, listener = _ref.listener, options = _ref.options, _ref$when = _ref.when, when = _ref$when === void 0 ? true : _ref$when;
      var context = reactExports.useContext(PrimeReactContext);
      var targetRef = reactExports.useRef(null);
      var listenerRef = reactExports.useRef(null);
      var scrollableParentsRef = reactExports.useRef([]);
      var prevListener = usePrevious(listener);
      var prevOptions = usePrevious(options);
      var bind = function bind2() {
        var bindOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (ObjectUtils.isNotEmpty(bindOptions.target)) {
          unbind();
          (bindOptions.when || when) && (targetRef.current = DomHandler.getTargetElement(bindOptions.target));
        }
        if (!listenerRef.current && targetRef.current) {
          var hideOnScroll = context ? context.hideOverlaysOnDocumentScrolling : PrimeReact.hideOverlaysOnDocumentScrolling;
          var nodes = scrollableParentsRef.current = DomHandler.getScrollableParents(targetRef.current);
          if (!nodes.some(function(node) {
            return node === document.body || node === window;
          })) {
            nodes.push(hideOnScroll ? window : document.body);
          }
          listenerRef.current = function(event) {
            return listener && listener(event);
          };
          nodes.forEach(function(node) {
            return node.addEventListener("scroll", listenerRef.current, options);
          });
        }
      };
      var unbind = function unbind2() {
        if (listenerRef.current) {
          var nodes = scrollableParentsRef.current;
          nodes.forEach(function(node) {
            return node.removeEventListener("scroll", listenerRef.current, options);
          });
          listenerRef.current = null;
        }
      };
      var dispose = function dispose2() {
        unbind();
        scrollableParentsRef.current = null;
        prevListener = null;
        prevOptions = null;
      };
      var updateTarget = reactExports.useCallback(function() {
        if (when) {
          targetRef.current = DomHandler.getTargetElement(target);
        } else {
          unbind();
          targetRef.current = null;
        }
      }, [target, when]);
      reactExports.useEffect(function() {
        updateTarget();
      }, [updateTarget]);
      reactExports.useEffect(function() {
        var listenerChanged = "".concat(prevListener) !== "".concat(listener);
        var optionsChanged = prevOptions !== options;
        var listenerExists = listenerRef.current;
        if (listenerExists && (listenerChanged || optionsChanged)) {
          unbind();
          when && bind();
        } else if (!listenerExists) {
          dispose();
        }
      }, [listener, options, when]);
      useUnmountEffect(function() {
        dispose();
      });
      return [bind, unbind];
    };
    var useResizeListener = function useResizeListener2(_ref) {
      var listener = _ref.listener, _ref$when = _ref.when, when = _ref$when === void 0 ? true : _ref$when;
      return useEventListener({
        target: "window",
        type: "resize",
        listener,
        when
      });
    };
    var _id = 0;
    var useStyle = function useStyle2(css) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var _useState = reactExports.useState(false), _useState2 = _slicedToArray$4(_useState, 2), isLoaded = _useState2[0], setIsLoaded = _useState2[1];
      var styleRef = reactExports.useRef(null);
      var context = reactExports.useContext(PrimeReactContext);
      var defaultDocument = DomHandler.isClient() ? window.document : void 0;
      var _options$document = options.document, document2 = _options$document === void 0 ? defaultDocument : _options$document, _options$manual = options.manual, manual = _options$manual === void 0 ? false : _options$manual, _options$name = options.name, name = _options$name === void 0 ? "style_".concat(++_id) : _options$name, _options$id = options.id, id = _options$id === void 0 ? void 0 : _options$id, _options$media = options.media, media = _options$media === void 0 ? void 0 : _options$media;
      var getCurrentStyleRef = function getCurrentStyleRef2(styleContainer) {
        var existingStyle = styleContainer.querySelector('style[data-primereact-style-id="'.concat(name, '"]'));
        if (existingStyle) {
          return existingStyle;
        }
        if (id !== void 0) {
          var existingElement = document2.getElementById(id);
          if (existingElement) {
            return existingElement;
          }
        }
        return document2.createElement("style");
      };
      var update = function update2(newCSS) {
        isLoaded && css !== newCSS && (styleRef.current.textContent = newCSS);
      };
      var load = function load2() {
        if (!document2 || isLoaded) {
          return;
        }
        var styleContainer = (context === null || context === void 0 ? void 0 : context.styleContainer) || document2.head;
        styleRef.current = getCurrentStyleRef(styleContainer);
        if (!styleRef.current.isConnected) {
          styleRef.current.type = "text/css";
          if (id) {
            styleRef.current.id = id;
          }
          if (media) {
            styleRef.current.media = media;
          }
          DomHandler.addNonce(styleRef.current, context && context.nonce || PrimeReact.nonce);
          styleContainer.appendChild(styleRef.current);
          if (name) {
            styleRef.current.setAttribute("data-primereact-style-id", name);
          }
        }
        styleRef.current.textContent = css;
        setIsLoaded(true);
      };
      var unload = function unload2() {
        if (!document2 || !styleRef.current) {
          return;
        }
        DomHandler.removeInlineStyle(styleRef.current);
        setIsLoaded(false);
      };
      reactExports.useEffect(function() {
        if (!manual) {
          load();
        }
      }, [manual]);
      return {
        id,
        name,
        update,
        unload,
        load,
        isLoaded
      };
    };
    var useUpdateEffect = function useUpdateEffect2(fn, deps) {
      var mounted = reactExports.useRef(false);
      return reactExports.useEffect(function() {
        if (!mounted.current) {
          mounted.current = true;
          return;
        }
        return fn && fn();
      }, deps);
    };
    function _arrayLikeToArray$4(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function _arrayWithoutHoles$2(r) {
      if (Array.isArray(r)) return _arrayLikeToArray$4(r);
    }
    function _iterableToArray$2(r) {
      if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
    }
    function _unsupportedIterableToArray$4(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray$4(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$4(r, a) : void 0;
      }
    }
    function _nonIterableSpread$2() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _toConsumableArray$2(r) {
      return _arrayWithoutHoles$2(r) || _iterableToArray$2(r) || _unsupportedIterableToArray$4(r) || _nonIterableSpread$2();
    }
    function _typeof$4(o) {
      "@babel/helpers - typeof";
      return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof$4(o);
    }
    function toPrimitive$4(t, r) {
      if ("object" != _typeof$4(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r);
        if ("object" != _typeof$4(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function toPropertyKey$4(t) {
      var i = toPrimitive$4(t, "string");
      return "symbol" == _typeof$4(i) ? i : i + "";
    }
    function _defineProperty$4(e, r, t) {
      return (r = toPropertyKey$4(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
      }) : e[r] = t, e;
    }
    function ownKeys$5(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread$5(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys$5(Object(t), true).forEach(function(r2) {
          _defineProperty$4(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$5(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    var baseStyle = "\n.p-hidden-accessible {\n    border: 0;\n    clip: rect(0 0 0 0);\n    height: 1px;\n    margin: -1px;\n    opacity: 0;\n    overflow: hidden;\n    padding: 0;\n    pointer-events: none;\n    position: absolute;\n    white-space: nowrap;\n    width: 1px;\n}\n\n.p-overflow-hidden {\n    overflow: hidden;\n    padding-right: var(--scrollbar-width);\n}\n";
    var buttonStyles = "\n.p-button {\n    margin: 0;\n    display: inline-flex;\n    cursor: pointer;\n    user-select: none;\n    align-items: center;\n    vertical-align: bottom;\n    text-align: center;\n    overflow: hidden;\n    position: relative;\n}\n\n.p-button-label {\n    flex: 1 1 auto;\n}\n\n.p-button-icon-right {\n    order: 1;\n}\n\n.p-button:disabled {\n    cursor: default;\n}\n\n.p-button-icon-only {\n    justify-content: center;\n}\n\n.p-button-icon-only .p-button-label {\n    visibility: hidden;\n    width: 0;\n    flex: 0 0 auto;\n}\n\n.p-button-vertical {\n    flex-direction: column;\n}\n\n.p-button-icon-bottom {\n    order: 2;\n}\n\n.p-button-group .p-button {\n    margin: 0;\n}\n\n.p-button-group .p-button:not(:last-child) {\n    border-right: 0 none;\n}\n\n.p-button-group .p-button:not(:first-of-type):not(:last-of-type) {\n    border-radius: 0;\n}\n\n.p-button-group .p-button:first-of-type {\n    border-top-right-radius: 0;\n    border-bottom-right-radius: 0;\n}\n\n.p-button-group .p-button:last-of-type {\n    border-top-left-radius: 0;\n    border-bottom-left-radius: 0;\n}\n\n.p-button-group .p-button:focus {\n    position: relative;\n    z-index: 1;\n}\n\n.p-button-group-single .p-button:first-of-type {\n    border-top-right-radius: var(--border-radius) !important;\n    border-bottom-right-radius: var(--border-radius) !important;\n}\n\n.p-button-group-single .p-button:last-of-type {\n    border-top-left-radius: var(--border-radius) !important;\n    border-bottom-left-radius: var(--border-radius) !important;\n}\n";
    var inputTextStyles = "\n.p-inputtext {\n    margin: 0;\n}\n\n.p-fluid .p-inputtext {\n    width: 100%;\n}\n\n/* InputGroup */\n.p-inputgroup {\n    display: flex;\n    align-items: stretch;\n    width: 100%;\n}\n\n.p-inputgroup-addon {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.p-inputgroup .p-float-label {\n    display: flex;\n    align-items: stretch;\n    width: 100%;\n}\n\n.p-inputgroup .p-inputtext,\n.p-fluid .p-inputgroup .p-inputtext,\n.p-inputgroup .p-inputwrapper,\n.p-fluid .p-inputgroup .p-input {\n    flex: 1 1 auto;\n    width: 1%;\n}\n\n/* Floating Label */\n.p-float-label {\n    display: block;\n    position: relative;\n}\n\n.p-float-label label {\n    position: absolute;\n    pointer-events: none;\n    top: 50%;\n    margin-top: -0.5rem;\n    transition-property: all;\n    transition-timing-function: ease;\n    line-height: 1;\n}\n\n.p-float-label textarea ~ label,\n.p-float-label .p-mention ~ label {\n    top: 1rem;\n}\n\n.p-float-label input:focus ~ label,\n.p-float-label input:-webkit-autofill ~ label,\n.p-float-label input.p-filled ~ label,\n.p-float-label textarea:focus ~ label,\n.p-float-label textarea.p-filled ~ label,\n.p-float-label .p-inputwrapper-focus ~ label,\n.p-float-label .p-inputwrapper-filled ~ label,\n.p-float-label .p-tooltip-target-wrapper ~ label {\n    top: -0.75rem;\n    font-size: 12px;\n}\n\n.p-float-label .p-placeholder,\n.p-float-label input::placeholder,\n.p-float-label .p-inputtext::placeholder {\n    opacity: 0;\n    transition-property: all;\n    transition-timing-function: ease;\n}\n\n.p-float-label .p-focus .p-placeholder,\n.p-float-label input:focus::placeholder,\n.p-float-label .p-inputtext:focus::placeholder {\n    opacity: 1;\n    transition-property: all;\n    transition-timing-function: ease;\n}\n\n.p-input-icon-left,\n.p-input-icon-right {\n    position: relative;\n    display: inline-block;\n}\n\n.p-input-icon-left > i,\n.p-input-icon-right > i,\n.p-input-icon-left > svg,\n.p-input-icon-right > svg,\n.p-input-icon-left > .p-input-prefix,\n.p-input-icon-right > .p-input-suffix {\n    position: absolute;\n    top: 50%;\n    margin-top: -0.5rem;\n}\n\n.p-fluid .p-input-icon-left,\n.p-fluid .p-input-icon-right {\n    display: block;\n    width: 100%;\n}\n";
    var iconStyles = "\n.p-icon {\n    display: inline-block;\n}\n\n.p-icon-spin {\n    -webkit-animation: p-icon-spin 2s infinite linear;\n    animation: p-icon-spin 2s infinite linear;\n}\n\nsvg.p-icon {\n    pointer-events: auto;\n}\n\nsvg.p-icon g,\n.p-disabled svg.p-icon {\n    pointer-events: none;\n}\n\n@-webkit-keyframes p-icon-spin {\n    0% {\n        -webkit-transform: rotate(0deg);\n        transform: rotate(0deg);\n    }\n    100% {\n        -webkit-transform: rotate(359deg);\n        transform: rotate(359deg);\n    }\n}\n\n@keyframes p-icon-spin {\n    0% {\n        -webkit-transform: rotate(0deg);\n        transform: rotate(0deg);\n    }\n    100% {\n        -webkit-transform: rotate(359deg);\n        transform: rotate(359deg);\n    }\n}\n";
    var commonStyle = "\n@layer primereact {\n    .p-component, .p-component * {\n        box-sizing: border-box;\n    }\n\n    .p-hidden {\n        display: none;\n    }\n\n    .p-hidden-space {\n        visibility: hidden;\n    }\n\n    .p-reset {\n        margin: 0;\n        padding: 0;\n        border: 0;\n        outline: 0;\n        text-decoration: none;\n        font-size: 100%;\n        list-style: none;\n    }\n\n    .p-disabled, .p-disabled * {\n        cursor: default;\n        pointer-events: none;\n        user-select: none;\n    }\n\n    .p-component-overlay {\n        position: fixed;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n    }\n\n    .p-unselectable-text {\n        user-select: none;\n    }\n\n    .p-scrollbar-measure {\n        width: 100px;\n        height: 100px;\n        overflow: scroll;\n        position: absolute;\n        top: -9999px;\n    }\n\n    @-webkit-keyframes p-fadein {\n      0%   { opacity: 0; }\n      100% { opacity: 1; }\n    }\n    @keyframes p-fadein {\n      0%   { opacity: 0; }\n      100% { opacity: 1; }\n    }\n\n    .p-link {\n        text-align: left;\n        background-color: transparent;\n        margin: 0;\n        padding: 0;\n        border: none;\n        cursor: pointer;\n        user-select: none;\n    }\n\n    .p-link:disabled {\n        cursor: default;\n    }\n\n    /* Non react overlay animations */\n    .p-connected-overlay {\n        opacity: 0;\n        transform: scaleY(0.8);\n        transition: transform .12s cubic-bezier(0, 0, 0.2, 1), opacity .12s cubic-bezier(0, 0, 0.2, 1);\n    }\n\n    .p-connected-overlay-visible {\n        opacity: 1;\n        transform: scaleY(1);\n    }\n\n    .p-connected-overlay-hidden {\n        opacity: 0;\n        transform: scaleY(1);\n        transition: opacity .1s linear;\n    }\n\n    /* React based overlay animations */\n    .p-connected-overlay-enter {\n        opacity: 0;\n        transform: scaleY(0.8);\n    }\n\n    .p-connected-overlay-enter-active {\n        opacity: 1;\n        transform: scaleY(1);\n        transition: transform .12s cubic-bezier(0, 0, 0.2, 1), opacity .12s cubic-bezier(0, 0, 0.2, 1);\n    }\n\n    .p-connected-overlay-enter-done {\n        transform: none;\n    }\n\n    .p-connected-overlay-exit {\n        opacity: 1;\n    }\n\n    .p-connected-overlay-exit-active {\n        opacity: 0;\n        transition: opacity .1s linear;\n    }\n\n    /* Toggleable Content */\n    .p-toggleable-content-enter {\n        max-height: 0;\n    }\n\n    .p-toggleable-content-enter-active {\n        overflow: hidden;\n        max-height: 1000px;\n        transition: max-height 1s ease-in-out;\n    }\n\n    .p-toggleable-content-enter-done {\n        transform: none;\n    }\n\n    .p-toggleable-content-exit {\n        max-height: 1000px;\n    }\n\n    .p-toggleable-content-exit-active {\n        overflow: hidden;\n        max-height: 0;\n        transition: max-height 0.45s cubic-bezier(0, 1, 0, 1);\n    }\n\n    /* @todo Refactor */\n    .p-menu .p-menuitem-link {\n        cursor: pointer;\n        display: flex;\n        align-items: center;\n        text-decoration: none;\n        overflow: hidden;\n        position: relative;\n    }\n\n    ".concat(buttonStyles, "\n    ").concat(inputTextStyles, "\n    ").concat(iconStyles, "\n}\n");
    var ComponentBase = {
      cProps: void 0,
      cParams: void 0,
      cName: void 0,
      defaultProps: {
        pt: void 0,
        ptOptions: void 0,
        unstyled: false
      },
      context: {},
      globalCSS: void 0,
      classes: {},
      styles: "",
      extend: function extend() {
        var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var css = props.css;
        var defaultProps = _objectSpread$5(_objectSpread$5({}, props.defaultProps), ComponentBase.defaultProps);
        var inlineStyles2 = {};
        var getProps = function getProps2(props2) {
          var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          ComponentBase.context = context;
          ComponentBase.cProps = props2;
          return ObjectUtils.getMergedProps(props2, defaultProps);
        };
        var getOtherProps = function getOtherProps2(props2) {
          return ObjectUtils.getDiffProps(props2, defaultProps);
        };
        var getPTValue = function getPTValue2() {
          var _ComponentBase$contex;
          var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
          var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          var searchInDefaultPT = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
          if (obj.hasOwnProperty("pt") && obj.pt !== void 0) {
            obj = obj.pt;
          }
          var originalkey = key;
          var isNestedParam = /./g.test(originalkey) && !!params[originalkey.split(".")[0]];
          var fkey = isNestedParam ? ObjectUtils.toFlatCase(originalkey.split(".")[1]) : ObjectUtils.toFlatCase(originalkey);
          var hostName = params.hostName && ObjectUtils.toFlatCase(params.hostName);
          var componentName = hostName || params.props && params.props.__TYPE && ObjectUtils.toFlatCase(params.props.__TYPE) || "";
          var isTransition = fkey === "transition";
          var datasetPrefix = "data-pc-";
          var _getHostInstance = function getHostInstance(params2) {
            return params2 !== null && params2 !== void 0 && params2.props ? params2.hostName ? params2.props.__TYPE === params2.hostName ? params2.props : _getHostInstance(params2.parent) : params2.parent : void 0;
          };
          var getPropValue = function getPropValue2(name) {
            var _params$props, _getHostInstance2;
            return ((_params$props = params.props) === null || _params$props === void 0 ? void 0 : _params$props[name]) || ((_getHostInstance2 = _getHostInstance(params)) === null || _getHostInstance2 === void 0 ? void 0 : _getHostInstance2[name]);
          };
          ComponentBase.cParams = params;
          ComponentBase.cName = componentName;
          var _ref = getPropValue("ptOptions") || ComponentBase.context.ptOptions || {}, _ref$mergeSections = _ref.mergeSections, mergeSections = _ref$mergeSections === void 0 ? true : _ref$mergeSections, _ref$mergeProps = _ref.mergeProps, useMergeProps2 = _ref$mergeProps === void 0 ? false : _ref$mergeProps;
          var getPTClassValue = function getPTClassValue2() {
            var value = _getOptionValue.apply(void 0, arguments);
            if (Array.isArray(value)) {
              return {
                className: classNames.apply(void 0, _toConsumableArray$2(value))
              };
            }
            if (ObjectUtils.isString(value)) {
              return {
                className: value
              };
            }
            if (value !== null && value !== void 0 && value.hasOwnProperty("className") && Array.isArray(value.className)) {
              return {
                className: classNames.apply(void 0, _toConsumableArray$2(value.className))
              };
            }
            return value;
          };
          var globalPT = searchInDefaultPT ? isNestedParam ? _useGlobalPT(getPTClassValue, originalkey, params) : _useDefaultPT(getPTClassValue, originalkey, params) : void 0;
          var self2 = isNestedParam ? void 0 : _usePT(_getPT(obj, componentName), getPTClassValue, originalkey, params);
          var datasetProps = !isTransition && _objectSpread$5(_objectSpread$5({}, fkey === "root" && _defineProperty$4({}, "".concat(datasetPrefix, "name"), params.props && params.props.__parentMetadata ? ObjectUtils.toFlatCase(params.props.__TYPE) : componentName)), {}, _defineProperty$4({}, "".concat(datasetPrefix, "section"), fkey));
          return mergeSections || !mergeSections && self2 ? useMergeProps2 ? mergeProps([globalPT, self2, Object.keys(datasetProps).length ? datasetProps : {}], {
            classNameMergeFunction: (_ComponentBase$contex = ComponentBase.context.ptOptions) === null || _ComponentBase$contex === void 0 ? void 0 : _ComponentBase$contex.classNameMergeFunction
          }) : _objectSpread$5(_objectSpread$5(_objectSpread$5({}, globalPT), self2), Object.keys(datasetProps).length ? datasetProps : {}) : _objectSpread$5(_objectSpread$5({}, self2), Object.keys(datasetProps).length ? datasetProps : {});
        };
        var setMetaData = function setMetaData2() {
          var metadata = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var props2 = metadata.props, state = metadata.state;
          var ptm = function ptm2() {
            var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
            var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            return getPTValue((props2 || {}).pt, key, _objectSpread$5(_objectSpread$5({}, metadata), params));
          };
          var ptmo = function ptmo2() {
            var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
            var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            return getPTValue(obj, key, params, false);
          };
          var isUnstyled = function isUnstyled2() {
            return ComponentBase.context.unstyled || PrimeReact.unstyled || props2.unstyled;
          };
          var cx = function cx2() {
            var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
            var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            return !isUnstyled() ? _getOptionValue(css && css.classes, key, _objectSpread$5({
              props: props2,
              state
            }, params)) : void 0;
          };
          var sx = function sx2() {
            var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
            var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var when = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
            if (when) {
              var _ComponentBase$contex2;
              var self2 = _getOptionValue(css && css.inlineStyles, key, _objectSpread$5({
                props: props2,
                state
              }, params));
              var base = _getOptionValue(inlineStyles2, key, _objectSpread$5({
                props: props2,
                state
              }, params));
              return mergeProps([base, self2], {
                classNameMergeFunction: (_ComponentBase$contex2 = ComponentBase.context.ptOptions) === null || _ComponentBase$contex2 === void 0 ? void 0 : _ComponentBase$contex2.classNameMergeFunction
              });
            }
            return void 0;
          };
          return {
            ptm,
            ptmo,
            sx,
            cx,
            isUnstyled
          };
        };
        return _objectSpread$5(_objectSpread$5({
          getProps,
          getOtherProps,
          setMetaData
        }, props), {}, {
          defaultProps
        });
      }
    };
    var _getOptionValue = function getOptionValue(obj) {
      var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var fKeys = String(ObjectUtils.toFlatCase(key)).split(".");
      var fKey = fKeys.shift();
      var matchedPTOption = ObjectUtils.isNotEmpty(obj) ? Object.keys(obj).find(function(k) {
        return ObjectUtils.toFlatCase(k) === fKey;
      }) : "";
      return fKey ? ObjectUtils.isObject(obj) ? _getOptionValue(ObjectUtils.getItemValue(obj[matchedPTOption], params), fKeys.join("."), params) : void 0 : ObjectUtils.getItemValue(obj, params);
    };
    var _getPT = function _getPT2(pt) {
      var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var callback = arguments.length > 2 ? arguments[2] : void 0;
      var _usept = pt === null || pt === void 0 ? void 0 : pt._usept;
      var getValue2 = function getValue3(value) {
        var _ref3;
        var checkSameKey = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var _value = callback ? callback(value) : value;
        var _key = ObjectUtils.toFlatCase(key);
        return (_ref3 = checkSameKey ? _key !== ComponentBase.cName ? _value === null || _value === void 0 ? void 0 : _value[_key] : void 0 : _value === null || _value === void 0 ? void 0 : _value[_key]) !== null && _ref3 !== void 0 ? _ref3 : _value;
      };
      return ObjectUtils.isNotEmpty(_usept) ? {
        _usept,
        originalValue: getValue2(pt.originalValue),
        value: getValue2(pt.value)
      } : getValue2(pt, true);
    };
    var _usePT = function _usePT2(pt, callback, key, params) {
      var fn = function fn2(value2) {
        return callback(value2, key, params);
      };
      if (pt !== null && pt !== void 0 && pt.hasOwnProperty("_usept")) {
        var _ref4 = pt._usept || ComponentBase.context.ptOptions || {}, _ref4$mergeSections = _ref4.mergeSections, mergeSections = _ref4$mergeSections === void 0 ? true : _ref4$mergeSections, _ref4$mergeProps = _ref4.mergeProps, useMergeProps2 = _ref4$mergeProps === void 0 ? false : _ref4$mergeProps, classNameMergeFunction = _ref4.classNameMergeFunction;
        var originalValue = fn(pt.originalValue);
        var value = fn(pt.value);
        if (originalValue === void 0 && value === void 0) {
          return void 0;
        } else if (ObjectUtils.isString(value)) {
          return value;
        } else if (ObjectUtils.isString(originalValue)) {
          return originalValue;
        }
        return mergeSections || !mergeSections && value ? useMergeProps2 ? mergeProps([originalValue, value], {
          classNameMergeFunction
        }) : _objectSpread$5(_objectSpread$5({}, originalValue), value) : value;
      }
      return fn(pt);
    };
    var getGlobalPT = function getGlobalPT2() {
      return _getPT(ComponentBase.context.pt || PrimeReact.pt, void 0, function(value) {
        return ObjectUtils.getItemValue(value, ComponentBase.cParams);
      });
    };
    var getDefaultPT = function getDefaultPT2() {
      return _getPT(ComponentBase.context.pt || PrimeReact.pt, void 0, function(value) {
        return _getOptionValue(value, ComponentBase.cName, ComponentBase.cParams) || ObjectUtils.getItemValue(value, ComponentBase.cParams);
      });
    };
    var _useGlobalPT = function _useGlobalPT2(callback, key, params) {
      return _usePT(getGlobalPT(), callback, key, params);
    };
    var _useDefaultPT = function _useDefaultPT2(callback, key, params) {
      return _usePT(getDefaultPT(), callback, key, params);
    };
    var useHandleStyle = function useHandleStyle2(styles2) {
      var _isUnstyled = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
      };
      var config = arguments.length > 2 ? arguments[2] : void 0;
      var name = config.name, _config$styled = config.styled, styled = _config$styled === void 0 ? false : _config$styled, _config$hostName = config.hostName, hostName = _config$hostName === void 0 ? "" : _config$hostName;
      var globalCSS = _useGlobalPT(_getOptionValue, "global.css", ComponentBase.cParams);
      var componentName = ObjectUtils.toFlatCase(name);
      var _useStyle = useStyle(baseStyle, {
        name: "base",
        manual: true
      }), loadBaseStyle = _useStyle.load;
      var _useStyle2 = useStyle(commonStyle, {
        name: "common",
        manual: true
      }), loadCommonStyle = _useStyle2.load;
      var _useStyle3 = useStyle(globalCSS, {
        name: "global",
        manual: true
      }), loadGlobalStyle = _useStyle3.load;
      var _useStyle4 = useStyle(styles2, {
        name,
        manual: true
      }), loadComponentStyle = _useStyle4.load;
      var hook = function hook2(hookName) {
        if (!hostName) {
          var selfHook = _usePT(_getPT((ComponentBase.cProps || {}).pt, componentName), _getOptionValue, "hooks.".concat(hookName));
          var defaultHook = _useDefaultPT(_getOptionValue, "hooks.".concat(hookName));
          selfHook === null || selfHook === void 0 || selfHook();
          defaultHook === null || defaultHook === void 0 || defaultHook();
        }
      };
      hook("useMountEffect");
      useMountEffect(function() {
        loadBaseStyle();
        loadGlobalStyle();
        if (!_isUnstyled()) {
          loadCommonStyle();
          if (!styled) {
            loadComponentStyle();
          }
        }
      });
      useUpdateEffect(function() {
        hook("useUpdateEffect");
      });
      useUnmountEffect(function() {
        hook("useUnmountEffect");
      });
    };
    var IconBase = {
      defaultProps: {
        __TYPE: "IconBase",
        className: null,
        label: null,
        spin: false
      },
      getProps: function getProps(props) {
        return ObjectUtils.getMergedProps(props, IconBase.defaultProps);
      },
      getOtherProps: function getOtherProps(props) {
        return ObjectUtils.getDiffProps(props, IconBase.defaultProps);
      },
      getPTI: function getPTI(props) {
        var isLabelEmpty = ObjectUtils.isEmpty(props.label);
        var otherProps = IconBase.getOtherProps(props);
        var ptiProps = {
          className: classNames("p-icon", {
            "p-icon-spin": props.spin
          }, props.className),
          role: !isLabelEmpty ? "img" : void 0,
          "aria-label": !isLabelEmpty ? props.label : void 0,
          "aria-hidden": props.label ? isLabelEmpty : void 0
        };
        return ObjectUtils.getMergedProps(otherProps, ptiProps);
      }
    };
    function _extends$9() {
      return _extends$9 = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
          var t = arguments[e];
          for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
        }
        return n;
      }, _extends$9.apply(null, arguments);
    }
    var SpinnerIcon = /* @__PURE__ */ reactExports.memo(/* @__PURE__ */ reactExports.forwardRef(function(inProps, ref) {
      var pti = IconBase.getPTI(inProps);
      return /* @__PURE__ */ reactExports.createElement("svg", _extends$9({
        ref,
        width: "14",
        height: "14",
        viewBox: "0 0 14 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, pti), /* @__PURE__ */ reactExports.createElement("path", {
        d: "M6.99701 14C5.85441 13.999 4.72939 13.7186 3.72012 13.1832C2.71084 12.6478 1.84795 11.8737 1.20673 10.9284C0.565504 9.98305 0.165424 8.89526 0.041387 7.75989C-0.0826496 6.62453 0.073125 5.47607 0.495122 4.4147C0.917119 3.35333 1.59252 2.4113 2.46241 1.67077C3.33229 0.930247 4.37024 0.413729 5.4857 0.166275C6.60117 -0.0811796 7.76026 -0.0520535 8.86188 0.251112C9.9635 0.554278 10.9742 1.12227 11.8057 1.90555C11.915 2.01493 11.9764 2.16319 11.9764 2.31778C11.9764 2.47236 11.915 2.62062 11.8057 2.73C11.7521 2.78503 11.688 2.82877 11.6171 2.85864C11.5463 2.8885 11.4702 2.90389 11.3933 2.90389C11.3165 2.90389 11.2404 2.8885 11.1695 2.85864C11.0987 2.82877 11.0346 2.78503 10.9809 2.73C9.9998 1.81273 8.73246 1.26138 7.39226 1.16876C6.05206 1.07615 4.72086 1.44794 3.62279 2.22152C2.52471 2.99511 1.72683 4.12325 1.36345 5.41602C1.00008 6.70879 1.09342 8.08723 1.62775 9.31926C2.16209 10.5513 3.10478 11.5617 4.29713 12.1803C5.48947 12.7989 6.85865 12.988 8.17414 12.7157C9.48963 12.4435 10.6711 11.7264 11.5196 10.6854C12.3681 9.64432 12.8319 8.34282 12.8328 7C12.8328 6.84529 12.8943 6.69692 13.0038 6.58752C13.1132 6.47812 13.2616 6.41667 13.4164 6.41667C13.5712 6.41667 13.7196 6.47812 13.8291 6.58752C13.9385 6.69692 14 6.84529 14 7C14 8.85651 13.2622 10.637 11.9489 11.9497C10.6356 13.2625 8.85432 14 6.99701 14Z",
        fill: "currentColor"
      }));
    }));
    SpinnerIcon.displayName = "SpinnerIcon";
    function _extends$8() {
      return _extends$8 = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
          var t = arguments[e];
          for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
        }
        return n;
      }, _extends$8.apply(null, arguments);
    }
    function _typeof$3(o) {
      "@babel/helpers - typeof";
      return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof$3(o);
    }
    function toPrimitive$3(t, r) {
      if ("object" != _typeof$3(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r);
        if ("object" != _typeof$3(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function toPropertyKey$3(t) {
      var i = toPrimitive$3(t, "string");
      return "symbol" == _typeof$3(i) ? i : i + "";
    }
    function _defineProperty$3(e, r, t) {
      return (r = toPropertyKey$3(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
      }) : e[r] = t, e;
    }
    function _arrayWithHoles$3(r) {
      if (Array.isArray(r)) return r;
    }
    function _iterableToArrayLimit$3(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) ;
          else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _arrayLikeToArray$3(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function _unsupportedIterableToArray$3(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray$3(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$3(r, a) : void 0;
      }
    }
    function _nonIterableRest$3() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _slicedToArray$3(r, e) {
      return _arrayWithHoles$3(r) || _iterableToArrayLimit$3(r, e) || _unsupportedIterableToArray$3(r, e) || _nonIterableRest$3();
    }
    var styles$4 = "\n@layer primereact {\n    .p-ripple {\n        overflow: hidden;\n        position: relative;\n    }\n    \n    .p-ink {\n        display: block;\n        position: absolute;\n        background: rgba(255, 255, 255, 0.5);\n        border-radius: 100%;\n        transform: scale(0);\n    }\n    \n    .p-ink-active {\n        animation: ripple 0.4s linear;\n    }\n    \n    .p-ripple-disabled .p-ink {\n        display: none;\n    }\n}\n\n@keyframes ripple {\n    100% {\n        opacity: 0;\n        transform: scale(2.5);\n    }\n}\n\n";
    var classes$4 = {
      root: "p-ink"
    };
    var RippleBase = ComponentBase.extend({
      defaultProps: {
        __TYPE: "Ripple",
        children: void 0
      },
      css: {
        styles: styles$4,
        classes: classes$4
      },
      getProps: function getProps(props) {
        return ObjectUtils.getMergedProps(props, RippleBase.defaultProps);
      },
      getOtherProps: function getOtherProps(props) {
        return ObjectUtils.getDiffProps(props, RippleBase.defaultProps);
      }
    });
    function ownKeys$4(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread$4(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys$4(Object(t), true).forEach(function(r2) {
          _defineProperty$3(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$4(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    var Ripple = /* @__PURE__ */ reactExports.memo(/* @__PURE__ */ reactExports.forwardRef(function(inProps, ref) {
      var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray$3(_React$useState, 2), isMounted = _React$useState2[0], setMounted = _React$useState2[1];
      var inkRef = reactExports.useRef(null);
      var targetRef = reactExports.useRef(null);
      var mergeProps2 = useMergeProps();
      var context = reactExports.useContext(PrimeReactContext);
      var props = RippleBase.getProps(inProps, context);
      var isRippleActive = context && context.ripple || PrimeReact.ripple;
      var metaData = {
        props
      };
      useStyle(RippleBase.css.styles, {
        name: "ripple",
        manual: !isRippleActive
      });
      var _RippleBase$setMetaDa = RippleBase.setMetaData(_objectSpread$4({}, metaData)), ptm = _RippleBase$setMetaDa.ptm, cx = _RippleBase$setMetaDa.cx;
      var getTarget = function getTarget2() {
        return inkRef.current && inkRef.current.parentElement;
      };
      var bindEvents = function bindEvents2() {
        if (targetRef.current) {
          targetRef.current.addEventListener("pointerdown", onPointerDown);
        }
      };
      var unbindEvents = function unbindEvents2() {
        if (targetRef.current) {
          targetRef.current.removeEventListener("pointerdown", onPointerDown);
        }
      };
      var onPointerDown = function onPointerDown2(event) {
        var offset = DomHandler.getOffset(targetRef.current);
        var offsetX = event.pageX - offset.left + document.body.scrollTop - DomHandler.getWidth(inkRef.current) / 2;
        var offsetY = event.pageY - offset.top + document.body.scrollLeft - DomHandler.getHeight(inkRef.current) / 2;
        activateRipple(offsetX, offsetY);
      };
      var activateRipple = function activateRipple2(offsetX, offsetY) {
        if (!inkRef.current || getComputedStyle(inkRef.current, null).display === "none") {
          return;
        }
        DomHandler.removeClass(inkRef.current, "p-ink-active");
        setDimensions();
        inkRef.current.style.top = offsetY + "px";
        inkRef.current.style.left = offsetX + "px";
        DomHandler.addClass(inkRef.current, "p-ink-active");
      };
      var onAnimationEnd = function onAnimationEnd2(event) {
        DomHandler.removeClass(event.currentTarget, "p-ink-active");
      };
      var setDimensions = function setDimensions2() {
        if (inkRef.current && !DomHandler.getHeight(inkRef.current) && !DomHandler.getWidth(inkRef.current)) {
          var d = Math.max(DomHandler.getOuterWidth(targetRef.current), DomHandler.getOuterHeight(targetRef.current));
          inkRef.current.style.height = d + "px";
          inkRef.current.style.width = d + "px";
        }
      };
      reactExports.useImperativeHandle(ref, function() {
        return {
          props,
          getInk: function getInk() {
            return inkRef.current;
          },
          getTarget: function getTarget2() {
            return targetRef.current;
          }
        };
      });
      useMountEffect(function() {
        setMounted(true);
      });
      useUpdateEffect(function() {
        if (isMounted && inkRef.current) {
          targetRef.current = getTarget();
          setDimensions();
          bindEvents();
        }
      }, [isMounted]);
      useUpdateEffect(function() {
        if (inkRef.current && !targetRef.current) {
          targetRef.current = getTarget();
          setDimensions();
          bindEvents();
        }
      });
      useUnmountEffect(function() {
        if (inkRef.current) {
          targetRef.current = null;
          unbindEvents();
        }
      });
      if (!isRippleActive) {
        return null;
      }
      var rootProps = mergeProps2({
        "aria-hidden": true,
        className: classNames(cx("root"))
      }, RippleBase.getOtherProps(props), ptm("root"));
      return /* @__PURE__ */ reactExports.createElement("span", _extends$8({
        role: "presentation",
        ref: inkRef
      }, rootProps, {
        onAnimationEnd
      }));
    }));
    Ripple.displayName = "Ripple";
    function _arrayWithHoles$2(r) {
      if (Array.isArray(r)) return r;
    }
    function _iterableToArrayLimit$2(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) ;
          else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _arrayLikeToArray$2(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function _unsupportedIterableToArray$2(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray$2(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$2(r, a) : void 0;
      }
    }
    function _nonIterableRest$2() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _slicedToArray$2(r, e) {
      return _arrayWithHoles$2(r) || _iterableToArrayLimit$2(r, e) || _unsupportedIterableToArray$2(r, e) || _nonIterableRest$2();
    }
    var PortalBase = {
      defaultProps: {
        __TYPE: "Portal",
        element: null,
        appendTo: null,
        visible: false,
        onMounted: null,
        onUnmounted: null,
        children: void 0
      },
      getProps: function getProps(props) {
        return ObjectUtils.getMergedProps(props, PortalBase.defaultProps);
      },
      getOtherProps: function getOtherProps(props) {
        return ObjectUtils.getDiffProps(props, PortalBase.defaultProps);
      }
    };
    var Portal = /* @__PURE__ */ reactExports.memo(function(inProps) {
      var props = PortalBase.getProps(inProps);
      var context = reactExports.useContext(PrimeReactContext);
      var _React$useState = reactExports.useState(props.visible && DomHandler.isClient()), _React$useState2 = _slicedToArray$2(_React$useState, 2), mountedState = _React$useState2[0], setMountedState = _React$useState2[1];
      useMountEffect(function() {
        if (DomHandler.isClient() && !mountedState) {
          setMountedState(true);
          props.onMounted && props.onMounted();
        }
      });
      useUpdateEffect(function() {
        props.onMounted && props.onMounted();
      }, [mountedState]);
      useUnmountEffect(function() {
        props.onUnmounted && props.onUnmounted();
      });
      var element = props.element || props.children;
      if (element && mountedState) {
        var appendTo = props.appendTo || context && context.appendTo || PrimeReact.appendTo;
        if (ObjectUtils.isFunction(appendTo)) {
          appendTo = appendTo();
        }
        if (!appendTo) {
          appendTo = document.body;
        }
        return appendTo === "self" ? element : /* @__PURE__ */ ReactDOM.createPortal(element, appendTo);
      }
      return null;
    });
    Portal.displayName = "Portal";
    function _extends$7() {
      return _extends$7 = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
          var t = arguments[e];
          for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
        }
        return n;
      }, _extends$7.apply(null, arguments);
    }
    function _typeof$2(o) {
      "@babel/helpers - typeof";
      return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof$2(o);
    }
    function toPrimitive$2(t, r) {
      if ("object" != _typeof$2(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r);
        if ("object" != _typeof$2(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function toPropertyKey$2(t) {
      var i = toPrimitive$2(t, "string");
      return "symbol" == _typeof$2(i) ? i : i + "";
    }
    function _defineProperty$2(e, r, t) {
      return (r = toPropertyKey$2(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
      }) : e[r] = t, e;
    }
    function _arrayLikeToArray$1(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function _arrayWithoutHoles$1(r) {
      if (Array.isArray(r)) return _arrayLikeToArray$1(r);
    }
    function _iterableToArray$1(r) {
      if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
    }
    function _unsupportedIterableToArray$1(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray$1(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$1(r, a) : void 0;
      }
    }
    function _nonIterableSpread$1() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _toConsumableArray$1(r) {
      return _arrayWithoutHoles$1(r) || _iterableToArray$1(r) || _unsupportedIterableToArray$1(r) || _nonIterableSpread$1();
    }
    function _arrayWithHoles$1(r) {
      if (Array.isArray(r)) return r;
    }
    function _iterableToArrayLimit$1(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) ;
          else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _nonIterableRest$1() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _slicedToArray$1(r, e) {
      return _arrayWithHoles$1(r) || _iterableToArrayLimit$1(r, e) || _unsupportedIterableToArray$1(r, e) || _nonIterableRest$1();
    }
    var classes$3 = {
      root: function root2(_ref) {
        var positionState = _ref.positionState, classNameState = _ref.classNameState;
        return classNames("p-tooltip p-component", _defineProperty$2({}, "p-tooltip-".concat(positionState), true), classNameState);
      },
      arrow: "p-tooltip-arrow",
      text: "p-tooltip-text"
    };
    var inlineStyles$1 = {
      arrow: function arrow(_ref2) {
        var context = _ref2.context;
        return {
          top: context.bottom ? "0" : context.right || context.left || !context.right && !context.left && !context.top && !context.bottom ? "50%" : null,
          bottom: context.top ? "0" : null,
          left: context.right || !context.right && !context.left && !context.top && !context.bottom ? "0" : context.top || context.bottom ? "50%" : null,
          right: context.left ? "0" : null
        };
      }
    };
    var styles$3 = "\n@layer primereact {\n    .p-tooltip {\n        position: absolute;\n        padding: .25em .5rem;\n        /* #3687: Tooltip prevent scrollbar flickering */\n        top: -9999px;\n        left: -9999px;\n    }\n    \n    .p-tooltip.p-tooltip-right,\n    .p-tooltip.p-tooltip-left {\n        padding: 0 .25rem;\n    }\n    \n    .p-tooltip.p-tooltip-top,\n    .p-tooltip.p-tooltip-bottom {\n        padding:.25em 0;\n    }\n    \n    .p-tooltip .p-tooltip-text {\n       white-space: pre-line;\n       word-break: break-word;\n    }\n    \n    .p-tooltip-arrow {\n        position: absolute;\n        width: 0;\n        height: 0;\n        border-color: transparent;\n        border-style: solid;\n    }\n    \n    .p-tooltip-right .p-tooltip-arrow {\n        top: 50%;\n        left: 0;\n        margin-top: -.25rem;\n        border-width: .25em .25em .25em 0;\n    }\n    \n    .p-tooltip-left .p-tooltip-arrow {\n        top: 50%;\n        right: 0;\n        margin-top: -.25rem;\n        border-width: .25em 0 .25em .25rem;\n    }\n    \n    .p-tooltip.p-tooltip-top {\n        padding: .25em 0;\n    }\n    \n    .p-tooltip-top .p-tooltip-arrow {\n        bottom: 0;\n        left: 50%;\n        margin-left: -.25rem;\n        border-width: .25em .25em 0;\n    }\n    \n    .p-tooltip-bottom .p-tooltip-arrow {\n        top: 0;\n        left: 50%;\n        margin-left: -.25rem;\n        border-width: 0 .25em .25rem;\n    }\n\n    .p-tooltip-target-wrapper {\n        display: inline-flex;\n    }\n}\n";
    var TooltipBase = ComponentBase.extend({
      defaultProps: {
        __TYPE: "Tooltip",
        appendTo: null,
        at: null,
        autoHide: true,
        autoZIndex: true,
        baseZIndex: 0,
        className: null,
        closeOnEscape: false,
        content: null,
        disabled: false,
        event: null,
        hideDelay: 0,
        hideEvent: "mouseleave",
        id: null,
        mouseTrack: false,
        mouseTrackLeft: 5,
        mouseTrackTop: 5,
        my: null,
        onBeforeHide: null,
        onBeforeShow: null,
        onHide: null,
        onShow: null,
        position: "right",
        showDelay: 0,
        showEvent: "mouseenter",
        showOnDisabled: false,
        style: null,
        target: null,
        updateDelay: 0,
        children: void 0
      },
      css: {
        classes: classes$3,
        styles: styles$3,
        inlineStyles: inlineStyles$1
      }
    });
    function ownKeys$3(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread$3(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys$3(Object(t), true).forEach(function(r2) {
          _defineProperty$2(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$3(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    var Tooltip = /* @__PURE__ */ reactExports.memo(/* @__PURE__ */ reactExports.forwardRef(function(inProps, ref) {
      var mergeProps2 = useMergeProps();
      var context = reactExports.useContext(PrimeReactContext);
      var props = TooltipBase.getProps(inProps, context);
      var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray$1(_React$useState, 2), visibleState = _React$useState2[0], setVisibleState = _React$useState2[1];
      var _React$useState3 = reactExports.useState(props.position || "right"), _React$useState4 = _slicedToArray$1(_React$useState3, 2), positionState = _React$useState4[0], setPositionState = _React$useState4[1];
      var _React$useState5 = reactExports.useState(""), _React$useState6 = _slicedToArray$1(_React$useState5, 2), classNameState = _React$useState6[0], setClassNameState = _React$useState6[1];
      var _React$useState7 = reactExports.useState(false), _React$useState8 = _slicedToArray$1(_React$useState7, 2), multipleFocusEvents = _React$useState8[0], setMultipleFocusEvents = _React$useState8[1];
      var isCloseOnEscape = visibleState && props.closeOnEscape;
      var overlayDisplayOrder = useDisplayOrder("tooltip", isCloseOnEscape);
      var metaData = {
        props,
        state: {
          visible: visibleState,
          position: positionState,
          className: classNameState
        },
        context: {
          right: positionState === "right",
          left: positionState === "left",
          top: positionState === "top",
          bottom: positionState === "bottom"
        }
      };
      var _TooltipBase$setMetaD = TooltipBase.setMetaData(metaData), ptm = _TooltipBase$setMetaD.ptm, cx = _TooltipBase$setMetaD.cx, sx = _TooltipBase$setMetaD.sx, isUnstyled = _TooltipBase$setMetaD.isUnstyled;
      useHandleStyle(TooltipBase.css.styles, isUnstyled, {
        name: "tooltip"
      });
      useGlobalOnEscapeKey({
        callback: function callback() {
          hide();
        },
        when: isCloseOnEscape,
        priority: [ESC_KEY_HANDLING_PRIORITIES.TOOLTIP, overlayDisplayOrder]
      });
      var elementRef = reactExports.useRef(null);
      var textRef = reactExports.useRef(null);
      var currentTargetRef = reactExports.useRef(null);
      var containerSize = reactExports.useRef(null);
      var allowHide = reactExports.useRef(true);
      var timeouts = reactExports.useRef({});
      var currentMouseEvent = reactExports.useRef(null);
      var _useResizeListener = useResizeListener({
        listener: function listener(event) {
          !DomHandler.isTouchDevice() && hide(event);
        }
      }), _useResizeListener2 = _slicedToArray$1(_useResizeListener, 2), bindWindowResizeListener = _useResizeListener2[0], unbindWindowResizeListener = _useResizeListener2[1];
      var _useOverlayScrollList = useOverlayScrollListener({
        target: currentTargetRef.current,
        listener: function listener(event) {
          hide(event);
        },
        when: visibleState
      }), _useOverlayScrollList2 = _slicedToArray$1(_useOverlayScrollList, 2), bindOverlayScrollListener = _useOverlayScrollList2[0], unbindOverlayScrollListener = _useOverlayScrollList2[1];
      var isTargetContentEmpty = function isTargetContentEmpty2(target) {
        return !(props.content || getTargetOption(target, "tooltip"));
      };
      var isContentEmpty = function isContentEmpty2(target) {
        return !(props.content || getTargetOption(target, "tooltip") || props.children);
      };
      var isMouseTrack = function isMouseTrack2(target) {
        return getTargetOption(target, "mousetrack") || props.mouseTrack;
      };
      var isDisabled = function isDisabled2(target) {
        return getTargetOption(target, "disabled") === "true" || hasTargetOption(target, "disabled") || props.disabled;
      };
      var isShowOnDisabled = function isShowOnDisabled2(target) {
        return getTargetOption(target, "showondisabled") || props.showOnDisabled;
      };
      var isAutoHide = function isAutoHide2() {
        return getTargetOption(currentTargetRef.current, "autohide") || props.autoHide;
      };
      var getTargetOption = function getTargetOption2(target, option) {
        return hasTargetOption(target, "data-pr-".concat(option)) ? target.getAttribute("data-pr-".concat(option)) : null;
      };
      var hasTargetOption = function hasTargetOption2(target, option) {
        return target && target.hasAttribute(option);
      };
      var getEvents = function getEvents2(target) {
        var showEvents = [getTargetOption(target, "showevent") || props.showEvent];
        var hideEvents = [getTargetOption(target, "hideevent") || props.hideEvent];
        if (isMouseTrack(target)) {
          showEvents = ["mousemove"];
          hideEvents = ["mouseleave"];
        } else {
          var event = getTargetOption(target, "event") || props.event;
          if (event === "focus") {
            showEvents = ["focus"];
            hideEvents = ["blur"];
          }
          if (event === "both") {
            showEvents = ["focus", "mouseenter"];
            hideEvents = multipleFocusEvents ? ["blur"] : ["mouseleave", "blur"];
          }
        }
        return {
          showEvents,
          hideEvents
        };
      };
      var getPosition = function getPosition2(target) {
        return getTargetOption(target, "position") || positionState;
      };
      var getMouseTrackPosition = function getMouseTrackPosition2(target) {
        var top = getTargetOption(target, "mousetracktop") || props.mouseTrackTop;
        var left = getTargetOption(target, "mousetrackleft") || props.mouseTrackLeft;
        return {
          top,
          left
        };
      };
      var updateText = function updateText2(target, callback) {
        if (textRef.current) {
          var content = getTargetOption(target, "tooltip") || props.content;
          if (content) {
            textRef.current.innerHTML = "";
            textRef.current.appendChild(document.createTextNode(content));
            callback();
          } else if (props.children) {
            callback();
          }
        }
      };
      var updateTooltipState = function updateTooltipState2(position) {
        updateText(currentTargetRef.current, function() {
          var _currentMouseEvent$cu = currentMouseEvent.current, x = _currentMouseEvent$cu.pageX, y = _currentMouseEvent$cu.pageY;
          if (props.autoZIndex && !ZIndexUtils.get(elementRef.current)) {
            ZIndexUtils.set("tooltip", elementRef.current, context && context.autoZIndex || PrimeReact.autoZIndex, props.baseZIndex || context && context.zIndex.tooltip || PrimeReact.zIndex.tooltip);
          }
          elementRef.current.style.left = "";
          elementRef.current.style.top = "";
          if (isAutoHide()) {
            elementRef.current.style.pointerEvents = "none";
          }
          var mouseTrackCheck = isMouseTrack(currentTargetRef.current) || position === "mouse";
          if (mouseTrackCheck && !containerSize.current || mouseTrackCheck) {
            containerSize.current = {
              width: DomHandler.getOuterWidth(elementRef.current),
              height: DomHandler.getOuterHeight(elementRef.current)
            };
          }
          align(currentTargetRef.current, {
            x,
            y
          }, position);
        });
      };
      var show = function show2(e) {
        if (e.type && e.type === "focus") setMultipleFocusEvents(true);
        currentTargetRef.current = e.currentTarget;
        var disabled = isDisabled(currentTargetRef.current);
        var empty = isContentEmpty(isShowOnDisabled(currentTargetRef.current) && disabled ? currentTargetRef.current.firstChild : currentTargetRef.current);
        if (empty || disabled) {
          return;
        }
        currentMouseEvent.current = e;
        if (visibleState) {
          applyDelay("updateDelay", updateTooltipState);
        } else {
          var success = sendCallback(props.onBeforeShow, {
            originalEvent: e,
            target: currentTargetRef.current
          });
          if (success) {
            applyDelay("showDelay", function() {
              setVisibleState(true);
              sendCallback(props.onShow, {
                originalEvent: e,
                target: currentTargetRef.current
              });
            });
          }
        }
      };
      var hide = function hide2(e) {
        if (e && e.type === "blur") setMultipleFocusEvents(false);
        clearTimeouts();
        if (visibleState) {
          var success = sendCallback(props.onBeforeHide, {
            originalEvent: e,
            target: currentTargetRef.current
          });
          if (success) {
            applyDelay("hideDelay", function() {
              if (!isAutoHide() && allowHide.current === false) {
                return;
              }
              ZIndexUtils.clear(elementRef.current);
              DomHandler.removeClass(elementRef.current, "p-tooltip-active");
              setVisibleState(false);
              sendCallback(props.onHide, {
                originalEvent: e,
                target: currentTargetRef.current
              });
            });
          }
        } else if (!props.onBeforeHide && !getDelay("hideDelay")) {
          setVisibleState(false);
        }
      };
      var align = function align2(target, coordinate, position) {
        var left = 0;
        var top = 0;
        var currentPosition = position || positionState;
        if ((isMouseTrack(target) || currentPosition == "mouse") && coordinate) {
          var _containerSize = {
            width: DomHandler.getOuterWidth(elementRef.current),
            height: DomHandler.getOuterHeight(elementRef.current)
          };
          left = coordinate.x;
          top = coordinate.y;
          var _getMouseTrackPositio = getMouseTrackPosition(target), mouseTrackTop = _getMouseTrackPositio.top, mouseTrackLeft = _getMouseTrackPositio.left;
          switch (currentPosition) {
            case "left":
              left = left - (_containerSize.width + mouseTrackLeft);
              top = top - (_containerSize.height / 2 - mouseTrackTop);
              break;
            case "right":
            case "mouse":
              left = left + mouseTrackLeft;
              top = top - (_containerSize.height / 2 - mouseTrackTop);
              break;
            case "top":
              left = left - (_containerSize.width / 2 - mouseTrackLeft);
              top = top - (_containerSize.height + mouseTrackTop);
              break;
            case "bottom":
              left = left - (_containerSize.width / 2 - mouseTrackLeft);
              top = top + mouseTrackTop;
              break;
          }
          if (left <= 0 || containerSize.current.width > _containerSize.width) {
            elementRef.current.style.left = "0px";
            elementRef.current.style.right = window.innerWidth - _containerSize.width - left + "px";
          } else {
            elementRef.current.style.right = "";
            elementRef.current.style.left = left + "px";
          }
          elementRef.current.style.top = top + "px";
          DomHandler.addClass(elementRef.current, "p-tooltip-active");
        } else {
          var pos = DomHandler.findCollisionPosition(currentPosition);
          var my = getTargetOption(target, "my") || props.my || pos.my;
          var at = getTargetOption(target, "at") || props.at || pos.at;
          elementRef.current.style.padding = "0px";
          DomHandler.flipfitCollision(elementRef.current, target, my, at, function(calculatedPosition) {
            var _calculatedPosition$a = calculatedPosition.at, atX = _calculatedPosition$a.x, atY = _calculatedPosition$a.y;
            var myX = calculatedPosition.my.x;
            var newPosition = props.at ? atX !== "center" && atX !== myX ? atX : atY : calculatedPosition.at["".concat(pos.axis)];
            elementRef.current.style.padding = "";
            setPositionState(newPosition);
            updateContainerPosition(newPosition);
            DomHandler.addClass(elementRef.current, "p-tooltip-active");
          });
        }
      };
      var updateContainerPosition = function updateContainerPosition2(position) {
        if (elementRef.current) {
          var style = getComputedStyle(elementRef.current);
          if (position === "left") {
            elementRef.current.style.left = parseFloat(style.left) - parseFloat(style.paddingLeft) * 2 + "px";
          } else if (position === "top") {
            elementRef.current.style.top = parseFloat(style.top) - parseFloat(style.paddingTop) * 2 + "px";
          }
        }
      };
      var _onMouseEnter = function onMouseEnter() {
        if (!isAutoHide()) {
          allowHide.current = false;
        }
      };
      var _onMouseLeave = function onMouseLeave(e) {
        if (!isAutoHide()) {
          allowHide.current = true;
          hide(e);
        }
      };
      var bindTargetEvent = function bindTargetEvent2(target) {
        if (target) {
          var _getEvents = getEvents(target), showEvents = _getEvents.showEvents, hideEvents = _getEvents.hideEvents;
          var currentTarget = getTarget(target);
          showEvents.forEach(function(event) {
            return currentTarget === null || currentTarget === void 0 ? void 0 : currentTarget.addEventListener(event, show);
          });
          hideEvents.forEach(function(event) {
            return currentTarget === null || currentTarget === void 0 ? void 0 : currentTarget.addEventListener(event, hide);
          });
        }
      };
      var unbindTargetEvent = function unbindTargetEvent2(target) {
        if (target) {
          var _getEvents2 = getEvents(target), showEvents = _getEvents2.showEvents, hideEvents = _getEvents2.hideEvents;
          var currentTarget = getTarget(target);
          showEvents.forEach(function(event) {
            return currentTarget === null || currentTarget === void 0 ? void 0 : currentTarget.removeEventListener(event, show);
          });
          hideEvents.forEach(function(event) {
            return currentTarget === null || currentTarget === void 0 ? void 0 : currentTarget.removeEventListener(event, hide);
          });
        }
      };
      var getDelay = function getDelay2(delayProp) {
        return getTargetOption(currentTargetRef.current, delayProp.toLowerCase()) || props[delayProp];
      };
      var applyDelay = function applyDelay2(delayProp, callback) {
        clearTimeouts();
        var delay = getDelay(delayProp);
        delay ? timeouts.current["".concat(delayProp)] = setTimeout(function() {
          return callback();
        }, delay) : callback();
      };
      var sendCallback = function sendCallback2(callback) {
        if (callback) {
          for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            params[_key - 1] = arguments[_key];
          }
          var result = callback.apply(void 0, params);
          if (result === void 0) {
            result = true;
          }
          return result;
        }
        return true;
      };
      var clearTimeouts = function clearTimeouts2() {
        Object.values(timeouts.current).forEach(function(t) {
          return clearTimeout(t);
        });
      };
      var getTarget = function getTarget2(target) {
        if (target) {
          if (isShowOnDisabled(target)) {
            if (!target.hasWrapper) {
              var wrapper = document.createElement("div");
              var isInputElement2 = target.nodeName === "INPUT";
              if (isInputElement2) {
                DomHandler.addMultipleClasses(wrapper, "p-tooltip-target-wrapper p-inputwrapper");
              } else {
                DomHandler.addClass(wrapper, "p-tooltip-target-wrapper");
              }
              target.parentNode.insertBefore(wrapper, target);
              wrapper.appendChild(target);
              target.hasWrapper = true;
              return wrapper;
            }
            return target.parentElement;
          } else if (target.hasWrapper) {
            var _target$parentElement;
            (_target$parentElement = target.parentElement).replaceWith.apply(_target$parentElement, _toConsumableArray$1(target.parentElement.childNodes));
            delete target.hasWrapper;
          }
          return target;
        }
        return null;
      };
      var updateTargetEvents = function updateTargetEvents2(target) {
        unloadTargetEvents(target);
        loadTargetEvents(target);
      };
      var loadTargetEvents = function loadTargetEvents2(target) {
        setTargetEventOperations(target || props.target, bindTargetEvent);
      };
      var unloadTargetEvents = function unloadTargetEvents2(target) {
        setTargetEventOperations(target || props.target, unbindTargetEvent);
      };
      var setTargetEventOperations = function setTargetEventOperations2(target, operation) {
        target = ObjectUtils.getRefElement(target);
        if (target) {
          if (DomHandler.isElement(target)) {
            operation(target);
          } else {
            var setEvent = function setEvent2(target2) {
              var element2 = DomHandler.find(document, target2);
              element2.forEach(function(el) {
                operation(el);
              });
            };
            if (target instanceof Array) {
              target.forEach(function(t) {
                setEvent(t);
              });
            } else {
              setEvent(target);
            }
          }
        }
      };
      useMountEffect(function() {
        if (visibleState && currentTargetRef.current && isDisabled(currentTargetRef.current)) {
          hide();
        }
      });
      useUpdateEffect(function() {
        loadTargetEvents();
        return function() {
          unloadTargetEvents();
        };
      }, [show, hide, props.target]);
      useUpdateEffect(function() {
        if (visibleState) {
          var position = getPosition(currentTargetRef.current);
          var classname = getTargetOption(currentTargetRef.current, "classname");
          setPositionState(position);
          setClassNameState(classname);
          updateTooltipState(position);
          bindWindowResizeListener();
          bindOverlayScrollListener();
        } else {
          setPositionState(props.position || "right");
          setClassNameState("");
          currentTargetRef.current = null;
          containerSize.current = null;
          allowHide.current = true;
        }
        return function() {
          unbindWindowResizeListener();
          unbindOverlayScrollListener();
        };
      }, [visibleState]);
      useUpdateEffect(function() {
        var position = getPosition(currentTargetRef.current);
        if (visibleState && position !== "mouse") {
          applyDelay("updateDelay", function() {
            updateText(currentTargetRef.current, function() {
              align(currentTargetRef.current);
            });
          });
        }
      }, [props.content]);
      useUnmountEffect(function() {
        hide();
        ZIndexUtils.clear(elementRef.current);
      });
      reactExports.useImperativeHandle(ref, function() {
        return {
          props,
          updateTargetEvents,
          loadTargetEvents,
          unloadTargetEvents,
          show,
          hide,
          getElement: function getElement() {
            return elementRef.current;
          },
          getTarget: function getTarget2() {
            return currentTargetRef.current;
          }
        };
      });
      var createElement = function createElement2() {
        var empty = isTargetContentEmpty(currentTargetRef.current);
        var rootProps = mergeProps2({
          id: props.id,
          className: classNames(props.className, cx("root", {
            positionState,
            classNameState
          })),
          style: props.style,
          role: "tooltip",
          "aria-hidden": visibleState,
          onMouseEnter: function onMouseEnter(e) {
            return _onMouseEnter();
          },
          onMouseLeave: function onMouseLeave(e) {
            return _onMouseLeave(e);
          }
        }, TooltipBase.getOtherProps(props), ptm("root"));
        var arrowProps = mergeProps2({
          className: cx("arrow"),
          style: sx("arrow", _objectSpread$3({}, metaData))
        }, ptm("arrow"));
        var textProps = mergeProps2({
          className: cx("text")
        }, ptm("text"));
        return /* @__PURE__ */ reactExports.createElement("div", _extends$7({
          ref: elementRef
        }, rootProps), /* @__PURE__ */ reactExports.createElement("div", arrowProps), /* @__PURE__ */ reactExports.createElement("div", _extends$7({
          ref: textRef
        }, textProps), empty && props.children));
      };
      if (visibleState) {
        var element = createElement();
        return /* @__PURE__ */ reactExports.createElement(Portal, {
          element,
          appendTo: props.appendTo,
          visible: true
        });
      }
      return null;
    }));
    Tooltip.displayName = "Tooltip";
    function _extends$6() {
      return _extends$6 = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
          var t = arguments[e];
          for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
        }
        return n;
      }, _extends$6.apply(null, arguments);
    }
    function _typeof$1(o) {
      "@babel/helpers - typeof";
      return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof$1(o);
    }
    function toPrimitive$1(t, r) {
      if ("object" != _typeof$1(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r);
        if ("object" != _typeof$1(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function toPropertyKey$1(t) {
      var i = toPrimitive$1(t, "string");
      return "symbol" == _typeof$1(i) ? i : i + "";
    }
    function _defineProperty$1(e, r, t) {
      return (r = toPropertyKey$1(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
      }) : e[r] = t, e;
    }
    var classes$1$1 = {
      root: function root2(_ref) {
        var props = _ref.props;
        return classNames("p-badge p-component", _defineProperty$1({
          "p-badge-no-gutter": ObjectUtils.isNotEmpty(props.value) && String(props.value).length === 1,
          "p-badge-dot": ObjectUtils.isEmpty(props.value),
          "p-badge-lg": props.size === "large",
          "p-badge-xl": props.size === "xlarge"
        }, "p-badge-".concat(props.severity), props.severity !== null));
      }
    };
    var styles$2 = "\n@layer primereact {\n    .p-badge {\n        display: inline-block;\n        border-radius: 10px;\n        text-align: center;\n        padding: 0 .5rem;\n    }\n    \n    .p-overlay-badge {\n        position: relative;\n    }\n    \n    .p-overlay-badge .p-badge {\n        position: absolute;\n        top: 0;\n        right: 0;\n        transform: translate(50%,-50%);\n        transform-origin: 100% 0;\n        margin: 0;\n    }\n    \n    .p-badge-dot {\n        width: .5rem;\n        min-width: .5rem;\n        height: .5rem;\n        border-radius: 50%;\n        padding: 0;\n    }\n    \n    .p-badge-no-gutter {\n        padding: 0;\n        border-radius: 50%;\n    }\n}\n";
    var BadgeBase = ComponentBase.extend({
      defaultProps: {
        __TYPE: "Badge",
        __parentMetadata: null,
        value: null,
        severity: null,
        size: null,
        style: null,
        className: null,
        children: void 0
      },
      css: {
        classes: classes$1$1,
        styles: styles$2
      }
    });
    function ownKeys$1(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread$1(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys$1(Object(t), true).forEach(function(r2) {
          _defineProperty$1(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    var Badge = /* @__PURE__ */ reactExports.memo(/* @__PURE__ */ reactExports.forwardRef(function(inProps, ref) {
      var mergeProps2 = useMergeProps();
      var context = reactExports.useContext(PrimeReactContext);
      var props = BadgeBase.getProps(inProps, context);
      var _BadgeBase$setMetaDat = BadgeBase.setMetaData(_objectSpread$1({
        props
      }, props.__parentMetadata)), ptm = _BadgeBase$setMetaDat.ptm, cx = _BadgeBase$setMetaDat.cx, isUnstyled = _BadgeBase$setMetaDat.isUnstyled;
      useHandleStyle(BadgeBase.css.styles, isUnstyled, {
        name: "badge"
      });
      var elementRef = reactExports.useRef(null);
      reactExports.useImperativeHandle(ref, function() {
        return {
          props,
          getElement: function getElement() {
            return elementRef.current;
          }
        };
      });
      var rootProps = mergeProps2({
        ref: elementRef,
        style: props.style,
        className: classNames(props.className, cx("root"))
      }, BadgeBase.getOtherProps(props), ptm("root"));
      return /* @__PURE__ */ reactExports.createElement("span", rootProps, props.value);
    }));
    Badge.displayName = "Badge";
    var classes$2 = {
      icon: function icon(_ref) {
        var props = _ref.props;
        return classNames("p-button-icon p-c", _defineProperty$1({}, "p-button-icon-".concat(props.iconPos), props.label));
      },
      loadingIcon: function loadingIcon(_ref2) {
        var props = _ref2.props, className = _ref2.className;
        return classNames(className, {
          "p-button-loading-icon": props.loading
        });
      },
      label: "p-button-label p-c",
      root: function root2(_ref3) {
        var props = _ref3.props, size = _ref3.size, disabled = _ref3.disabled;
        return classNames("p-button p-component", _defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1({
          "p-button-icon-only": (props.icon || props.loading) && !props.label && !props.children,
          "p-button-vertical": (props.iconPos === "top" || props.iconPos === "bottom") && props.label,
          "p-disabled": disabled,
          "p-button-loading": props.loading,
          "p-button-outlined": props.outlined,
          "p-button-raised": props.raised,
          "p-button-link": props.link,
          "p-button-text": props.text,
          "p-button-rounded": props.rounded,
          "p-button-loading-label-only": props.loading && !props.icon && props.label
        }, "p-button-loading-".concat(props.iconPos), props.loading && props.label), "p-button-".concat(size), size), "p-button-".concat(props.severity), props.severity), "p-button-plain", props.plain));
      }
    };
    var ButtonBase = ComponentBase.extend({
      defaultProps: {
        __TYPE: "Button",
        __parentMetadata: null,
        badge: null,
        badgeClassName: null,
        className: null,
        children: void 0,
        disabled: false,
        icon: null,
        iconPos: "left",
        label: null,
        link: false,
        loading: false,
        loadingIcon: null,
        outlined: false,
        plain: false,
        raised: false,
        rounded: false,
        severity: null,
        size: null,
        text: false,
        tooltip: null,
        tooltipOptions: null,
        visible: true
      },
      css: {
        classes: classes$2
      }
    });
    function ownKeys$2(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread$2(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys$2(Object(t), true).forEach(function(r2) {
          _defineProperty$1(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    var Button = /* @__PURE__ */ reactExports.memo(/* @__PURE__ */ reactExports.forwardRef(function(inProps, ref) {
      var mergeProps2 = useMergeProps();
      var context = reactExports.useContext(PrimeReactContext);
      var props = ButtonBase.getProps(inProps, context);
      var disabled = props.disabled || props.loading;
      var metaData = _objectSpread$2(_objectSpread$2({
        props
      }, props.__parentMetadata), {}, {
        context: {
          disabled
        }
      });
      var _ButtonBase$setMetaDa = ButtonBase.setMetaData(metaData), ptm = _ButtonBase$setMetaDa.ptm, cx = _ButtonBase$setMetaDa.cx, isUnstyled = _ButtonBase$setMetaDa.isUnstyled;
      useHandleStyle(ButtonBase.css.styles, isUnstyled, {
        name: "button",
        styled: true
      });
      var elementRef = reactExports.useRef(ref);
      reactExports.useEffect(function() {
        ObjectUtils.combinedRefs(elementRef, ref);
      }, [elementRef, ref]);
      if (props.visible === false) {
        return null;
      }
      var createIcon = function createIcon2() {
        var className = classNames("p-button-icon p-c", _defineProperty$1({}, "p-button-icon-".concat(props.iconPos), props.label));
        var iconsProps = mergeProps2({
          className: cx("icon")
        }, ptm("icon"));
        className = classNames(className, {
          "p-button-loading-icon": props.loading
        });
        var loadingIconProps = mergeProps2({
          className: cx("loadingIcon", {
            className
          })
        }, ptm("loadingIcon"));
        var icon2 = props.loading ? props.loadingIcon || /* @__PURE__ */ reactExports.createElement(SpinnerIcon, _extends$6({}, loadingIconProps, {
          spin: true
        })) : props.icon;
        return IconUtils.getJSXIcon(icon2, _objectSpread$2({}, iconsProps), {
          props
        });
      };
      var createLabel = function createLabel2() {
        var labelProps = mergeProps2({
          className: cx("label")
        }, ptm("label"));
        if (props.label) {
          return /* @__PURE__ */ reactExports.createElement("span", labelProps, props.label);
        }
        return !props.children && !props.label && /* @__PURE__ */ reactExports.createElement("span", _extends$6({}, labelProps, {
          dangerouslySetInnerHTML: {
            __html: "&nbsp;"
          }
        }));
      };
      var createBadge = function createBadge2() {
        if (props.badge) {
          var badgeProps = mergeProps2({
            className: classNames(props.badgeClassName),
            value: props.badge,
            unstyled: props.unstyled,
            __parentMetadata: {
              parent: metaData
            }
          }, ptm("badge"));
          return /* @__PURE__ */ reactExports.createElement(Badge, badgeProps, props.badge);
        }
        return null;
      };
      var showTooltip = !disabled || props.tooltipOptions && props.tooltipOptions.showOnDisabled;
      var hasTooltip = ObjectUtils.isNotEmpty(props.tooltip) && showTooltip;
      var sizeMapping = {
        large: "lg",
        small: "sm"
      };
      var size = sizeMapping[props.size];
      var icon = createIcon();
      var label = createLabel();
      var badge = createBadge();
      var defaultAriaLabel = props.label ? props.label + (props.badge ? " " + props.badge : "") : props["aria-label"];
      var rootProps = mergeProps2({
        ref: elementRef,
        "aria-label": defaultAriaLabel,
        "data-pc-autofocus": props.autoFocus,
        className: classNames(props.className, cx("root", {
          size,
          disabled
        })),
        disabled
      }, ButtonBase.getOtherProps(props), ptm("root"));
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("button", rootProps, icon, label, props.children, badge, /* @__PURE__ */ reactExports.createElement(Ripple, null)), hasTooltip && /* @__PURE__ */ reactExports.createElement(Tooltip, _extends$6({
        target: elementRef,
        content: props.tooltip,
        pt: ptm("tooltip")
      }, props.tooltipOptions)));
    }));
    Button.displayName = "Button";
    const Navbar = () => {
      const [openMenu, setOpenMenu] = reactExports.useState(false);
      const navigate = useNavigate();
      const toggleMenu = () => {
        setOpenMenu(!openMenu);
      };
      const handleNavClick = (sectionId) => {
        navigate("/");
        setTimeout(() => {
          var _a;
          (_a = document.getElementById(sectionId)) == null ? void 0 : _a.scrollIntoView({ behavior: "smooth" });
        }, 100);
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          MobileNav,
          {
            isOpen: openMenu,
            toggleMenu,
            handleNavClick
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("nav", { className: "nav-wrapper", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nav-content", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              className: "logo",
              src: "./assets/images/roushan-logo.png",
              alt: "Roushan"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                className: "menu-item",
                onClick: () => handleNavClick("home"),
                children: "Home"
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                className: "menu-item",
                onClick: () => handleNavClick("skills"),
                children: "Skills"
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                className: "menu-item",
                onClick: () => handleNavClick("work-experience"),
                children: "Work Experience"
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { className: "menu-item", to: "/projects", children: "Projects" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                className: "menu-item",
                onClick: () => handleNavClick("contact"),
                children: "Contact Me"
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "contact-btn",
                onClick: () => {
                  const link = document.createElement("a");
                  link.href = "/assets/resume/RoushanBhadaniResume.pdf";
                  link.download = "Roushan_Resume.pdf";
                  link.click();
                },
                children: "Resume"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "contact-btn",
                onClick: () => {
                  handleNavClick("contact");
                },
                children: "Hire Me"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "menu-btn", onClick: toggleMenu, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "material-symbols-outlined",
              style: { fontSize: "1.8rem" },
              children: openMenu ? "close" : "menu"
            }
          ) })
        ] }) })
      ] });
    };
    function _extends$5() {
      return _extends$5 = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
          var t = arguments[e];
          for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
        }
        return n;
      }, _extends$5.apply(null, arguments);
    }
    var ChevronDownIcon = /* @__PURE__ */ reactExports.memo(/* @__PURE__ */ reactExports.forwardRef(function(inProps, ref) {
      var pti = IconBase.getPTI(inProps);
      return /* @__PURE__ */ reactExports.createElement("svg", _extends$5({
        ref,
        width: "14",
        height: "14",
        viewBox: "0 0 14 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, pti), /* @__PURE__ */ reactExports.createElement("path", {
        d: "M7.01744 10.398C6.91269 10.3985 6.8089 10.378 6.71215 10.3379C6.61541 10.2977 6.52766 10.2386 6.45405 10.1641L1.13907 4.84913C1.03306 4.69404 0.985221 4.5065 1.00399 4.31958C1.02276 4.13266 1.10693 3.95838 1.24166 3.82747C1.37639 3.69655 1.55301 3.61742 1.74039 3.60402C1.92777 3.59062 2.11386 3.64382 2.26584 3.75424L7.01744 8.47394L11.769 3.75424C11.9189 3.65709 12.097 3.61306 12.2748 3.62921C12.4527 3.64535 12.6199 3.72073 12.7498 3.84328C12.8797 3.96582 12.9647 4.12842 12.9912 4.30502C13.0177 4.48162 12.9841 4.662 12.8958 4.81724L7.58083 10.1322C7.50996 10.2125 7.42344 10.2775 7.32656 10.3232C7.22968 10.3689 7.12449 10.3944 7.01744 10.398Z",
        fill: "currentColor"
      }));
    }));
    ChevronDownIcon.displayName = "ChevronDownIcon";
    function _extends$4() {
      return _extends$4 = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
          var t = arguments[e];
          for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
        }
        return n;
      }, _extends$4.apply(null, arguments);
    }
    var ChevronLeftIcon = /* @__PURE__ */ reactExports.memo(/* @__PURE__ */ reactExports.forwardRef(function(inProps, ref) {
      var pti = IconBase.getPTI(inProps);
      return /* @__PURE__ */ reactExports.createElement("svg", _extends$4({
        ref,
        width: "14",
        height: "14",
        viewBox: "0 0 14 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, pti), /* @__PURE__ */ reactExports.createElement("path", {
        d: "M9.61296 13C9.50997 13.0005 9.40792 12.9804 9.3128 12.9409C9.21767 12.9014 9.13139 12.8433 9.05902 12.7701L3.83313 7.54416C3.68634 7.39718 3.60388 7.19795 3.60388 6.99022C3.60388 6.78249 3.68634 6.58325 3.83313 6.43628L9.05902 1.21039C9.20762 1.07192 9.40416 0.996539 9.60724 1.00012C9.81032 1.00371 10.0041 1.08597 10.1477 1.22959C10.2913 1.37322 10.3736 1.56698 10.3772 1.77005C10.3808 1.97313 10.3054 2.16968 10.1669 2.31827L5.49496 6.99022L10.1669 11.6622C10.3137 11.8091 10.3962 12.0084 10.3962 12.2161C10.3962 12.4238 10.3137 12.6231 10.1669 12.7701C10.0945 12.8433 10.0083 12.9014 9.91313 12.9409C9.81801 12.9804 9.71596 13.0005 9.61296 13Z",
        fill: "currentColor"
      }));
    }));
    ChevronLeftIcon.displayName = "ChevronLeftIcon";
    function _extends$3() {
      return _extends$3 = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
          var t = arguments[e];
          for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
        }
        return n;
      }, _extends$3.apply(null, arguments);
    }
    var ChevronRightIcon = /* @__PURE__ */ reactExports.memo(/* @__PURE__ */ reactExports.forwardRef(function(inProps, ref) {
      var pti = IconBase.getPTI(inProps);
      return /* @__PURE__ */ reactExports.createElement("svg", _extends$3({
        ref,
        width: "14",
        height: "14",
        viewBox: "0 0 14 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, pti), /* @__PURE__ */ reactExports.createElement("path", {
        d: "M4.38708 13C4.28408 13.0005 4.18203 12.9804 4.08691 12.9409C3.99178 12.9014 3.9055 12.8433 3.83313 12.7701C3.68634 12.6231 3.60388 12.4238 3.60388 12.2161C3.60388 12.0084 3.68634 11.8091 3.83313 11.6622L8.50507 6.99022L3.83313 2.31827C3.69467 2.16968 3.61928 1.97313 3.62287 1.77005C3.62645 1.56698 3.70872 1.37322 3.85234 1.22959C3.99596 1.08597 4.18972 1.00371 4.3928 1.00012C4.59588 0.996539 4.79242 1.07192 4.94102 1.21039L10.1669 6.43628C10.3137 6.58325 10.3962 6.78249 10.3962 6.99022C10.3962 7.19795 10.3137 7.39718 10.1669 7.54416L4.94102 12.7701C4.86865 12.8433 4.78237 12.9014 4.68724 12.9409C4.59212 12.9804 4.49007 13.0005 4.38708 13Z",
        fill: "currentColor"
      }));
    }));
    ChevronRightIcon.displayName = "ChevronRightIcon";
    function _extends$2() {
      return _extends$2 = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
          var t = arguments[e];
          for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
        }
        return n;
      }, _extends$2.apply(null, arguments);
    }
    var ChevronUpIcon = /* @__PURE__ */ reactExports.memo(/* @__PURE__ */ reactExports.forwardRef(function(inProps, ref) {
      var pti = IconBase.getPTI(inProps);
      return /* @__PURE__ */ reactExports.createElement("svg", _extends$2({
        ref,
        width: "14",
        height: "14",
        viewBox: "0 0 14 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, pti), /* @__PURE__ */ reactExports.createElement("path", {
        d: "M12.2097 10.4113C12.1057 10.4118 12.0027 10.3915 11.9067 10.3516C11.8107 10.3118 11.7237 10.2532 11.6506 10.1792L6.93602 5.46461L2.22139 10.1476C2.07272 10.244 1.89599 10.2877 1.71953 10.2717C1.54307 10.2556 1.3771 10.1808 1.24822 10.0593C1.11933 9.93766 1.035 9.77633 1.00874 9.6011C0.982477 9.42587 1.0158 9.2469 1.10338 9.09287L6.37701 3.81923C6.52533 3.6711 6.72639 3.58789 6.93602 3.58789C7.14565 3.58789 7.3467 3.6711 7.49502 3.81923L12.7687 9.09287C12.9168 9.24119 13 9.44225 13 9.65187C13 9.8615 12.9168 10.0626 12.7687 10.2109C12.616 10.3487 12.4151 10.4207 12.2097 10.4113Z",
        fill: "currentColor"
      }));
    }));
    ChevronUpIcon.displayName = "ChevronUpIcon";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r);
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function toPropertyKey(t) {
      var i = toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _defineProperty(e, r, t) {
      return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
      }) : e[r] = t, e;
    }
    function _extends$1() {
      return _extends$1 = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
          var t = arguments[e];
          for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
        }
        return n;
      }, _extends$1.apply(null, arguments);
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function _arrayWithoutHoles(r) {
      if (Array.isArray(r)) return _arrayLikeToArray(r);
    }
    function _iterableToArray(r) {
      if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _toConsumableArray(r) {
      return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
    }
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _slicedToArray(r, e) {
      return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
    }
    var styles$1 = "\n@layer primereact {\n    .p-carousel {\n        display: flex;\n        flex-direction: column;\n    }\n    \n    .p-carousel-content {\n        display: flex;\n        flex-direction: column;\n        overflow: auto;\n    }\n    \n    .p-carousel-prev,\n    .p-carousel-next {\n        align-self: center;\n        flex-grow: 0;\n        flex-shrink: 0;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        overflow: hidden;\n        position: relative;\n    }\n    \n    .p-carousel-container {\n        display: flex;\n        flex-direction: row;\n    }\n    \n    .p-carousel-items-content {\n        overflow: hidden;\n        width: 100%;\n    }\n    \n    .p-carousel-items-container {\n        display: flex;\n        flex-direction: row;\n    }\n    \n    .p-carousel-indicators {\n        display: flex;\n        flex-direction: row;\n        justify-content: center;\n        flex-wrap: wrap;\n    }\n    \n    .p-carousel-indicator > button {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n    }\n    \n    /* Vertical */\n    .p-carousel-vertical .p-carousel-container {\n        flex-direction: column;\n    }\n    \n    .p-carousel-vertical .p-carousel-items-container {\n        flex-direction: column;\n        height: 100%;\n    }\n    \n    /* Keyboard Support */\n    .p-items-hidden .p-carousel-item {\n        visibility: hidden;\n    }\n    \n    .p-items-hidden .p-carousel-item.p-carousel-item-active {\n        visibility: visible;\n    }\n}\n";
    var classes$1 = {
      root: function root2(_ref) {
        var isVertical = _ref.isVertical;
        return classNames("p-carousel p-component", {
          "p-carousel-vertical": isVertical,
          "p-carousel-horizontal": !isVertical
        });
      },
      container: "p-carousel-container",
      content: "p-carousel-content",
      indicators: "p-carousel-indicators p-reset",
      header: "p-carousel-header",
      footer: "p-carousel-footer",
      itemsContainer: "p-carousel-items-container",
      itemsContent: "p-carousel-items-content",
      previousButton: function previousButton(_ref2) {
        var isDisabled = _ref2.isDisabled;
        return classNames("p-carousel-prev p-link", {
          "p-disabled": isDisabled
        });
      },
      previousButtonIcon: "p-carousel-prev-icon",
      nextButton: function nextButton(_ref3) {
        var isDisabled = _ref3.isDisabled;
        return classNames("p-carousel-next p-link", {
          "p-disabled": isDisabled
        });
      },
      nextButtonIcon: "p-carousel-next-icon",
      indicator: function indicator(_ref4) {
        var isActive = _ref4.isActive;
        return classNames("p-carousel-indicator", {
          "p-highlight": isActive
        });
      },
      indicatorButton: "p-link",
      itemCloned: function itemCloned(_ref5) {
        var props = _ref5.itemProps;
        return classNames(props.className, "p-carousel-item", {
          "p-carousel-item-active": props.active,
          "p-carousel-item-start": props.start,
          "p-carousel-item-end": props.end
        });
      },
      item: function item(_ref6) {
        var props = _ref6.itemProps;
        return classNames(props.className, "p-carousel-item", {
          "p-carousel-item-active": props.active,
          "p-carousel-item-start": props.start,
          "p-carousel-item-end": props.end
        });
      }
    };
    var inlineStyles = {
      itemsContent: function itemsContent(_ref7) {
        var height = _ref7.height;
        return {
          height
        };
      }
    };
    var CarouselBase = ComponentBase.extend({
      defaultProps: {
        __TYPE: "Carousel",
        id: null,
        value: null,
        page: 0,
        header: null,
        footer: null,
        style: null,
        className: null,
        itemTemplate: null,
        circular: false,
        showIndicators: true,
        showNavigators: true,
        autoplayInterval: 0,
        numVisible: 1,
        numScroll: 1,
        prevIcon: null,
        nextIcon: null,
        responsiveOptions: null,
        orientation: "horizontal",
        verticalViewPortHeight: "300px",
        contentClassName: null,
        containerClassName: null,
        indicatorsContentClassName: null,
        onPageChange: null,
        children: void 0
      },
      css: {
        classes: classes$1,
        styles: styles$1,
        inlineStyles
      }
    });
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    var CarouselItem = /* @__PURE__ */ reactExports.memo(function(props) {
      var mergeProps2 = useMergeProps();
      var ptm = props.ptm, cx = props.cx;
      var key = props.className && props.className === "p-carousel-item-cloned" ? "itemCloned" : "item";
      var content = props.template(props.item);
      var itemClonedProps = mergeProps2({
        className: cx(key, {
          itemProps: props
        }),
        role: props.role,
        "aria-roledescription": props.ariaRoledescription,
        "aria-label": props.ariaLabel,
        "aria-hidden": props.ariaHidden,
        "data-p-carousel-item-active": props.active,
        "data-p-carousel-item-start": props.start,
        "data-p-carousel-item-end": props.end
      }, ptm(key));
      return /* @__PURE__ */ reactExports.createElement("div", itemClonedProps, content);
    });
    var Carousel = /* @__PURE__ */ reactExports.memo(/* @__PURE__ */ reactExports.forwardRef(function(inProps, ref) {
      var mergeProps2 = useMergeProps();
      var context = reactExports.useContext(PrimeReactContext);
      var props = CarouselBase.getProps(inProps, context);
      var _React$useState = reactExports.useState(props.numVisible), _React$useState2 = _slicedToArray(_React$useState, 2), numVisibleState = _React$useState2[0], setNumVisibleState = _React$useState2[1];
      var _React$useState3 = reactExports.useState(props.numScroll), _React$useState4 = _slicedToArray(_React$useState3, 2), numScrollState = _React$useState4[0], setNumScrollState = _React$useState4[1];
      var _React$useState5 = reactExports.useState(props.page * props.numScroll * -1), _React$useState6 = _slicedToArray(_React$useState5, 2), totalShiftedItemsState = _React$useState6[0], setTotalShiftedItemsState = _React$useState6[1];
      var _React$useState7 = reactExports.useState(props.page), _React$useState8 = _slicedToArray(_React$useState7, 2), pageState = _React$useState8[0], setPageState = _React$useState8[1];
      var _CarouselBase$setMeta = CarouselBase.setMetaData({
        props,
        state: {
          numVisible: numVisibleState,
          numScroll: numScrollState,
          totalShiftedItems: totalShiftedItemsState,
          page: pageState
        }
      }), ptm = _CarouselBase$setMeta.ptm, cx = _CarouselBase$setMeta.cx, sx = _CarouselBase$setMeta.sx, isUnstyled = _CarouselBase$setMeta.isUnstyled;
      useHandleStyle(CarouselBase.css.styles, isUnstyled, {
        name: "carousel"
      });
      var elementRef = reactExports.useRef(null);
      var itemsContainerRef = reactExports.useRef(null);
      var remainingItems = reactExports.useRef(0);
      var allowAutoplay = reactExports.useRef(!!props.autoplayInterval);
      var attributeSelector = reactExports.useRef("");
      var swipeThreshold = reactExports.useRef(20);
      var startPos = reactExports.useRef(null);
      var interval = reactExports.useRef(null);
      var carouselStyle = reactExports.useRef(null);
      var indicatorContent = reactExports.useRef(null);
      var isRemainingItemsAdded = reactExports.useRef(false);
      var responsiveOptions = reactExports.useRef(null);
      var prevNumScroll = usePrevious(numScrollState);
      var prevNumVisible = usePrevious(numVisibleState);
      var prevValue = usePrevious(props.value);
      var prevPage = usePrevious(props.page);
      var isVertical = props.orientation === "vertical";
      var circular = props.circular || !!props.autoplayInterval;
      var isCircular = circular && props.value && props.value.length >= numVisibleState;
      var totalIndicators = props.value ? Math.max(Math.ceil((props.value.length - numVisibleState) / numScrollState) + 1, 0) : 0;
      var isAutoplay = totalIndicators && props.autoplayInterval && allowAutoplay.current;
      var isControlled = props.onPageChange && !isAutoplay;
      var currentPage = isControlled ? props.page : pageState;
      var _useResizeListener = useResizeListener({
        listener: function listener() {
          calculatePosition();
        },
        when: props.responsiveOptions
      }), _useResizeListener2 = _slicedToArray(_useResizeListener, 1), bindWindowResizeListener = _useResizeListener2[0];
      var step = function step2(dir, page) {
        var totalShiftedItems = totalShiftedItemsState;
        if (page != null) {
          totalShiftedItems = numScrollState * page * -1;
          if (isCircular) {
            totalShiftedItems = totalShiftedItems - numVisibleState;
          }
          isRemainingItemsAdded.current = false;
        } else {
          totalShiftedItems = totalShiftedItems + numScrollState * dir;
          if (isRemainingItemsAdded.current) {
            totalShiftedItems = totalShiftedItems + (remainingItems.current - numScrollState * dir);
            isRemainingItemsAdded.current = false;
          }
          var originalShiftedItems = isCircular ? totalShiftedItems + numVisibleState : totalShiftedItems;
          page = Math.abs(Math.floor(originalShiftedItems / numScrollState));
        }
        if (isCircular && pageState === totalIndicators - 1 && dir === -1) {
          totalShiftedItems = -1 * (props.value.length + numVisibleState);
          page = 0;
        } else if (isCircular && pageState === 0 && dir === 1) {
          totalShiftedItems = 0;
          page = totalIndicators - 1;
        } else if (page === totalIndicators - 1 && remainingItems.current > 0) {
          totalShiftedItems = totalShiftedItems + (remainingItems.current * -1 - numScrollState * dir);
          isRemainingItemsAdded.current = true;
        }
        if (itemsContainerRef.current) {
          !isUnstyled() && DomHandler.removeClass(itemsContainerRef.current, "p-items-hidden");
          changePosition(totalShiftedItems);
          itemsContainerRef.current.style.transition = "transform 500ms ease 0s";
        }
        changePage(page);
        setTotalShiftedItemsState(totalShiftedItems);
      };
      var calculatePosition = function calculatePosition2() {
        if (itemsContainerRef.current && responsiveOptions.current) {
          var windowWidth = window.innerWidth;
          var matchedResponsiveData = {
            numVisible: props.numVisible,
            numScroll: props.numScroll
          };
          for (var i = 0; i < responsiveOptions.current.length; i++) {
            var res = responsiveOptions.current[i];
            if (parseInt(res.breakpoint, 10) >= windowWidth) {
              matchedResponsiveData = res;
            }
          }
          if (numScrollState !== matchedResponsiveData.numScroll) {
            var page = Math.floor(currentPage * numScrollState / matchedResponsiveData.numScroll);
            var totalShiftedItems = matchedResponsiveData.numScroll * page * -1;
            if (isCircular) {
              totalShiftedItems = totalShiftedItems - matchedResponsiveData.numVisible;
            }
            setTotalShiftedItemsState(totalShiftedItems);
            setNumScrollState(matchedResponsiveData.numScroll);
            changePage(page);
          }
          if (numVisibleState !== matchedResponsiveData.numVisible) {
            setNumVisibleState(matchedResponsiveData.numVisible);
          }
        }
      };
      var navBackward = function navBackward2(e, page) {
        if (circular || currentPage !== 0) {
          step(1, page);
        }
        allowAutoplay.current = false;
        if (e.cancelable) {
          e.preventDefault();
        }
      };
      var navForward = function navForward2(e, page) {
        if (circular || currentPage < totalIndicators - 1) {
          step(-1, page);
        }
        allowAutoplay.current = false;
        if (e.cancelable) {
          e.preventDefault();
        }
      };
      var onIndicatorClick = function onIndicatorClick2(e, page) {
        if (page > currentPage) {
          navForward(e, page);
        } else if (page < currentPage) {
          navBackward(e, page);
        }
      };
      var onTransitionEnd = function onTransitionEnd2(e) {
        if (itemsContainerRef.current && e.propertyName === "transform") {
          DomHandler.addClass(itemsContainerRef.current, "p-items-hidden");
          itemsContainerRef.current.style.transition = "";
          if ((pageState === 0 || pageState === totalIndicators - 1) && isCircular) {
            changePosition(totalShiftedItemsState);
          }
        }
      };
      var _onTouchStart = function onTouchStart(e) {
        var touchobj = e.changedTouches[0];
        startPos.current = {
          x: touchobj.pageX,
          y: touchobj.pageY
        };
      };
      var _onTouchMove = function onTouchMove(e) {
        if (e.cancelable) {
          e.preventDefault();
        }
      };
      var _onTouchEnd = function onTouchEnd(e) {
        var touchobj = e.changedTouches[0];
        if (isVertical) {
          changePageOnTouch(e, touchobj.pageY - startPos.current.y);
        } else {
          changePageOnTouch(e, touchobj.pageX - startPos.current.x);
        }
      };
      var changePageOnTouch = function changePageOnTouch2(e, diff) {
        if (Math.abs(diff) > swipeThreshold.current) {
          if (diff < 0) {
            navForward(e);
          } else {
            navBackward(e);
          }
        }
      };
      var onIndicatorKeydown = function onIndicatorKeydown2(event) {
        switch (event.code) {
          case "ArrowRight":
            onRightKey();
            break;
          case "ArrowLeft":
            onLeftKey();
            break;
          case "Home":
            onHomeKey();
            event.preventDefault();
            break;
          case "End":
            onEndKey();
            event.preventDefault();
            break;
          case "ArrowUp":
          case "ArrowDown":
            event.preventDefault();
            break;
          case "Tab":
            onTabKey();
            break;
        }
      };
      var onRightKey = function onRightKey2() {
        var indicators2 = _toConsumableArray(DomHandler.find(indicatorContent.current, '[data-pc-section="indicator"]'));
        var activeIndex = findFocusedIndicatorIndex();
        changedFocusedIndicator(activeIndex, activeIndex + 1 === indicators2.length ? indicators2.length - 1 : activeIndex + 1);
      };
      var onLeftKey = function onLeftKey2() {
        var activeIndex = findFocusedIndicatorIndex();
        changedFocusedIndicator(activeIndex, activeIndex - 1 <= 0 ? 0 : activeIndex - 1);
      };
      var onHomeKey = function onHomeKey2() {
        var activeIndex = findFocusedIndicatorIndex();
        changedFocusedIndicator(activeIndex, 0);
      };
      var onEndKey = function onEndKey2() {
        var indicators2 = _toConsumableArray(DomHandler.find(indicatorContent.current, '[data-pc-section="indicator"]r'));
        var activeIndex = findFocusedIndicatorIndex();
        changedFocusedIndicator(activeIndex, indicators2.length - 1);
      };
      var onTabKey = function onTabKey2() {
        var indicators2 = _toConsumableArray(DomHandler.find(indicatorContent.current, '[data-pc-section="indicator"]'));
        var highlightedIndex = indicators2.findIndex(function(ind) {
          return DomHandler.getAttribute(ind, "data-p-highlight") === true;
        });
        var activeIndicator = DomHandler.findSingle(indicatorContent.current, '[data-pc-section="indicator"] > button[tabindex="0"]');
        var activeIndex = indicators2.findIndex(function(ind) {
          return ind === activeIndicator.parentElement;
        });
        indicators2[activeIndex].children[0].tabIndex = "-1";
        indicators2[highlightedIndex].children[0].tabIndex = "0";
      };
      var findFocusedIndicatorIndex = function findFocusedIndicatorIndex2() {
        var indicators2 = _toConsumableArray(DomHandler.find(indicatorContent.current, '[data-pc-section="indicator"]'));
        var activeIndicator = DomHandler.findSingle(indicatorContent.current, '[data-pc-section="indicator"] > button[tabindex="0"]');
        return indicators2.findIndex(function(ind) {
          return ind === activeIndicator.parentElement;
        });
      };
      var changedFocusedIndicator = function changedFocusedIndicator2(prevInd, nextInd) {
        var indicators2 = _toConsumableArray(DomHandler.find(indicatorContent.current, '[data-pc-section="indicator"]'));
        indicators2[prevInd].children[0].tabIndex = "-1";
        indicators2[nextInd].children[0].tabIndex = "0";
        indicators2[nextInd].children[0].focus();
      };
      var startAutoplay = function startAutoplay2() {
        if (props.autoplayInterval > 0) {
          interval.current = setInterval(function() {
            if (pageState === totalIndicators - 1) {
              step(-1, 0);
            } else {
              step(-1, pageState + 1);
            }
          }, props.autoplayInterval);
        }
      };
      var stopAutoplay = function stopAutoplay2() {
        if (interval.current) {
          clearInterval(interval.current);
        }
      };
      var createStyle = function createStyle2() {
        if (!carouselStyle.current) {
          carouselStyle.current = DomHandler.createInlineStyle(context && context.nonce || PrimeReact.nonce, context && context.styleContainer);
        }
        var innerHTML = "\n            .p-carousel[".concat(attributeSelector.current, "] .p-carousel-item {\n                flex: 1 0 ").concat(100 / numVisibleState, "%\n            }\n        ");
        if (props.responsiveOptions) {
          var comparator = ObjectUtils.localeComparator(context && context.locale || PrimeReact.locale);
          responsiveOptions.current = _toConsumableArray(props.responsiveOptions);
          responsiveOptions.current.sort(function(data1, data2) {
            var value1 = data1.breakpoint;
            var value2 = data2.breakpoint;
            return ObjectUtils.sort(value1, value2, -1, comparator, context && context.nullSortOrder || PrimeReact.nullSortOrder);
          });
          for (var i = 0; i < responsiveOptions.current.length; i++) {
            var res = responsiveOptions.current[i];
            innerHTML = innerHTML + "\n                    @media screen and (max-width: ".concat(res.breakpoint, ") {\n                        .p-carousel[").concat(attributeSelector.current, "] .p-carousel-item {\n                            flex: 1 0 ").concat(100 / res.numVisible, "%\n                        }\n                    }\n                ");
          }
          calculatePosition();
        }
        carouselStyle.current.innerHTML = innerHTML;
      };
      var destroyStyle = function destroyStyle2() {
        carouselStyle.current = DomHandler.removeInlineStyle(carouselStyle.current);
      };
      var changePosition = function changePosition2(totalShiftedItems) {
        if (itemsContainerRef.current) {
          itemsContainerRef.current.style.transform = isVertical ? "translate3d(0, ".concat(totalShiftedItems * (100 / numVisibleState), "%, 0)") : "translate3d(".concat(totalShiftedItems * (100 / numVisibleState), "%, 0, 0)");
        }
      };
      var changePage = function changePage2(page) {
        !isControlled && setPageState(page);
        props.onPageChange && props.onPageChange({
          page
        });
      };
      reactExports.useImperativeHandle(ref, function() {
        return {
          props,
          startAutoplay,
          stopAutoplay,
          getElement: function getElement() {
            return elementRef.current;
          }
        };
      });
      useMountEffect(function() {
        if (elementRef.current) {
          attributeSelector.current = UniqueComponentId();
          elementRef.current.setAttribute(attributeSelector.current, "");
        }
        if (!carouselStyle.current) {
          calculatePosition();
          changePosition(totalShiftedItemsState);
          bindWindowResizeListener();
        }
      });
      useUpdateEffect(function() {
        var stateChanged = false;
        var totalShiftedItems = totalShiftedItemsState;
        createStyle();
        if (props.autoplayInterval) {
          stopAutoplay();
        }
        if (prevNumScroll !== numScrollState || prevNumVisible !== numVisibleState || props.value && prevValue && prevValue.length !== props.value.length) {
          remainingItems.current = (props.value.length - numVisibleState) % numScrollState;
          var page = currentPage;
          if (totalIndicators !== 0 && page >= totalIndicators) {
            page = totalIndicators - 1;
            changePage(page);
            stateChanged = true;
          }
          totalShiftedItems = page * numScrollState * -1;
          if (isCircular) {
            totalShiftedItems = totalShiftedItems - numVisibleState;
          }
          if (page === totalIndicators - 1 && remainingItems.current > 0) {
            totalShiftedItems = totalShiftedItems + (-1 * remainingItems.current + numScrollState);
            isRemainingItemsAdded.current = true;
          } else {
            isRemainingItemsAdded.current = false;
          }
          if (totalShiftedItems !== totalShiftedItemsState) {
            setTotalShiftedItemsState(totalShiftedItems);
            stateChanged = true;
          }
          changePosition(totalShiftedItems);
        }
        if (isCircular) {
          if (pageState === 0) {
            totalShiftedItems = -1 * numVisibleState;
          } else if (totalShiftedItems === 0) {
            totalShiftedItems = -1 * props.value.length;
            if (remainingItems.current > 0) {
              isRemainingItemsAdded.current = true;
            }
          }
          if (totalShiftedItems !== totalShiftedItemsState) {
            setTotalShiftedItemsState(totalShiftedItems);
            stateChanged = true;
          }
        }
        if (prevPage !== props.page) {
          if (props.page > prevPage && props.page <= totalIndicators - 1) {
            step(-1, props.page);
          } else if (props.page < prevPage) {
            step(1, props.page);
          }
        }
        if (!stateChanged && isAutoplay) {
          startAutoplay();
        }
        return function() {
          if (props.autoplayInterval) {
            stopAutoplay();
          }
          destroyStyle();
        };
      });
      var ariaSlideNumber = function ariaSlideNumber2(value) {
        return ariaLabel("slideNumber", {
          slideNumber: value
        });
      };
      var createItems = function createItems2() {
        if (props.value && props.value.length) {
          var clonedItemsForStarting = null;
          var clonedItemsForFinishing = null;
          if (isCircular) {
            var clonedElements = null;
            clonedElements = props.value.slice(-1 * numVisibleState);
            clonedItemsForStarting = clonedElements.map(function(item, index) {
              var isActive = totalShiftedItemsState * -1 === props.value.length + numVisibleState;
              var start = index === 0;
              var end = index === clonedElements.length - 1;
              var key = index + "_scloned";
              return /* @__PURE__ */ reactExports.createElement(CarouselItem, {
                key,
                className: "p-carousel-item-cloned",
                template: props.itemTemplate,
                item,
                active: isActive,
                start,
                end,
                ptm,
                cx
              });
            });
            clonedElements = props.value.slice(0, numVisibleState);
            clonedItemsForFinishing = clonedElements.map(function(item, index) {
              var isActive = totalShiftedItemsState === 0;
              var start = index === 0;
              var end = index === clonedElements.length - 1;
              var key = index + "_fcloned";
              return /* @__PURE__ */ reactExports.createElement(CarouselItem, {
                key,
                className: "p-carousel-item-cloned",
                template: props.itemTemplate,
                item,
                active: isActive,
                start,
                end,
                ptm,
                cx
              });
            });
          }
          var items = props.value.map(function(item, index) {
            var firstIndex = isCircular ? -1 * (totalShiftedItemsState + numVisibleState) : totalShiftedItemsState * -1;
            var lastIndex = firstIndex + numVisibleState - 1;
            var isActive = firstIndex <= index && lastIndex >= index;
            var start = firstIndex === index;
            var end = lastIndex === index;
            var ariaHidden = firstIndex > index || lastIndex < index ? true : void 0;
            var ariaLabel2 = ariaSlideNumber(index);
            var ariaRoledescription = localeOption("aria") ? localeOption("aria").slide : void 0;
            return /* @__PURE__ */ reactExports.createElement(CarouselItem, {
              key: index,
              template: props.itemTemplate,
              item,
              active: isActive,
              start,
              ariaHidden,
              ariaLabel: ariaLabel2,
              ariaRoledescription,
              role: "group",
              end,
              ptm,
              cx
            });
          });
          return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, clonedItemsForStarting, items, clonedItemsForFinishing);
        }
      };
      var createHeader = function createHeader2() {
        if (props.header) {
          var headerProps = mergeProps2({
            className: cx("header")
          }, ptm("header"));
          return /* @__PURE__ */ reactExports.createElement("div", headerProps, props.header);
        }
        return null;
      };
      var createFooter = function createFooter2() {
        if (props.footer) {
          var footerProps = mergeProps2({
            className: cx("footer")
          }, ptm("footer"));
          return /* @__PURE__ */ reactExports.createElement("div", footerProps, props.footer);
        }
        return null;
      };
      var createContent = function createContent2() {
        var items = createItems();
        var height = isVertical ? props.verticalViewPortHeight : "auto";
        var backwardNavigator = createBackwardNavigator();
        var forwardNavigator = createForwardNavigator();
        var itemsContentProps = mergeProps2({
          className: cx("itemsContent"),
          style: sx("itemsContent", {
            height
          }),
          onTouchStart: function onTouchStart(e) {
            return _onTouchStart(e);
          },
          onTouchMove: function onTouchMove(e) {
            return _onTouchMove(e);
          },
          onTouchEnd: function onTouchEnd(e) {
            return _onTouchEnd(e);
          }
        }, ptm("itemsContent"));
        var containerProps = mergeProps2({
          className: classNames(props.containerClassName, cx("container")),
          "aria-live": allowAutoplay.current ? "polite" : "off"
        }, ptm("container"));
        var itemsContainerProps = mergeProps2({
          className: cx("itemsContainer"),
          onTransitionEnd
        }, ptm("itemsContainer"));
        return /* @__PURE__ */ reactExports.createElement("div", containerProps, backwardNavigator, /* @__PURE__ */ reactExports.createElement("div", itemsContentProps, /* @__PURE__ */ reactExports.createElement("div", _extends$1({
          ref: itemsContainerRef
        }, itemsContainerProps), items)), forwardNavigator);
      };
      var createBackwardNavigator = function createBackwardNavigator2() {
        if (props.showNavigators) {
          var isDisabled = (!circular || props.value && props.value.length < numVisibleState) && currentPage === 0;
          var previousButtonIconProps = mergeProps2({
            className: cx("previousButtonIcon")
          }, ptm("previousButtonIcon"));
          var icon = isVertical ? props.prevIcon || /* @__PURE__ */ reactExports.createElement(ChevronUpIcon, previousButtonIconProps) : props.prevIcon || /* @__PURE__ */ reactExports.createElement(ChevronLeftIcon, previousButtonIconProps);
          var backwardNavigatorIcon = IconUtils.getJSXIcon(icon, _objectSpread({}, previousButtonIconProps), {
            props
          });
          var previousButtonProps = mergeProps2({
            type: "button",
            className: cx("previousButton", {
              isDisabled
            }),
            onClick: function onClick(e) {
              return navBackward(e);
            },
            disabled: isDisabled,
            "aria-label": localeOption("aria") ? localeOption("aria").prevPageLabel : void 0,
            "data-pc-group-section": "navigator"
          }, ptm("previousButton"));
          return /* @__PURE__ */ reactExports.createElement("button", previousButtonProps, backwardNavigatorIcon, /* @__PURE__ */ reactExports.createElement(Ripple, null));
        }
        return null;
      };
      var createForwardNavigator = function createForwardNavigator2() {
        if (props.showNavigators) {
          var isDisabled = (!circular || props.value && props.value.length < numVisibleState) && (currentPage === totalIndicators - 1 || totalIndicators === 0);
          var nextButtonIconProps = mergeProps2({
            className: cx("nextButtonIcon")
          }, ptm("nextButtonIcon"));
          var icon = isVertical ? props.nextIcon || /* @__PURE__ */ reactExports.createElement(ChevronDownIcon, nextButtonIconProps) : props.nextIcon || /* @__PURE__ */ reactExports.createElement(ChevronRightIcon, nextButtonIconProps);
          var forwardNavigatorIcon = IconUtils.getJSXIcon(icon, _objectSpread({}, nextButtonIconProps), {
            props
          });
          var nextButtonProps = mergeProps2({
            type: "button",
            className: cx("nextButton", {
              isDisabled
            }),
            onClick: function onClick(e) {
              return navForward(e);
            },
            disabled: isDisabled,
            "aria-label": localeOption("aria") ? localeOption("aria").nextPageLabel : void 0,
            "data-pc-group-section": "navigator"
          }, ptm("nextButton"));
          return /* @__PURE__ */ reactExports.createElement("button", nextButtonProps, forwardNavigatorIcon, /* @__PURE__ */ reactExports.createElement(Ripple, null));
        }
        return null;
      };
      var ariaPageLabel = function ariaPageLabel2(value) {
        return ariaLabel("pageLabel", {
          page: value
        });
      };
      var createIndicator = function createIndicator2(index) {
        var isActive = currentPage === index;
        var getPTOptions = function getPTOptions2(key2) {
          return ptm(key2, {
            context: {
              active: isActive
            }
          });
        };
        var key = "carousel-indicator-" + index;
        var indicatorProps = mergeProps2({
          className: cx("indicator", {
            isActive
          }),
          "data-p-highlight": isActive
        }, getPTOptions("indicator"));
        var indicatorButtonProps = mergeProps2({
          type: "button",
          className: cx("indicatorButton"),
          tabIndex: currentPage === index ? "0" : "-1",
          onClick: function onClick(e) {
            return onIndicatorClick(e, index);
          },
          "aria-label": ariaPageLabel(index + 1),
          "aria-current": currentPage === index ? "page" : void 0
        }, getPTOptions("indicatorButton"));
        return /* @__PURE__ */ reactExports.createElement("li", _extends$1({}, indicatorProps, {
          key
        }), /* @__PURE__ */ reactExports.createElement("button", indicatorButtonProps, /* @__PURE__ */ reactExports.createElement(Ripple, null)));
      };
      var createIndicators = function createIndicators2() {
        if (props.showIndicators) {
          var _indicators = [];
          for (var i = 0; i < totalIndicators; i++) {
            _indicators.push(createIndicator(i));
          }
          var indicatorsProps = mergeProps2({
            ref: indicatorContent,
            className: classNames(props.indicatorsContentClassName, cx("indicators")),
            onKeyDown: onIndicatorKeydown
          }, ptm("indicators"));
          return /* @__PURE__ */ reactExports.createElement("ul", indicatorsProps, _indicators);
        }
        return null;
      };
      var content = createContent();
      var indicators = createIndicators();
      var header = createHeader();
      var footer = createFooter();
      var rootProps = mergeProps2({
        id: props.id,
        ref: elementRef,
        className: classNames(props.className, cx("root", {
          isVertical
        })),
        style: props.style,
        role: "region"
      }, CarouselBase.getOtherProps(props), ptm("root"));
      var contentProps = mergeProps2({
        className: classNames(props.contentClassName, cx("content"))
      }, ptm("content"));
      return /* @__PURE__ */ reactExports.createElement("div", rootProps, header, /* @__PURE__ */ reactExports.createElement("div", contentProps, content, indicators), footer);
    }));
    CarouselItem.displayName = "CarouselItem";
    Carousel.displayName = "Carousel";
    const techIcons = [
      { image: "./assets/images/physics.png", alt: "React" },
      { image: "./assets/images/html.png", alt: "HTML" },
      { image: "./assets/images/css-3.png", alt: "CSS" },
      { image: "./assets/images/js-file.png", alt: "JavaScript" },
      { image: "./assets/images/redux.png", alt: "React" },
      { image: "./assets/images/nodejs.png", alt: "HTML" },
      { image: "./assets/images/reactnative.png", alt: "CSS" },
      { image: "./assets/images/typescript.png", alt: "JavaScript" },
      { image: "./assets/images/reactnativepapersvg.svg", alt: "React" }
    ];
    const techTemplate = (item) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex align-items-center justify-content-center tech-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: item.image, alt: item.alt, className: "tech-image" }) });
    };
    const Hero = () => {
      const responsiveOptions = [
        {
          breakpoint: "1400px",
          numVisible: 5,
          numScroll: 1
        },
        {
          breakpoint: "1199px",
          numVisible: 4,
          numScroll: 1
        },
        {
          breakpoint: "991px",
          numVisible: 3,
          numScroll: 1
        },
        {
          breakpoint: "767px",
          numVisible: 2,
          numScroll: 1
        },
        {
          breakpoint: "480px",
          numVisible: 2,
          numScroll: 1
        }
      ];
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "hero-container", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hero-content", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { children: [
              "Hi, I'm ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "hero-name", children: "ROUSHAN" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Transforming Ideas into Digital Reality" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "experience-text", children: "Working Experience" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "experience-text", children: [
              "Contact Number: ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "tel:7484030370", className: "highlight", children: "7484030370" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "first-p", children: "Innovative Frontend Creator | Building Sleek and User-Friendly Web Applications" }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hero-img", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "./assets/images/boss.png", alt: "Avtar" }) }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tech-carousel-wrapper", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tech-carousel", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Carousel,
          {
            value: techIcons,
            numVisible: 6,
            numScroll: 1,
            autoplayInterval: 2e3,
            showIndicators: false,
            circular: true,
            itemTemplate: techTemplate,
            responsiveOptions
          }
        ) }) })
      ] });
    };
    function _0x5ebb(_0x3cf5c1, _0x507a8a) {
      const _0x550f6e = _0x550f();
      return _0x5ebb = function(_0x5ebbcf, _0x23893f) {
        _0x5ebbcf = _0x5ebbcf - 452;
        let _0x15b482 = _0x550f6e[_0x5ebbcf];
        return _0x15b482;
      }, _0x5ebb(_0x3cf5c1, _0x507a8a);
    }
    const _0x48d7e3 = _0x5ebb;
    (function(_0x33da77, _0x5f2aff) {
      const _0xee9318 = _0x5ebb, _0x309e3c = _0x33da77();
      while (!![]) {
        try {
          const _0x1140c0 = parseInt(_0xee9318(464)) / 1 + parseInt(_0xee9318(485)) / 2 + parseInt(_0xee9318(493)) / 3 * (-parseInt(_0xee9318(521)) / 4) + parseInt(_0xee9318(463)) / 5 * (-parseInt(_0xee9318(524)) / 6) + -parseInt(_0xee9318(517)) / 7 + parseInt(_0xee9318(499)) / 8 + parseInt(_0xee9318(512)) / 9 * (-parseInt(_0xee9318(474)) / 10);
          if (_0x1140c0 === _0x5f2aff) break;
          else _0x309e3c["push"](_0x309e3c["shift"]());
        } catch (_0x337810) {
          _0x309e3c["push"](_0x309e3c["shift"]());
        }
      }
    })(_0x550f, 163701);
    function _0x550f() {
      const _0x3e8dbd = ["Typescript", "Soft Skills", "Advanced", "Node.js", "Created a mobile student portal for course access, mentor interaction, and exams. Integrated APIs for real-time data syncing, managed state with Recoil, and styled with React Native Paper.", "Movieland", "Built an educational platform for course browsing and enrollment with Redux state management. Integrated backend APIs for dynamic course and user data.", "655685Dwdlkj", "323416JFbHXG", "React JS", "./assets/images/clickandsend.jpeg", "Working on TechHut Academy's web and mobile platforms to enhance user experience and performance.", "85%", "Techhut Academy", "Designed and implemented backend logic using Java, JSP, and Servlets.", "React JS + Redux + Bootstrap + NodeJs", "80%", "Developed responsive web applications using React.js, Redux, HTML5, CSS3, and JavaScript.", "222230uDbgJZ", "Integrating component libraries like React Native Paper to deliver clean and consistent design across mobile apps.", "https://www.techhutacademy.com/", "./assets/images/creative.png", "./assets/images/workinprogress.jpg", "Gained hands-on experience in full-stack development by building end-to-end projects.", "Frontend", "60%", "Bootstrap (CSS)", "Responsive Design", "Tailwind (CSS)", "434766vwTODA", "React Native + Recoil + React Native Paper", "https://movieland-six-omega.vercel.app/", "Built reusable UI components and managed state effectively using Redux.", "./assets/images/screwdriver.png", "./assets/images/backend.png", "Java", "React.js", "81wTITiq", "Software Developer at Webpristine Technologies", "Framework", "90%", "January 2025 - Present", "https://portal.techhutacademy.com/", "2336144FbVgVP", "Attention to Detail", "Click and Send", "Worked as part of a team delivering scalable UI components for the UK-based application Click and Send.", "./assets/images/tictactoe.jpeg", "React Native Paper", "React Native", "Fullstack Java + ReactJS Training at DUCAT IT", "https://tic-tac-toe-game-nine-gray.vercel.app/", "Git & GitHub", "Visual Studio Code", "React JS + API integration", "Integrated frontend with backend services using RESTful APIs.", "63QSCBdr", "Next JS + Redux + MaterialUI", "Developed a delivery job platform with real-time driver matching, job posting, and tracking. Integrated secure authentication, REST APIs, and a responsive Material UI design.", "70%", "Optimizing builds and development workflow using Webpack.", "417053bkloly", "A full-stack API Market Place for students to buy and practice APIs with guided docs. Built with React, Redux Toolkit, PrimeReact, and Node.js, handling both frontend and backend with auth, API access, and purchase tracking.", "Basic", "Developed an e-commerce store for replica weapons with product catalog, cart, and checkout flow. Integrated Node.js APIs and managed state using Redux.", "47828MemLfd", "75%", "Techhut Student", "6PsrWrn", "Intermediate", "July 2024 - January 2025", "Collaboration", "TIC TAC TOE", "./assets/images/movieland.jpeg"];
      _0x550f = function() {
        return _0x3e8dbd;
      };
      return _0x550f();
    }
    const SKILLS = [{ "title": _0x48d7e3(480), "icon": "./assets/images/front-end.png", "skills": [{ "skill": _0x48d7e3(492), "percentage": _0x48d7e3(496) }, { "skill": "JavaScript", "percentage": _0x48d7e3(522) }, { "skill": _0x48d7e3(505), "percentage": _0x48d7e3(515) }, { "skill": _0x48d7e3(456), "percentage": _0x48d7e3(472) }, { "skill": "CSS3", "percentage": _0x48d7e3(496) }] }, { "title": "Backend", "icon": _0x48d7e3(490), "skills": [{ "skill": _0x48d7e3(459), "percentage": "80%" }, { "skill": _0x48d7e3(491), "percentage": "65%" }] }, { "title": _0x48d7e3(495), "icon": _0x48d7e3(489), "skills": [{ "skill": "Prime React", "percentage": _0x48d7e3(522) }, { "skill": _0x48d7e3(504), "percentage": _0x48d7e3(515) }, { "skill": "Prime Flex", "percentage": _0x48d7e3(472) }, { "skill": _0x48d7e3(482), "percentage": "80%" }, { "skill": _0x48d7e3(484), "percentage": _0x48d7e3(515) }] }, { "title": "Tools", "icon": _0x48d7e3(489), "skills": [{ "skill": _0x48d7e3(508), "percentage": _0x48d7e3(472) }, { "skill": _0x48d7e3(509), "percentage": _0x48d7e3(522) }, { "skill": "Webpack", "percentage": _0x48d7e3(481) }, { "skill": _0x48d7e3(483), "percentage": _0x48d7e3(515) }] }, { "title": _0x48d7e3(457), "icon": _0x48d7e3(477), "skills": [{ "skill": "Problem-Solving", "percentage": _0x48d7e3(472) }, { "skill": _0x48d7e3(453), "percentage": _0x48d7e3(468) }, { "skill": _0x48d7e3(500), "percentage": "75%" }] }];
    const WORK_EXPERIENCE = [{ "title": _0x48d7e3(494), "date": _0x48d7e3(497), "responsibility": [_0x48d7e3(502), _0x48d7e3(467), "Building and maintaining responsive UIs using React.js, React Native, PrimeReact, Bootstrap, and PrimeFlex.", "Managing application state effectively using Redux Toolkit and Recoil.", "Handling asynchronous API requests using Axios and `useMutation` for robust data handling.", _0x48d7e3(516), _0x48d7e3(475)] }, { "title": _0x48d7e3(506), "date": _0x48d7e3(452), "responsibility": [_0x48d7e3(473), _0x48d7e3(488), _0x48d7e3(511), _0x48d7e3(470), "Worked with Hibernate for efficient database interaction and ORM mapping.", "Followed MVC architecture to structure and organize the application effectively.", _0x48d7e3(479)] }];
    const projectData = [{ "id": 1, "title": "API Market Place", "subtitle": "React JS + Redux Toolkit + Prime React + Prime Flex + Node JS", "image": _0x48d7e3(478), "company": ![], "level": _0x48d7e3(458), "currentlyWorking": !![], "link": "", "description": _0x48d7e3(518) }, { "id": 2, "title": _0x48d7e3(501), "subtitle": _0x48d7e3(513), "image": _0x48d7e3(466), "company": !![], "level": "Advanced", "currentlyWorking": ![], "link": "https://www.clicknsend.co.uk/", "description": _0x48d7e3(514) }, { "id": 3, "title": _0x48d7e3(469), "subtitle": "React JS + Bootstrap + Redux", "image": "./assets/images/Techhut.jpeg", "company": !![], "level": _0x48d7e3(525), "currentlyWorking": ![], "link": _0x48d7e3(476), "description": _0x48d7e3(462) }, { "id": 4, "title": _0x48d7e3(523), "subtitle": _0x48d7e3(486), "image": "./assets/images/TechhutStudent.jpeg", "company": !![], "level": _0x48d7e3(458), "currentlyWorking": ![], "link": _0x48d7e3(498), "description": _0x48d7e3(460) }, { "id": 5, "title": "Replica Weapon Store", "subtitle": _0x48d7e3(471), "image": "./assets/images/replicaweaponsestore.jpeg", "company": ![], "level": _0x48d7e3(525), "currentlyWorking": ![], "link": "https://replicaweaponstore.vercel.app/", "description": _0x48d7e3(520) }, { "id": 6, "title": _0x48d7e3(461), "subtitle": _0x48d7e3(510), "image": _0x48d7e3(455), "company": ![], "level": "Basic", "currentlyWorking": ![], "link": _0x48d7e3(487), "description": "Built a movie search application using the OMDb API. Integrated API calls for fetching movie data and implemented dynamic search with responsive design." }, { "id": 7, "title": _0x48d7e3(454), "subtitle": _0x48d7e3(465), "image": _0x48d7e3(503), "company": ![], "level": _0x48d7e3(519), "currentlyWorking": ![], "link": _0x48d7e3(507), "description": "Created an interactive Tic Tac Toe game with win detection and game reset functionality. Designed a clean, responsive interface in React." }];
    const SkillsCard = ({ title, iconUrl, isActive, onClick }) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `skills-card ${isActive ? "active" : ""}`, onClick: () => onClick(), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "skill-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: iconUrl, alt: title }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: title })
      ] });
    };
    const SkillsInfoCard = ({ heading, skills }) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "skills-info-card", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h6", { children: heading }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "skills-info-content", children: skills.map((item, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(React.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "skill-info", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: item.skill }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "percentage", children: item.percentage })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "skill-progress-bg", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "skill-progress", style: { width: item.percentage } }) })
        ] }, `skill_${index}`)) })
      ] });
    };
    const Skills = () => {
      const [selectSkills, setSelectSkills] = reactExports.useState(SKILLS[0]);
      const [isMobile, setIsMobile] = reactExports.useState(window.innerWidth <= 768);
      const [openSkill, setOpenSkill] = reactExports.useState(SKILLS[0].title);
      reactExports.useEffect(() => {
        const handleResize = () => {
          setIsMobile(window.innerWidth <= 768);
        };
        window.addEventListener("resize", handleResize);
        return () => window.removeEventListener("resize", handleResize);
      }, []);
      const handleSelectSkill = (title) => {
        if (isMobile) {
          setOpenSkill((prev) => prev === title ? null : title);
        } else {
          const skill = SKILLS.find((item) => item.title === title);
          setSelectSkills(skill);
        }
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "skills-container", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "skills-title", children: "Technical Proficiency" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "skills-content", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "skills", children: SKILLS.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "skill-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              SkillsCard,
              {
                iconUrl: item.icon,
                title: item.title,
                isActive: isMobile ? openSkill === item.title : selectSkills.title === item.title,
                onClick: () => handleSelectSkill(item.title)
              }
            ),
            isMobile && openSkill === item.title && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mobile-skill-info", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SkillsInfoCard, { heading: item.title, skills: item.skills }) })
          ] }, item.title)) }),
          !isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "skills-info", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SkillsInfoCard, { heading: selectSkills.title, skills: selectSkills.skills }) })
        ] })
      ] });
    };
    const ExperienceCard = ({ details }) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "work-exp-card", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h6", { children: details.title }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "work-duration", children: details.date }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { children: details.responsibility.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: item }, item)) })
      ] });
    };
    const WorkExperience = () => {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "experience-container", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { children: "Work Experience" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "experience-grid", children: WORK_EXPERIENCE.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsx(ExperienceCard, { details: item }, item.title)) })
      ] });
    };
    const ContactInfoCard = ({ iconUrl, text, url }) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contact-details-card", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "icon", children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: iconUrl, alt: text }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: text })
      ] });
    };
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
    }
    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
      });
    }
    function mergeObject(target, source, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
        Object.keys(target).forEach(function(key) {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
      }
      Object.keys(source).forEach(function(key) {
        if (!options.isMergeableObject(source[key]) || !target[key]) {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        } else {
          destination[key] = deepmerge(target[key], source[key], options);
        }
      });
      return destination;
    }
    function deepmerge(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }
    deepmerge.all = function deepmergeAll(array2, options) {
      if (!Array.isArray(array2)) {
        throw new Error("first argument should be an array");
      }
      return array2.reduce(function(prev, next) {
        return deepmerge(prev, next, options);
      }, {});
    };
    var deepmerge_1 = deepmerge;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root$1 = freeGlobal || freeSelf || Function("return this")();
    var Symbol$1 = root$1.Symbol;
    var objectProto$d = Object.prototype;
    var hasOwnProperty$a = objectProto$d.hasOwnProperty;
    var nativeObjectToString$1 = objectProto$d.toString;
    var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty$a.call(value, symToStringTag$1), tag = value[symToStringTag$1];
      try {
        value[symToStringTag$1] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString$1.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }
      return result;
    }
    var objectProto$c = Object.prototype;
    var nativeObjectToString = objectProto$c.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var objectTag$3 = "[object Object]";
    var funcProto$2 = Function.prototype, objectProto$b = Object.prototype;
    var funcToString$2 = funcProto$2.toString;
    var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
    var objectCtorString$1 = funcToString$2.call(Object);
    function isPlainObject$2(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag$3) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty$9.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString$2.call(Ctor) == objectCtorString$1;
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function assocIndexOf(array2, key) {
      var length = array2.length;
      while (length--) {
        if (eq(array2[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function isObject$2(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
    function isFunction$2(value) {
      if (!isObject$2(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
    }
    var coreJsData = root$1["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    var funcProto$1 = Function.prototype;
    var funcToString$1 = funcProto$1.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString$1.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype, objectProto$a = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty$8).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject$2(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction$2(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function getValue(object2, key) {
      return object2 == null ? void 0 : object2[key];
    }
    function getNative(object2, key) {
      var value = getValue(object2, key);
      return baseIsNative(value) ? value : void 0;
    }
    var Map$1 = getNative(root$1, "Map");
    var nativeCreate = getNative(Object, "create");
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
    var objectProto$9 = Object.prototype;
    var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED$1 ? void 0 : result;
      }
      return hasOwnProperty$7.call(data, key) ? data[key] : void 0;
    }
    var objectProto$8 = Object.prototype;
    var hasOwnProperty$6 = objectProto$8.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty$6.call(data, key);
    }
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map$1 || ListCache)(),
        "string": new Hash()
      };
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayEach(array2, iteratee) {
      var index = -1, length = array2 == null ? 0 : array2.length;
      while (++index < length) {
        if (iteratee(array2[index], index, array2) === false) {
          break;
        }
      }
      return array2;
    }
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    function baseAssignValue(object2, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object2, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object2[key] = value;
      }
    }
    var objectProto$7 = Object.prototype;
    var hasOwnProperty$5 = objectProto$7.hasOwnProperty;
    function assignValue(object2, key, value) {
      var objValue = object2[key];
      if (!(hasOwnProperty$5.call(object2, key) && eq(objValue, value)) || value === void 0 && !(key in object2)) {
        baseAssignValue(object2, key, value);
      }
    }
    function copyObject(source, props, object2, customizer) {
      var isNew = !object2;
      object2 || (object2 = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object2, key, newValue);
        } else {
          assignValue(object2, key, newValue);
        }
      }
      return object2;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    var argsTag$2 = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag$2;
    }
    var objectProto$6 = Object.prototype;
    var hasOwnProperty$4 = objectProto$6.hasOwnProperty;
    var propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable;
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty$4.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
    };
    var isArray = Array.isArray;
    function stubFalse() {
      return false;
    }
    var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
    var Buffer$1 = moduleExports$2 ? root$1.Buffer : void 0;
    var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    var MAX_SAFE_INTEGER$1 = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER$1 : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$1 = "[object Error]", funcTag$1 = "[object Function]", mapTag$4 = "[object Map]", numberTag$2 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$2 = "[object RegExp]", setTag$4 = "[object Set]", stringTag$2 = "[object String]", weakMapTag$2 = "[object WeakMap]";
    var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
    typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] = typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$4] = typedArrayTags[numberTag$2] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$2] = typedArrayTags[setTag$4] = typedArrayTags[stringTag$2] = typedArrayTags[weakMapTag$2] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
    var freeProcess = moduleExports$1 && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    var objectProto$5 = Object.prototype;
    var hasOwnProperty$3 = objectProto$5.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty$3.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    var objectProto$4 = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$4;
      return value === proto;
    }
    var nativeKeys = overArg(Object.keys, Object);
    var objectProto$3 = Object.prototype;
    var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
    function baseKeys(object2) {
      if (!isPrototype(object2)) {
        return nativeKeys(object2);
      }
      var result = [];
      for (var key in Object(object2)) {
        if (hasOwnProperty$2.call(object2, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction$2(value);
    }
    function keys(object2) {
      return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
    }
    function baseAssign(object2, source) {
      return object2 && copyObject(source, keys(source), object2);
    }
    function nativeKeysIn(object2) {
      var result = [];
      if (object2 != null) {
        for (var key in Object(object2)) {
          result.push(key);
        }
      }
      return result;
    }
    var objectProto$2 = Object.prototype;
    var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
    function baseKeysIn(object2) {
      if (!isObject$2(object2)) {
        return nativeKeysIn(object2);
      }
      var isProto = isPrototype(object2), result = [];
      for (var key in object2) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty$1.call(object2, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function keysIn(object2) {
      return isArrayLike(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
    }
    function baseAssignIn(object2, source) {
      return object2 && copyObject(source, keysIn(source), object2);
    }
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root$1.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    function copyArray(source, array2) {
      var index = -1, length = source.length;
      array2 || (array2 = Array(length));
      while (++index < length) {
        array2[index] = source[index];
      }
      return array2;
    }
    function arrayFilter(array2, predicate) {
      var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array2[index];
        if (predicate(value, index, array2)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function stubArray() {
      return [];
    }
    var objectProto$1 = Object.prototype;
    var propertyIsEnumerable = objectProto$1.propertyIsEnumerable;
    var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object2) {
      if (object2 == null) {
        return [];
      }
      object2 = Object(object2);
      return arrayFilter(nativeGetSymbols$1(object2), function(symbol) {
        return propertyIsEnumerable.call(object2, symbol);
      });
    };
    function copySymbols(source, object2) {
      return copyObject(source, getSymbols(source), object2);
    }
    function arrayPush(array2, values) {
      var index = -1, length = values.length, offset = array2.length;
      while (++index < length) {
        array2[offset + index] = values[index];
      }
      return array2;
    }
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object2) {
      var result = [];
      while (object2) {
        arrayPush(result, getSymbols(object2));
        object2 = getPrototype(object2);
      }
      return result;
    };
    function copySymbolsIn(source, object2) {
      return copyObject(source, getSymbolsIn(source), object2);
    }
    function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
      var result = keysFunc(object2);
      return isArray(object2) ? result : arrayPush(result, symbolsFunc(object2));
    }
    function getAllKeys(object2) {
      return baseGetAllKeys(object2, keys, getSymbols);
    }
    function getAllKeysIn(object2) {
      return baseGetAllKeys(object2, keysIn, getSymbolsIn);
    }
    var DataView = getNative(root$1, "DataView");
    var Promise$1 = getNative(root$1, "Promise");
    var Set$1 = getNative(root$1, "Set");
    var WeakMap$1 = getNative(root$1, "WeakMap");
    var mapTag$3 = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag$3 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
    var dataViewTag$2 = "[object DataView]";
    var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$2 || Map$1 && getTag(new Map$1()) != mapTag$3 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$3 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag$1) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag$2;
            case mapCtorString:
              return mapTag$3;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag$3;
            case weakMapCtorString:
              return weakMapTag$1;
          }
        }
        return result;
      };
    }
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function initCloneArray(array2) {
      var length = array2.length, result = new array2.constructor(length);
      if (length && typeof array2[0] == "string" && hasOwnProperty.call(array2, "index")) {
        result.index = array2.index;
        result.input = array2.input;
      }
      return result;
    }
    var Uint8Array2 = root$1.Uint8Array;
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    var reFlags = /\w*$/;
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : void 0;
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$2 = "[object Symbol]";
    var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
    function initCloneByTag(object2, tag, isDeep) {
      var Ctor = object2.constructor;
      switch (tag) {
        case arrayBufferTag$1:
          return cloneArrayBuffer(object2);
        case boolTag$1:
        case dateTag$1:
          return new Ctor(+object2);
        case dataViewTag$1:
          return cloneDataView(object2, isDeep);
        case float32Tag$1:
        case float64Tag$1:
        case int8Tag$1:
        case int16Tag$1:
        case int32Tag$1:
        case uint8Tag$1:
        case uint8ClampedTag$1:
        case uint16Tag$1:
        case uint32Tag$1:
          return cloneTypedArray(object2, isDeep);
        case mapTag$2:
          return new Ctor();
        case numberTag$1:
        case stringTag$1:
          return new Ctor(object2);
        case regexpTag$1:
          return cloneRegExp(object2);
        case setTag$2:
          return new Ctor();
        case symbolTag$2:
          return cloneSymbol(object2);
      }
    }
    var objectCreate = Object.create;
    var baseCreate = /* @__PURE__ */ function() {
      function object2() {
      }
      return function(proto) {
        if (!isObject$2(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object2.prototype = proto;
        var result = new object2();
        object2.prototype = void 0;
        return result;
      };
    }();
    function initCloneObject(object2) {
      return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate(getPrototype(object2)) : {};
    }
    var mapTag$1 = "[object Map]";
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag$1;
    }
    var nodeIsMap = nodeUtil && nodeUtil.isMap;
    var isMap$1 = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
    var setTag$1 = "[object Set]";
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag$1;
    }
    var nodeIsSet = nodeUtil && nodeUtil.isSet;
    var isSet$1 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
    var CLONE_DEEP_FLAG$1 = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$2 = 4;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag$1 = "[object Symbol]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    function baseClone(value, bitmask, customizer, key, object2, stack) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG$1, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$2;
      if (result !== void 0) {
        return result;
      }
      if (!isObject$2(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object2) {
          result = isFlat || isFunc ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object2 ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (isSet$1(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap$1(value)) {
        value.forEach(function(subValue, key2) {
          result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
      var props = isArr ? void 0 : keysFunc(value);
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
      });
      return result;
    }
    var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG$1 = 4;
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG$1);
    }
    var reactFastCompare;
    var hasRequiredReactFastCompare;
    function requireReactFastCompare() {
      if (hasRequiredReactFastCompare) return reactFastCompare;
      hasRequiredReactFastCompare = 1;
      var isArray2 = Array.isArray;
      var keyList = Object.keys;
      var hasProp = Object.prototype.hasOwnProperty;
      var hasElementType = typeof Element !== "undefined";
      function equal(a, b) {
        if (a === b) return true;
        if (a && b && typeof a == "object" && typeof b == "object") {
          var arrA = isArray2(a), arrB = isArray2(b), i, length, key;
          if (arrA && arrB) {
            length = a.length;
            if (length != b.length) return false;
            for (i = length; i-- !== 0; )
              if (!equal(a[i], b[i])) return false;
            return true;
          }
          if (arrA != arrB) return false;
          var dateA = a instanceof Date, dateB = b instanceof Date;
          if (dateA != dateB) return false;
          if (dateA && dateB) return a.getTime() == b.getTime();
          var regexpA = a instanceof RegExp, regexpB = b instanceof RegExp;
          if (regexpA != regexpB) return false;
          if (regexpA && regexpB) return a.toString() == b.toString();
          var keys2 = keyList(a);
          length = keys2.length;
          if (length !== keyList(b).length)
            return false;
          for (i = length; i-- !== 0; )
            if (!hasProp.call(b, keys2[i])) return false;
          if (hasElementType && a instanceof Element && b instanceof Element)
            return a === b;
          for (i = length; i-- !== 0; ) {
            key = keys2[i];
            if (key === "_owner" && a.$$typeof) {
              continue;
            } else {
              if (!equal(a[key], b[key])) return false;
            }
          }
          return true;
        }
        return a !== a && b !== b;
      }
      reactFastCompare = function exportedEqual(a, b) {
        try {
          return equal(a, b);
        } catch (error) {
          if (error.message && error.message.match(/stack|recursion/i) || error.number === -2146828260) {
            console.warn("Warning: react-fast-compare does not handle circular references.", error.name, error.message);
            return false;
          }
          throw error;
        }
      };
      return reactFastCompare;
    }
    var reactFastCompareExports = requireReactFastCompare();
    const isEqual = /* @__PURE__ */ getDefaultExportFromCjs(reactFastCompareExports);
    var CLONE_SYMBOLS_FLAG = 4;
    function clone$1(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }
    function arrayMap(array2, iteratee) {
      var index = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array2[index], index, array2);
      }
      return result;
    }
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
        if (cache2.has(key)) {
          return cache2.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache2.set(key, result) || cache2;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache2.size === MAX_MEMOIZE_SIZE) {
          cache2.clear();
        }
        return key;
      });
      var cache2 = result.cache;
      return result;
    }
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string2) {
      var result = [];
      if (string2.charCodeAt(0) === 46) {
        result.push("");
      }
      string2.replace(rePropName, function(match, number2, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
      });
      return result;
    });
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -Infinity ? "-0" : result;
    }
    var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString$1 = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString$1 ? symbolToString$1.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -Infinity ? "-0" : result;
    }
    function toString$1(value) {
      return value == null ? "" : baseToString(value);
    }
    function toPath(value) {
      if (isArray(value)) {
        return arrayMap(value, toKey);
      }
      return isSymbol(value) ? [value] : copyArray(stringToPath(toString$1(value)));
    }
    var reactIs = { exports: {} };
    var reactIs_production_min = {};
    /** @license React v16.13.1
     * react-is.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var hasRequiredReactIs_production_min;
    function requireReactIs_production_min() {
      if (hasRequiredReactIs_production_min) return reactIs_production_min;
      hasRequiredReactIs_production_min = 1;
      var b = "function" === typeof Symbol && Symbol.for, c = b ? Symbol.for("react.element") : 60103, d = b ? Symbol.for("react.portal") : 60106, e = b ? Symbol.for("react.fragment") : 60107, f = b ? Symbol.for("react.strict_mode") : 60108, g = b ? Symbol.for("react.profiler") : 60114, h = b ? Symbol.for("react.provider") : 60109, k = b ? Symbol.for("react.context") : 60110, l = b ? Symbol.for("react.async_mode") : 60111, m = b ? Symbol.for("react.concurrent_mode") : 60111, n = b ? Symbol.for("react.forward_ref") : 60112, p = b ? Symbol.for("react.suspense") : 60113, q = b ? Symbol.for("react.suspense_list") : 60120, r = b ? Symbol.for("react.memo") : 60115, t = b ? Symbol.for("react.lazy") : 60116, v = b ? Symbol.for("react.block") : 60121, w = b ? Symbol.for("react.fundamental") : 60117, x = b ? Symbol.for("react.responder") : 60118, y = b ? Symbol.for("react.scope") : 60119;
      function z(a) {
        if ("object" === typeof a && null !== a) {
          var u = a.$$typeof;
          switch (u) {
            case c:
              switch (a = a.type, a) {
                case l:
                case m:
                case e:
                case g:
                case f:
                case p:
                  return a;
                default:
                  switch (a = a && a.$$typeof, a) {
                    case k:
                    case n:
                    case t:
                    case r:
                    case h:
                      return a;
                    default:
                      return u;
                  }
              }
            case d:
              return u;
          }
        }
      }
      function A(a) {
        return z(a) === m;
      }
      reactIs_production_min.AsyncMode = l;
      reactIs_production_min.ConcurrentMode = m;
      reactIs_production_min.ContextConsumer = k;
      reactIs_production_min.ContextProvider = h;
      reactIs_production_min.Element = c;
      reactIs_production_min.ForwardRef = n;
      reactIs_production_min.Fragment = e;
      reactIs_production_min.Lazy = t;
      reactIs_production_min.Memo = r;
      reactIs_production_min.Portal = d;
      reactIs_production_min.Profiler = g;
      reactIs_production_min.StrictMode = f;
      reactIs_production_min.Suspense = p;
      reactIs_production_min.isAsyncMode = function(a) {
        return A(a) || z(a) === l;
      };
      reactIs_production_min.isConcurrentMode = A;
      reactIs_production_min.isContextConsumer = function(a) {
        return z(a) === k;
      };
      reactIs_production_min.isContextProvider = function(a) {
        return z(a) === h;
      };
      reactIs_production_min.isElement = function(a) {
        return "object" === typeof a && null !== a && a.$$typeof === c;
      };
      reactIs_production_min.isForwardRef = function(a) {
        return z(a) === n;
      };
      reactIs_production_min.isFragment = function(a) {
        return z(a) === e;
      };
      reactIs_production_min.isLazy = function(a) {
        return z(a) === t;
      };
      reactIs_production_min.isMemo = function(a) {
        return z(a) === r;
      };
      reactIs_production_min.isPortal = function(a) {
        return z(a) === d;
      };
      reactIs_production_min.isProfiler = function(a) {
        return z(a) === g;
      };
      reactIs_production_min.isStrictMode = function(a) {
        return z(a) === f;
      };
      reactIs_production_min.isSuspense = function(a) {
        return z(a) === p;
      };
      reactIs_production_min.isValidElementType = function(a) {
        return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
      };
      reactIs_production_min.typeOf = z;
      return reactIs_production_min;
    }
    var hasRequiredReactIs;
    function requireReactIs() {
      if (hasRequiredReactIs) return reactIs.exports;
      hasRequiredReactIs = 1;
      {
        reactIs.exports = requireReactIs_production_min();
      }
      return reactIs.exports;
    }
    var hoistNonReactStatics_cjs;
    var hasRequiredHoistNonReactStatics_cjs;
    function requireHoistNonReactStatics_cjs() {
      if (hasRequiredHoistNonReactStatics_cjs) return hoistNonReactStatics_cjs;
      hasRequiredHoistNonReactStatics_cjs = 1;
      var reactIs2 = requireReactIs();
      var REACT_STATICS = {
        childContextTypes: true,
        contextType: true,
        contextTypes: true,
        defaultProps: true,
        displayName: true,
        getDefaultProps: true,
        getDerivedStateFromError: true,
        getDerivedStateFromProps: true,
        mixins: true,
        propTypes: true,
        type: true
      };
      var KNOWN_STATICS = {
        name: true,
        length: true,
        prototype: true,
        caller: true,
        callee: true,
        arguments: true,
        arity: true
      };
      var FORWARD_REF_STATICS = {
        "$$typeof": true,
        render: true,
        defaultProps: true,
        displayName: true,
        propTypes: true
      };
      var MEMO_STATICS = {
        "$$typeof": true,
        compare: true,
        defaultProps: true,
        displayName: true,
        propTypes: true,
        type: true
      };
      var TYPE_STATICS = {};
      TYPE_STATICS[reactIs2.ForwardRef] = FORWARD_REF_STATICS;
      TYPE_STATICS[reactIs2.Memo] = MEMO_STATICS;
      function getStatics(component) {
        if (reactIs2.isMemo(component)) {
          return MEMO_STATICS;
        }
        return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
      }
      var defineProperty2 = Object.defineProperty;
      var getOwnPropertyNames = Object.getOwnPropertyNames;
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var getPrototypeOf2 = Object.getPrototypeOf;
      var objectPrototype = Object.prototype;
      function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
        if (typeof sourceComponent !== "string") {
          if (objectPrototype) {
            var inheritedComponent = getPrototypeOf2(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
              hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
            }
          }
          var keys2 = getOwnPropertyNames(sourceComponent);
          if (getOwnPropertySymbols) {
            keys2 = keys2.concat(getOwnPropertySymbols(sourceComponent));
          }
          var targetStatics = getStatics(targetComponent);
          var sourceStatics = getStatics(sourceComponent);
          for (var i = 0; i < keys2.length; ++i) {
            var key = keys2[i];
            if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
              var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
              try {
                defineProperty2(targetComponent, key, descriptor);
              } catch (e) {
              }
            }
          }
        }
        return targetComponent;
      }
      hoistNonReactStatics_cjs = hoistNonReactStatics;
      return hoistNonReactStatics_cjs;
    }
    requireHoistNonReactStatics_cjs();
    function _extends() {
      _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null) return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
      }
      return target;
    }
    var FormikContext = /* @__PURE__ */ reactExports.createContext(void 0);
    FormikContext.displayName = "FormikContext";
    FormikContext.Provider;
    FormikContext.Consumer;
    function useFormikContext() {
      var formik = reactExports.useContext(FormikContext);
      return formik;
    }
    var isFunction$1 = function isFunction2(obj) {
      return typeof obj === "function";
    };
    var isObject$1 = function isObject2(obj) {
      return obj !== null && typeof obj === "object";
    };
    var isInteger = function isInteger2(obj) {
      return String(Math.floor(Number(obj))) === obj;
    };
    var isString = function isString2(obj) {
      return Object.prototype.toString.call(obj) === "[object String]";
    };
    var isPromise = function isPromise2(value) {
      return isObject$1(value) && isFunction$1(value.then);
    };
    function getIn$1(obj, key, def, p) {
      if (p === void 0) {
        p = 0;
      }
      var path = toPath(key);
      while (obj && p < path.length) {
        obj = obj[path[p++]];
      }
      if (p !== path.length && !obj) {
        return def;
      }
      return obj === void 0 ? def : obj;
    }
    function setIn(obj, path, value) {
      var res = clone$1(obj);
      var resVal = res;
      var i = 0;
      var pathArray = toPath(path);
      for (; i < pathArray.length - 1; i++) {
        var currentPath = pathArray[i];
        var currentObj = getIn$1(obj, pathArray.slice(0, i + 1));
        if (currentObj && (isObject$1(currentObj) || Array.isArray(currentObj))) {
          resVal = resVal[currentPath] = clone$1(currentObj);
        } else {
          var nextPath = pathArray[i + 1];
          resVal = resVal[currentPath] = isInteger(nextPath) && Number(nextPath) >= 0 ? [] : {};
        }
      }
      if ((i === 0 ? obj : resVal)[pathArray[i]] === value) {
        return obj;
      }
      if (value === void 0) {
        delete resVal[pathArray[i]];
      } else {
        resVal[pathArray[i]] = value;
      }
      if (i === 0 && value === void 0) {
        delete res[pathArray[i]];
      }
      return res;
    }
    function setNestedObjectValues(object2, value, visited, response) {
      if (visited === void 0) {
        visited = /* @__PURE__ */ new WeakMap();
      }
      if (response === void 0) {
        response = {};
      }
      for (var _i = 0, _Object$keys = Object.keys(object2); _i < _Object$keys.length; _i++) {
        var k = _Object$keys[_i];
        var val = object2[k];
        if (isObject$1(val)) {
          if (!visited.get(val)) {
            visited.set(val, true);
            response[k] = Array.isArray(val) ? [] : {};
            setNestedObjectValues(val, value, visited, response[k]);
          }
        } else {
          response[k] = value;
        }
      }
      return response;
    }
    function formikReducer(state, msg) {
      switch (msg.type) {
        case "SET_VALUES":
          return _extends({}, state, {
            values: msg.payload
          });
        case "SET_TOUCHED":
          return _extends({}, state, {
            touched: msg.payload
          });
        case "SET_ERRORS":
          if (isEqual(state.errors, msg.payload)) {
            return state;
          }
          return _extends({}, state, {
            errors: msg.payload
          });
        case "SET_STATUS":
          return _extends({}, state, {
            status: msg.payload
          });
        case "SET_ISSUBMITTING":
          return _extends({}, state, {
            isSubmitting: msg.payload
          });
        case "SET_ISVALIDATING":
          return _extends({}, state, {
            isValidating: msg.payload
          });
        case "SET_FIELD_VALUE":
          return _extends({}, state, {
            values: setIn(state.values, msg.payload.field, msg.payload.value)
          });
        case "SET_FIELD_TOUCHED":
          return _extends({}, state, {
            touched: setIn(state.touched, msg.payload.field, msg.payload.value)
          });
        case "SET_FIELD_ERROR":
          return _extends({}, state, {
            errors: setIn(state.errors, msg.payload.field, msg.payload.value)
          });
        case "RESET_FORM":
          return _extends({}, state, msg.payload);
        case "SET_FORMIK_STATE":
          return msg.payload(state);
        case "SUBMIT_ATTEMPT":
          return _extends({}, state, {
            touched: setNestedObjectValues(state.values, true),
            isSubmitting: true,
            submitCount: state.submitCount + 1
          });
        case "SUBMIT_FAILURE":
          return _extends({}, state, {
            isSubmitting: false
          });
        case "SUBMIT_SUCCESS":
          return _extends({}, state, {
            isSubmitting: false
          });
        default:
          return state;
      }
    }
    var emptyErrors = {};
    var emptyTouched = {};
    function useFormik(_ref) {
      var _ref$validateOnChange = _ref.validateOnChange, validateOnChange = _ref$validateOnChange === void 0 ? true : _ref$validateOnChange, _ref$validateOnBlur = _ref.validateOnBlur, validateOnBlur = _ref$validateOnBlur === void 0 ? true : _ref$validateOnBlur, _ref$validateOnMount = _ref.validateOnMount, validateOnMount = _ref$validateOnMount === void 0 ? false : _ref$validateOnMount, isInitialValid = _ref.isInitialValid, _ref$enableReinitiali = _ref.enableReinitialize, enableReinitialize = _ref$enableReinitiali === void 0 ? false : _ref$enableReinitiali, onSubmit = _ref.onSubmit, rest = _objectWithoutPropertiesLoose(_ref, ["validateOnChange", "validateOnBlur", "validateOnMount", "isInitialValid", "enableReinitialize", "onSubmit"]);
      var props = _extends({
        validateOnChange,
        validateOnBlur,
        validateOnMount,
        onSubmit
      }, rest);
      var initialValues2 = reactExports.useRef(props.initialValues);
      var initialErrors = reactExports.useRef(props.initialErrors || emptyErrors);
      var initialTouched = reactExports.useRef(props.initialTouched || emptyTouched);
      var initialStatus = reactExports.useRef(props.initialStatus);
      var isMounted = reactExports.useRef(false);
      var fieldRegistry = reactExports.useRef({});
      reactExports.useEffect(function() {
        isMounted.current = true;
        return function() {
          isMounted.current = false;
        };
      }, []);
      var _React$useState = reactExports.useState(0), setIteration = _React$useState[1];
      var stateRef = reactExports.useRef({
        values: cloneDeep(props.initialValues),
        errors: cloneDeep(props.initialErrors) || emptyErrors,
        touched: cloneDeep(props.initialTouched) || emptyTouched,
        status: cloneDeep(props.initialStatus),
        isSubmitting: false,
        isValidating: false,
        submitCount: 0
      });
      var state = stateRef.current;
      var dispatch = reactExports.useCallback(function(action) {
        var prev = stateRef.current;
        stateRef.current = formikReducer(prev, action);
        if (prev !== stateRef.current) setIteration(function(x) {
          return x + 1;
        });
      }, []);
      var runValidateHandler = reactExports.useCallback(function(values, field) {
        return new Promise(function(resolve, reject) {
          var maybePromisedErrors = props.validate(values, field);
          if (maybePromisedErrors == null) {
            resolve(emptyErrors);
          } else if (isPromise(maybePromisedErrors)) {
            maybePromisedErrors.then(function(errors) {
              resolve(errors || emptyErrors);
            }, function(actualException) {
              reject(actualException);
            });
          } else {
            resolve(maybePromisedErrors);
          }
        });
      }, [props.validate]);
      var runValidationSchema = reactExports.useCallback(function(values, field) {
        var validationSchema2 = props.validationSchema;
        var schema = isFunction$1(validationSchema2) ? validationSchema2(field) : validationSchema2;
        var promise = field && schema.validateAt ? schema.validateAt(field, values) : validateYupSchema(values, schema);
        return new Promise(function(resolve, reject) {
          promise.then(function() {
            resolve(emptyErrors);
          }, function(err) {
            if (err.name === "ValidationError") {
              resolve(yupToFormErrors(err));
            } else {
              reject(err);
            }
          });
        });
      }, [props.validationSchema]);
      var runSingleFieldLevelValidation = reactExports.useCallback(function(field, value) {
        return new Promise(function(resolve) {
          return resolve(fieldRegistry.current[field].validate(value));
        });
      }, []);
      var runFieldLevelValidations = reactExports.useCallback(function(values) {
        var fieldKeysWithValidation = Object.keys(fieldRegistry.current).filter(function(f) {
          return isFunction$1(fieldRegistry.current[f].validate);
        });
        var fieldValidations = fieldKeysWithValidation.length > 0 ? fieldKeysWithValidation.map(function(f) {
          return runSingleFieldLevelValidation(f, getIn$1(values, f));
        }) : [Promise.resolve("DO_NOT_DELETE_YOU_WILL_BE_FIRED")];
        return Promise.all(fieldValidations).then(function(fieldErrorsList) {
          return fieldErrorsList.reduce(function(prev, curr, index) {
            if (curr === "DO_NOT_DELETE_YOU_WILL_BE_FIRED") {
              return prev;
            }
            if (curr) {
              prev = setIn(prev, fieldKeysWithValidation[index], curr);
            }
            return prev;
          }, {});
        });
      }, [runSingleFieldLevelValidation]);
      var runAllValidations = reactExports.useCallback(function(values) {
        return Promise.all([runFieldLevelValidations(values), props.validationSchema ? runValidationSchema(values) : {}, props.validate ? runValidateHandler(values) : {}]).then(function(_ref2) {
          var fieldErrors = _ref2[0], schemaErrors = _ref2[1], validateErrors = _ref2[2];
          var combinedErrors = deepmerge_1.all([fieldErrors, schemaErrors, validateErrors], {
            arrayMerge
          });
          return combinedErrors;
        });
      }, [props.validate, props.validationSchema, runFieldLevelValidations, runValidateHandler, runValidationSchema]);
      var validateFormWithHighPriority = useEventCallback(function(values) {
        if (values === void 0) {
          values = state.values;
        }
        dispatch({
          type: "SET_ISVALIDATING",
          payload: true
        });
        return runAllValidations(values).then(function(combinedErrors) {
          if (!!isMounted.current) {
            dispatch({
              type: "SET_ISVALIDATING",
              payload: false
            });
            dispatch({
              type: "SET_ERRORS",
              payload: combinedErrors
            });
          }
          return combinedErrors;
        });
      });
      reactExports.useEffect(function() {
        if (validateOnMount && isMounted.current === true && isEqual(initialValues2.current, props.initialValues)) {
          validateFormWithHighPriority(initialValues2.current);
        }
      }, [validateOnMount, validateFormWithHighPriority]);
      var resetForm = reactExports.useCallback(function(nextState) {
        var values = nextState && nextState.values ? nextState.values : initialValues2.current;
        var errors = nextState && nextState.errors ? nextState.errors : initialErrors.current ? initialErrors.current : props.initialErrors || {};
        var touched = nextState && nextState.touched ? nextState.touched : initialTouched.current ? initialTouched.current : props.initialTouched || {};
        var status = nextState && nextState.status ? nextState.status : initialStatus.current ? initialStatus.current : props.initialStatus;
        initialValues2.current = values;
        initialErrors.current = errors;
        initialTouched.current = touched;
        initialStatus.current = status;
        var dispatchFn = function dispatchFn2() {
          dispatch({
            type: "RESET_FORM",
            payload: {
              isSubmitting: !!nextState && !!nextState.isSubmitting,
              errors,
              touched,
              status,
              values,
              isValidating: !!nextState && !!nextState.isValidating,
              submitCount: !!nextState && !!nextState.submitCount && typeof nextState.submitCount === "number" ? nextState.submitCount : 0
            }
          });
        };
        if (props.onReset) {
          var maybePromisedOnReset = props.onReset(state.values, imperativeMethods);
          if (isPromise(maybePromisedOnReset)) {
            maybePromisedOnReset.then(dispatchFn);
          } else {
            dispatchFn();
          }
        } else {
          dispatchFn();
        }
      }, [props.initialErrors, props.initialStatus, props.initialTouched, props.onReset]);
      reactExports.useEffect(function() {
        if (isMounted.current === true && !isEqual(initialValues2.current, props.initialValues)) {
          if (enableReinitialize) {
            initialValues2.current = props.initialValues;
            resetForm();
            if (validateOnMount) {
              validateFormWithHighPriority(initialValues2.current);
            }
          }
        }
      }, [enableReinitialize, props.initialValues, resetForm, validateOnMount, validateFormWithHighPriority]);
      reactExports.useEffect(function() {
        if (enableReinitialize && isMounted.current === true && !isEqual(initialErrors.current, props.initialErrors)) {
          initialErrors.current = props.initialErrors || emptyErrors;
          dispatch({
            type: "SET_ERRORS",
            payload: props.initialErrors || emptyErrors
          });
        }
      }, [enableReinitialize, props.initialErrors]);
      reactExports.useEffect(function() {
        if (enableReinitialize && isMounted.current === true && !isEqual(initialTouched.current, props.initialTouched)) {
          initialTouched.current = props.initialTouched || emptyTouched;
          dispatch({
            type: "SET_TOUCHED",
            payload: props.initialTouched || emptyTouched
          });
        }
      }, [enableReinitialize, props.initialTouched]);
      reactExports.useEffect(function() {
        if (enableReinitialize && isMounted.current === true && !isEqual(initialStatus.current, props.initialStatus)) {
          initialStatus.current = props.initialStatus;
          dispatch({
            type: "SET_STATUS",
            payload: props.initialStatus
          });
        }
      }, [enableReinitialize, props.initialStatus, props.initialTouched]);
      var validateField = useEventCallback(function(name) {
        if (fieldRegistry.current[name] && isFunction$1(fieldRegistry.current[name].validate)) {
          var value = getIn$1(state.values, name);
          var maybePromise = fieldRegistry.current[name].validate(value);
          if (isPromise(maybePromise)) {
            dispatch({
              type: "SET_ISVALIDATING",
              payload: true
            });
            return maybePromise.then(function(x) {
              return x;
            }).then(function(error) {
              dispatch({
                type: "SET_FIELD_ERROR",
                payload: {
                  field: name,
                  value: error
                }
              });
              dispatch({
                type: "SET_ISVALIDATING",
                payload: false
              });
            });
          } else {
            dispatch({
              type: "SET_FIELD_ERROR",
              payload: {
                field: name,
                value: maybePromise
              }
            });
            return Promise.resolve(maybePromise);
          }
        } else if (props.validationSchema) {
          dispatch({
            type: "SET_ISVALIDATING",
            payload: true
          });
          return runValidationSchema(state.values, name).then(function(x) {
            return x;
          }).then(function(error) {
            dispatch({
              type: "SET_FIELD_ERROR",
              payload: {
                field: name,
                value: getIn$1(error, name)
              }
            });
            dispatch({
              type: "SET_ISVALIDATING",
              payload: false
            });
          });
        }
        return Promise.resolve();
      });
      var registerField = reactExports.useCallback(function(name, _ref3) {
        var validate = _ref3.validate;
        fieldRegistry.current[name] = {
          validate
        };
      }, []);
      var unregisterField = reactExports.useCallback(function(name) {
        delete fieldRegistry.current[name];
      }, []);
      var setTouched = useEventCallback(function(touched, shouldValidate) {
        dispatch({
          type: "SET_TOUCHED",
          payload: touched
        });
        var willValidate = shouldValidate === void 0 ? validateOnBlur : shouldValidate;
        return willValidate ? validateFormWithHighPriority(state.values) : Promise.resolve();
      });
      var setErrors = reactExports.useCallback(function(errors) {
        dispatch({
          type: "SET_ERRORS",
          payload: errors
        });
      }, []);
      var setValues = useEventCallback(function(values, shouldValidate) {
        var resolvedValues = isFunction$1(values) ? values(state.values) : values;
        dispatch({
          type: "SET_VALUES",
          payload: resolvedValues
        });
        var willValidate = shouldValidate === void 0 ? validateOnChange : shouldValidate;
        return willValidate ? validateFormWithHighPriority(resolvedValues) : Promise.resolve();
      });
      var setFieldError = reactExports.useCallback(function(field, value) {
        dispatch({
          type: "SET_FIELD_ERROR",
          payload: {
            field,
            value
          }
        });
      }, []);
      var setFieldValue = useEventCallback(function(field, value, shouldValidate) {
        dispatch({
          type: "SET_FIELD_VALUE",
          payload: {
            field,
            value
          }
        });
        var willValidate = shouldValidate === void 0 ? validateOnChange : shouldValidate;
        return willValidate ? validateFormWithHighPriority(setIn(state.values, field, value)) : Promise.resolve();
      });
      var executeChange = reactExports.useCallback(function(eventOrTextValue, maybePath) {
        var field = maybePath;
        var val = eventOrTextValue;
        var parsed;
        if (!isString(eventOrTextValue)) {
          if (eventOrTextValue.persist) {
            eventOrTextValue.persist();
          }
          var target = eventOrTextValue.target ? eventOrTextValue.target : eventOrTextValue.currentTarget;
          var type = target.type, name = target.name, id = target.id, value = target.value, checked = target.checked;
          target.outerHTML;
          var options = target.options, multiple = target.multiple;
          field = maybePath ? maybePath : name ? name : id;
          val = /number|range/.test(type) ? (parsed = parseFloat(value), isNaN(parsed) ? "" : parsed) : /checkbox/.test(type) ? getValueForCheckbox(getIn$1(state.values, field), checked, value) : options && multiple ? getSelectedValues(options) : value;
        }
        if (field) {
          setFieldValue(field, val);
        }
      }, [setFieldValue, state.values]);
      var handleChange = useEventCallback(function(eventOrPath) {
        if (isString(eventOrPath)) {
          return function(event) {
            return executeChange(event, eventOrPath);
          };
        } else {
          executeChange(eventOrPath);
        }
      });
      var setFieldTouched = useEventCallback(function(field, touched, shouldValidate) {
        if (touched === void 0) {
          touched = true;
        }
        dispatch({
          type: "SET_FIELD_TOUCHED",
          payload: {
            field,
            value: touched
          }
        });
        var willValidate = shouldValidate === void 0 ? validateOnBlur : shouldValidate;
        return willValidate ? validateFormWithHighPriority(state.values) : Promise.resolve();
      });
      var executeBlur = reactExports.useCallback(function(e, path) {
        if (e.persist) {
          e.persist();
        }
        var _e$target = e.target, name = _e$target.name, id = _e$target.id;
        _e$target.outerHTML;
        var field = path ? path : name ? name : id;
        setFieldTouched(field, true);
      }, [setFieldTouched]);
      var handleBlur = useEventCallback(function(eventOrString) {
        if (isString(eventOrString)) {
          return function(event) {
            return executeBlur(event, eventOrString);
          };
        } else {
          executeBlur(eventOrString);
        }
      });
      var setFormikState = reactExports.useCallback(function(stateOrCb) {
        if (isFunction$1(stateOrCb)) {
          dispatch({
            type: "SET_FORMIK_STATE",
            payload: stateOrCb
          });
        } else {
          dispatch({
            type: "SET_FORMIK_STATE",
            payload: function payload() {
              return stateOrCb;
            }
          });
        }
      }, []);
      var setStatus = reactExports.useCallback(function(status) {
        dispatch({
          type: "SET_STATUS",
          payload: status
        });
      }, []);
      var setSubmitting = reactExports.useCallback(function(isSubmitting) {
        dispatch({
          type: "SET_ISSUBMITTING",
          payload: isSubmitting
        });
      }, []);
      var submitForm = useEventCallback(function() {
        dispatch({
          type: "SUBMIT_ATTEMPT"
        });
        return validateFormWithHighPriority().then(function(combinedErrors) {
          var isInstanceOfError = combinedErrors instanceof Error;
          var isActuallyValid = !isInstanceOfError && Object.keys(combinedErrors).length === 0;
          if (isActuallyValid) {
            var promiseOrUndefined;
            try {
              promiseOrUndefined = executeSubmit();
              if (promiseOrUndefined === void 0) {
                return;
              }
            } catch (error) {
              throw error;
            }
            return Promise.resolve(promiseOrUndefined).then(function(result) {
              if (!!isMounted.current) {
                dispatch({
                  type: "SUBMIT_SUCCESS"
                });
              }
              return result;
            })["catch"](function(_errors) {
              if (!!isMounted.current) {
                dispatch({
                  type: "SUBMIT_FAILURE"
                });
                throw _errors;
              }
            });
          } else if (!!isMounted.current) {
            dispatch({
              type: "SUBMIT_FAILURE"
            });
            if (isInstanceOfError) {
              throw combinedErrors;
            }
          }
          return;
        });
      });
      var handleSubmit = useEventCallback(function(e) {
        if (e && e.preventDefault && isFunction$1(e.preventDefault)) {
          e.preventDefault();
        }
        if (e && e.stopPropagation && isFunction$1(e.stopPropagation)) {
          e.stopPropagation();
        }
        submitForm()["catch"](function(reason) {
          console.warn("Warning: An unhandled error was caught from submitForm()", reason);
        });
      });
      var imperativeMethods = {
        resetForm,
        validateForm: validateFormWithHighPriority,
        validateField,
        setErrors,
        setFieldError,
        setFieldTouched,
        setFieldValue,
        setStatus,
        setSubmitting,
        setTouched,
        setValues,
        setFormikState,
        submitForm
      };
      var executeSubmit = useEventCallback(function() {
        return onSubmit(state.values, imperativeMethods);
      });
      var handleReset = useEventCallback(function(e) {
        if (e && e.preventDefault && isFunction$1(e.preventDefault)) {
          e.preventDefault();
        }
        if (e && e.stopPropagation && isFunction$1(e.stopPropagation)) {
          e.stopPropagation();
        }
        resetForm();
      });
      var getFieldMeta = reactExports.useCallback(function(name) {
        return {
          value: getIn$1(state.values, name),
          error: getIn$1(state.errors, name),
          touched: !!getIn$1(state.touched, name),
          initialValue: getIn$1(initialValues2.current, name),
          initialTouched: !!getIn$1(initialTouched.current, name),
          initialError: getIn$1(initialErrors.current, name)
        };
      }, [state.errors, state.touched, state.values]);
      var getFieldHelpers = reactExports.useCallback(function(name) {
        return {
          setValue: function setValue(value, shouldValidate) {
            return setFieldValue(name, value, shouldValidate);
          },
          setTouched: function setTouched2(value, shouldValidate) {
            return setFieldTouched(name, value, shouldValidate);
          },
          setError: function setError(value) {
            return setFieldError(name, value);
          }
        };
      }, [setFieldValue, setFieldTouched, setFieldError]);
      var getFieldProps = reactExports.useCallback(function(nameOrOptions) {
        var isAnObject = isObject$1(nameOrOptions);
        var name = isAnObject ? nameOrOptions.name : nameOrOptions;
        var valueState = getIn$1(state.values, name);
        var field = {
          name,
          value: valueState,
          onChange: handleChange,
          onBlur: handleBlur
        };
        if (isAnObject) {
          var type = nameOrOptions.type, valueProp = nameOrOptions.value, is2 = nameOrOptions.as, multiple = nameOrOptions.multiple;
          if (type === "checkbox") {
            if (valueProp === void 0) {
              field.checked = !!valueState;
            } else {
              field.checked = !!(Array.isArray(valueState) && ~valueState.indexOf(valueProp));
              field.value = valueProp;
            }
          } else if (type === "radio") {
            field.checked = valueState === valueProp;
            field.value = valueProp;
          } else if (is2 === "select" && multiple) {
            field.value = field.value || [];
            field.multiple = true;
          }
        }
        return field;
      }, [handleBlur, handleChange, state.values]);
      var dirty = reactExports.useMemo(function() {
        return !isEqual(initialValues2.current, state.values);
      }, [initialValues2.current, state.values]);
      var isValid = reactExports.useMemo(function() {
        return typeof isInitialValid !== "undefined" ? dirty ? state.errors && Object.keys(state.errors).length === 0 : isInitialValid !== false && isFunction$1(isInitialValid) ? isInitialValid(props) : isInitialValid : state.errors && Object.keys(state.errors).length === 0;
      }, [isInitialValid, dirty, state.errors, props]);
      var ctx = _extends({}, state, {
        initialValues: initialValues2.current,
        initialErrors: initialErrors.current,
        initialTouched: initialTouched.current,
        initialStatus: initialStatus.current,
        handleBlur,
        handleChange,
        handleReset,
        handleSubmit,
        resetForm,
        setErrors,
        setFormikState,
        setFieldTouched,
        setFieldValue,
        setFieldError,
        setStatus,
        setSubmitting,
        setTouched,
        setValues,
        submitForm,
        validateForm: validateFormWithHighPriority,
        validateField,
        isValid,
        dirty,
        unregisterField,
        registerField,
        getFieldProps,
        getFieldMeta,
        getFieldHelpers,
        validateOnBlur,
        validateOnChange,
        validateOnMount
      });
      return ctx;
    }
    function yupToFormErrors(yupError) {
      var errors = {};
      if (yupError.inner) {
        if (yupError.inner.length === 0) {
          return setIn(errors, yupError.path, yupError.message);
        }
        for (var _iterator = yupError.inner, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ; ) {
          var _ref5;
          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref5 = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref5 = _i.value;
          }
          var err = _ref5;
          if (!getIn$1(errors, err.path)) {
            errors = setIn(errors, err.path, err.message);
          }
        }
      }
      return errors;
    }
    function validateYupSchema(values, schema, sync, context) {
      if (sync === void 0) {
        sync = false;
      }
      var normalizedValues = prepareDataForValidation(values);
      return schema[sync ? "validateSync" : "validate"](normalizedValues, {
        abortEarly: false,
        context: normalizedValues
      });
    }
    function prepareDataForValidation(values) {
      var data = Array.isArray(values) ? [] : {};
      for (var k in values) {
        if (Object.prototype.hasOwnProperty.call(values, k)) {
          var key = String(k);
          if (Array.isArray(values[key]) === true) {
            data[key] = values[key].map(function(value) {
              if (Array.isArray(value) === true || isPlainObject$2(value)) {
                return prepareDataForValidation(value);
              } else {
                return value !== "" ? value : void 0;
              }
            });
          } else if (isPlainObject$2(values[key])) {
            data[key] = prepareDataForValidation(values[key]);
          } else {
            data[key] = values[key] !== "" ? values[key] : void 0;
          }
        }
      }
      return data;
    }
    function arrayMerge(target, source, options) {
      var destination = target.slice();
      source.forEach(function merge(e, i) {
        if (typeof destination[i] === "undefined") {
          var cloneRequested = options.clone !== false;
          var shouldClone = cloneRequested && options.isMergeableObject(e);
          destination[i] = shouldClone ? deepmerge_1(Array.isArray(e) ? [] : {}, e, options) : e;
        } else if (options.isMergeableObject(e)) {
          destination[i] = deepmerge_1(target[i], e, options);
        } else if (target.indexOf(e) === -1) {
          destination.push(e);
        }
      });
      return destination;
    }
    function getSelectedValues(options) {
      return Array.from(options).filter(function(el) {
        return el.selected;
      }).map(function(el) {
        return el.value;
      });
    }
    function getValueForCheckbox(currentValue, checked, valueProp) {
      if (typeof currentValue === "boolean") {
        return Boolean(checked);
      }
      var currentArrayOfValues = [];
      var isValueInArray = false;
      var index = -1;
      if (!Array.isArray(currentValue)) {
        if (!valueProp || valueProp == "true" || valueProp == "false") {
          return Boolean(checked);
        }
      } else {
        currentArrayOfValues = currentValue;
        index = currentValue.indexOf(valueProp);
        isValueInArray = index >= 0;
      }
      if (checked && valueProp && !isValueInArray) {
        return currentArrayOfValues.concat(valueProp);
      }
      if (!isValueInArray) {
        return currentArrayOfValues;
      }
      return currentArrayOfValues.slice(0, index).concat(currentArrayOfValues.slice(index + 1));
    }
    var useIsomorphicLayoutEffect$2 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
    function useEventCallback(fn) {
      var ref = reactExports.useRef(fn);
      useIsomorphicLayoutEffect$2(function() {
        ref.current = fn;
      });
      return reactExports.useCallback(function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return ref.current.apply(void 0, args);
      }, []);
    }
    var Form = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var action = props.action, rest = _objectWithoutPropertiesLoose(props, ["action"]);
      var _action = action != null ? action : "#";
      var _useFormikContext = useFormikContext(), handleReset = _useFormikContext.handleReset, handleSubmit = _useFormikContext.handleSubmit;
      return reactExports.createElement("form", _extends({
        onSubmit: handleSubmit,
        ref,
        onReset: handleReset,
        action: _action
      }, rest));
    });
    Form.displayName = "Form";
    var propertyExpr;
    var hasRequiredPropertyExpr;
    function requirePropertyExpr() {
      if (hasRequiredPropertyExpr) return propertyExpr;
      hasRequiredPropertyExpr = 1;
      function Cache(maxSize) {
        this._maxSize = maxSize;
        this.clear();
      }
      Cache.prototype.clear = function() {
        this._size = 0;
        this._values = /* @__PURE__ */ Object.create(null);
      };
      Cache.prototype.get = function(key) {
        return this._values[key];
      };
      Cache.prototype.set = function(key, value) {
        this._size >= this._maxSize && this.clear();
        if (!(key in this._values)) this._size++;
        return this._values[key] = value;
      };
      var SPLIT_REGEX = /[^.^\]^[]+|(?=\[\]|\.\.)/g, DIGIT_REGEX = /^\d+$/, LEAD_DIGIT_REGEX = /^\d/, SPEC_CHAR_REGEX = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g, CLEAN_QUOTES_REGEX = /^\s*(['"]?)(.*?)(\1)\s*$/, MAX_CACHE_SIZE = 512;
      var pathCache = new Cache(MAX_CACHE_SIZE), setCache = new Cache(MAX_CACHE_SIZE), getCache = new Cache(MAX_CACHE_SIZE);
      propertyExpr = {
        Cache,
        split,
        normalizePath,
        setter: function(path) {
          var parts = normalizePath(path);
          return setCache.get(path) || setCache.set(path, function setter(obj, value) {
            var index = 0;
            var len = parts.length;
            var data = obj;
            while (index < len - 1) {
              var part = parts[index];
              if (part === "__proto__" || part === "constructor" || part === "prototype") {
                return obj;
              }
              data = data[parts[index++]];
            }
            data[parts[index]] = value;
          });
        },
        getter: function(path, safe) {
          var parts = normalizePath(path);
          return getCache.get(path) || getCache.set(path, function getter(data) {
            var index = 0, len = parts.length;
            while (index < len) {
              if (data != null || !safe) data = data[parts[index++]];
              else return;
            }
            return data;
          });
        },
        join: function(segments) {
          return segments.reduce(function(path, part) {
            return path + (isQuoted(part) || DIGIT_REGEX.test(part) ? "[" + part + "]" : (path ? "." : "") + part);
          }, "");
        },
        forEach: function(path, cb, thisArg) {
          forEach(Array.isArray(path) ? path : split(path), cb, thisArg);
        }
      };
      function normalizePath(path) {
        return pathCache.get(path) || pathCache.set(
          path,
          split(path).map(function(part) {
            return part.replace(CLEAN_QUOTES_REGEX, "$2");
          })
        );
      }
      function split(path) {
        return path.match(SPLIT_REGEX) || [""];
      }
      function forEach(parts, iter, thisArg) {
        var len = parts.length, part, idx, isArray2, isBracket;
        for (idx = 0; idx < len; idx++) {
          part = parts[idx];
          if (part) {
            if (shouldBeQuoted(part)) {
              part = '"' + part + '"';
            }
            isBracket = isQuoted(part);
            isArray2 = !isBracket && /^\d+$/.test(part);
            iter.call(thisArg, part, isBracket, isArray2, idx, parts);
          }
        }
      }
      function isQuoted(str) {
        return typeof str === "string" && str && ["'", '"'].indexOf(str.charAt(0)) !== -1;
      }
      function hasLeadingNumber(part) {
        return part.match(LEAD_DIGIT_REGEX) && !part.match(DIGIT_REGEX);
      }
      function hasSpecialChars(part) {
        return SPEC_CHAR_REGEX.test(part);
      }
      function shouldBeQuoted(part) {
        return !isQuoted(part) && (hasLeadingNumber(part) || hasSpecialChars(part));
      }
      return propertyExpr;
    }
    var propertyExprExports = requirePropertyExpr();
    var tinyCase;
    var hasRequiredTinyCase;
    function requireTinyCase() {
      if (hasRequiredTinyCase) return tinyCase;
      hasRequiredTinyCase = 1;
      const reWords = /[A-Z\xc0-\xd6\xd8-\xde]?[a-z\xdf-\xf6\xf8-\xff]+(?:['](?:d|ll|m|re|s|t|ve))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde]|$)|(?:[A-Z\xc0-\xd6\xd8-\xde]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['](?:D|LL|M|RE|S|T|VE))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde](?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])|$)|[A-Z\xc0-\xd6\xd8-\xde]?(?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['](?:d|ll|m|re|s|t|ve))?|[A-Z\xc0-\xd6\xd8-\xde]+(?:['](?:D|LL|M|RE|S|T|VE))?|\d*(?:1ST|2ND|3RD|(?![123])\dTH)(?=\b|[a-z_])|\d*(?:1st|2nd|3rd|(?![123])\dth)(?=\b|[A-Z_])|\d+|(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?(?:\u200d(?:[^\ud800-\udfff]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?)*/g;
      const words = (str) => str.match(reWords) || [];
      const upperFirst = (str) => str[0].toUpperCase() + str.slice(1);
      const join = (str, d) => words(str).join(d).toLowerCase();
      const camelCase = (str) => words(str).reduce(
        (acc, next) => `${acc}${!acc ? next.toLowerCase() : next[0].toUpperCase() + next.slice(1).toLowerCase()}`,
        ""
      );
      const pascalCase = (str) => upperFirst(camelCase(str));
      const snakeCase = (str) => join(str, "_");
      const kebabCase = (str) => join(str, "-");
      const sentenceCase = (str) => upperFirst(join(str, " "));
      const titleCase = (str) => words(str).map(upperFirst).join(" ");
      tinyCase = {
        words,
        upperFirst,
        camelCase,
        pascalCase,
        snakeCase,
        kebabCase,
        sentenceCase,
        titleCase
      };
      return tinyCase;
    }
    var tinyCaseExports = requireTinyCase();
    var toposort$1 = { exports: {} };
    var hasRequiredToposort;
    function requireToposort() {
      if (hasRequiredToposort) return toposort$1.exports;
      hasRequiredToposort = 1;
      toposort$1.exports = function(edges) {
        return toposort2(uniqueNodes(edges), edges);
      };
      toposort$1.exports.array = toposort2;
      function toposort2(nodes, edges) {
        var cursor = nodes.length, sorted = new Array(cursor), visited = {}, i = cursor, outgoingEdges = makeOutgoingEdges(edges), nodesHash = makeNodesHash(nodes);
        edges.forEach(function(edge) {
          if (!nodesHash.has(edge[0]) || !nodesHash.has(edge[1])) {
            throw new Error("Unknown node. There is an unknown node in the supplied edges.");
          }
        });
        while (i--) {
          if (!visited[i]) visit(nodes[i], i, /* @__PURE__ */ new Set());
        }
        return sorted;
        function visit(node, i2, predecessors) {
          if (predecessors.has(node)) {
            var nodeRep;
            try {
              nodeRep = ", node was:" + JSON.stringify(node);
            } catch (e) {
              nodeRep = "";
            }
            throw new Error("Cyclic dependency" + nodeRep);
          }
          if (!nodesHash.has(node)) {
            throw new Error("Found unknown node. Make sure to provided all involved nodes. Unknown node: " + JSON.stringify(node));
          }
          if (visited[i2]) return;
          visited[i2] = true;
          var outgoing = outgoingEdges.get(node) || /* @__PURE__ */ new Set();
          outgoing = Array.from(outgoing);
          if (i2 = outgoing.length) {
            predecessors.add(node);
            do {
              var child = outgoing[--i2];
              visit(child, nodesHash.get(child), predecessors);
            } while (i2);
            predecessors.delete(node);
          }
          sorted[--cursor] = node;
        }
      }
      function uniqueNodes(arr) {
        var res = /* @__PURE__ */ new Set();
        for (var i = 0, len = arr.length; i < len; i++) {
          var edge = arr[i];
          res.add(edge[0]);
          res.add(edge[1]);
        }
        return Array.from(res);
      }
      function makeOutgoingEdges(arr) {
        var edges = /* @__PURE__ */ new Map();
        for (var i = 0, len = arr.length; i < len; i++) {
          var edge = arr[i];
          if (!edges.has(edge[0])) edges.set(edge[0], /* @__PURE__ */ new Set());
          if (!edges.has(edge[1])) edges.set(edge[1], /* @__PURE__ */ new Set());
          edges.get(edge[0]).add(edge[1]);
        }
        return edges;
      }
      function makeNodesHash(arr) {
        var res = /* @__PURE__ */ new Map();
        for (var i = 0, len = arr.length; i < len; i++) {
          res.set(arr[i], i);
        }
        return res;
      }
      return toposort$1.exports;
    }
    var toposortExports = requireToposort();
    const toposort = /* @__PURE__ */ getDefaultExportFromCjs(toposortExports);
    const toString = Object.prototype.toString;
    const errorToString = Error.prototype.toString;
    const regExpToString = RegExp.prototype.toString;
    const symbolToString = typeof Symbol !== "undefined" ? Symbol.prototype.toString : () => "";
    const SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
    function printNumber(val) {
      if (val != +val) return "NaN";
      const isNegativeZero = val === 0 && 1 / val < 0;
      return isNegativeZero ? "-0" : "" + val;
    }
    function printSimpleValue(val, quoteStrings = false) {
      if (val == null || val === true || val === false) return "" + val;
      const typeOf = typeof val;
      if (typeOf === "number") return printNumber(val);
      if (typeOf === "string") return quoteStrings ? `"${val}"` : val;
      if (typeOf === "function") return "[Function " + (val.name || "anonymous") + "]";
      if (typeOf === "symbol") return symbolToString.call(val).replace(SYMBOL_REGEXP, "Symbol($1)");
      const tag = toString.call(val).slice(8, -1);
      if (tag === "Date") return isNaN(val.getTime()) ? "" + val : val.toISOString(val);
      if (tag === "Error" || val instanceof Error) return "[" + errorToString.call(val) + "]";
      if (tag === "RegExp") return regExpToString.call(val);
      return null;
    }
    function printValue(value, quoteStrings) {
      let result = printSimpleValue(value, quoteStrings);
      if (result !== null) return result;
      return JSON.stringify(value, function(key, value2) {
        let result2 = printSimpleValue(this[key], quoteStrings);
        if (result2 !== null) return result2;
        return value2;
      }, 2);
    }
    function toArray(value) {
      return value == null ? [] : [].concat(value);
    }
    let _Symbol$toStringTag, _Symbol$hasInstance, _Symbol$toStringTag2;
    let strReg = /\$\{\s*(\w+)\s*\}/g;
    _Symbol$toStringTag = Symbol.toStringTag;
    class ValidationErrorNoStack {
      constructor(errorOrErrors, value, field, type) {
        this.name = void 0;
        this.message = void 0;
        this.value = void 0;
        this.path = void 0;
        this.type = void 0;
        this.params = void 0;
        this.errors = void 0;
        this.inner = void 0;
        this[_Symbol$toStringTag] = "Error";
        this.name = "ValidationError";
        this.value = value;
        this.path = field;
        this.type = type;
        this.errors = [];
        this.inner = [];
        toArray(errorOrErrors).forEach((err) => {
          if (ValidationError.isError(err)) {
            this.errors.push(...err.errors);
            const innerErrors = err.inner.length ? err.inner : [err];
            this.inner.push(...innerErrors);
          } else {
            this.errors.push(err);
          }
        });
        this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0];
      }
    }
    _Symbol$hasInstance = Symbol.hasInstance;
    _Symbol$toStringTag2 = Symbol.toStringTag;
    class ValidationError extends Error {
      static formatError(message, params) {
        const path = params.label || params.path || "this";
        params = Object.assign({}, params, {
          path,
          originalPath: params.path
        });
        if (typeof message === "string") return message.replace(strReg, (_, key) => printValue(params[key]));
        if (typeof message === "function") return message(params);
        return message;
      }
      static isError(err) {
        return err && err.name === "ValidationError";
      }
      constructor(errorOrErrors, value, field, type, disableStack) {
        const errorNoStack = new ValidationErrorNoStack(errorOrErrors, value, field, type);
        if (disableStack) {
          return errorNoStack;
        }
        super();
        this.value = void 0;
        this.path = void 0;
        this.type = void 0;
        this.params = void 0;
        this.errors = [];
        this.inner = [];
        this[_Symbol$toStringTag2] = "Error";
        this.name = errorNoStack.name;
        this.message = errorNoStack.message;
        this.type = errorNoStack.type;
        this.value = errorNoStack.value;
        this.path = errorNoStack.path;
        this.errors = errorNoStack.errors;
        this.inner = errorNoStack.inner;
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, ValidationError);
        }
      }
      static [_Symbol$hasInstance](inst) {
        return ValidationErrorNoStack[Symbol.hasInstance](inst) || super[Symbol.hasInstance](inst);
      }
    }
    let mixed = {
      default: "${path} is invalid",
      required: "${path} is a required field",
      defined: "${path} must be defined",
      notNull: "${path} cannot be null",
      oneOf: "${path} must be one of the following values: ${values}",
      notOneOf: "${path} must not be one of the following values: ${values}",
      notType: ({
        path,
        type,
        value,
        originalValue
      }) => {
        const castMsg = originalValue != null && originalValue !== value ? ` (cast from the value \`${printValue(originalValue, true)}\`).` : ".";
        return type !== "mixed" ? `${path} must be a \`${type}\` type, but the final value was: \`${printValue(value, true)}\`` + castMsg : `${path} must match the configured type. The validated value was: \`${printValue(value, true)}\`` + castMsg;
      }
    };
    let string = {
      length: "${path} must be exactly ${length} characters",
      min: "${path} must be at least ${min} characters",
      max: "${path} must be at most ${max} characters",
      matches: '${path} must match the following: "${regex}"',
      email: "${path} must be a valid email",
      url: "${path} must be a valid URL",
      uuid: "${path} must be a valid UUID",
      datetime: "${path} must be a valid ISO date-time",
      datetime_precision: "${path} must be a valid ISO date-time with a sub-second precision of exactly ${precision} digits",
      datetime_offset: '${path} must be a valid ISO date-time with UTC "Z" timezone',
      trim: "${path} must be a trimmed string",
      lowercase: "${path} must be a lowercase string",
      uppercase: "${path} must be a upper case string"
    };
    let number = {
      min: "${path} must be greater than or equal to ${min}",
      max: "${path} must be less than or equal to ${max}",
      lessThan: "${path} must be less than ${less}",
      moreThan: "${path} must be greater than ${more}",
      positive: "${path} must be a positive number",
      negative: "${path} must be a negative number",
      integer: "${path} must be an integer"
    };
    let date = {
      min: "${path} field must be later than ${min}",
      max: "${path} field must be at earlier than ${max}"
    };
    let boolean = {
      isValue: "${path} field must be ${value}"
    };
    let object = {
      noUnknown: "${path} field has unspecified keys: ${unknown}",
      exact: "${path} object contains unknown properties: ${properties}"
    };
    let array = {
      min: "${path} field must have at least ${min} items",
      max: "${path} field must have less than or equal to ${max} items",
      length: "${path} must have ${length} items"
    };
    let tuple = {
      notType: (params) => {
        const {
          path,
          value,
          spec
        } = params;
        const typeLen = spec.types.length;
        if (Array.isArray(value)) {
          if (value.length < typeLen) return `${path} tuple value has too few items, expected a length of ${typeLen} but got ${value.length} for value: \`${printValue(value, true)}\``;
          if (value.length > typeLen) return `${path} tuple value has too many items, expected a length of ${typeLen} but got ${value.length} for value: \`${printValue(value, true)}\``;
        }
        return ValidationError.formatError(mixed.notType, params);
      }
    };
    var locale = Object.assign(/* @__PURE__ */ Object.create(null), {
      mixed,
      string,
      number,
      date,
      object,
      array,
      boolean,
      tuple
    });
    const isSchema = (obj) => obj && obj.__isYupSchema__;
    class Condition {
      static fromOptions(refs, config) {
        if (!config.then && !config.otherwise) throw new TypeError("either `then:` or `otherwise:` is required for `when()` conditions");
        let {
          is: is2,
          then,
          otherwise
        } = config;
        let check = typeof is2 === "function" ? is2 : (...values) => values.every((value) => value === is2);
        return new Condition(refs, (values, schema) => {
          var _branch;
          let branch = check(...values) ? then : otherwise;
          return (_branch = branch == null ? void 0 : branch(schema)) != null ? _branch : schema;
        });
      }
      constructor(refs, builder) {
        this.fn = void 0;
        this.refs = refs;
        this.refs = refs;
        this.fn = builder;
      }
      resolve(base, options) {
        let values = this.refs.map((ref) => (
          // TODO: ? operator here?
          ref.getValue(options == null ? void 0 : options.value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context)
        ));
        let schema = this.fn(values, base, options);
        if (schema === void 0 || // @ts-ignore this can be base
        schema === base) {
          return base;
        }
        if (!isSchema(schema)) throw new TypeError("conditions must return a schema object");
        return schema.resolve(options);
      }
    }
    const prefixes = {
      context: "$",
      value: "."
    };
    function create$9(key, options) {
      return new Reference(key, options);
    }
    class Reference {
      constructor(key, options = {}) {
        this.key = void 0;
        this.isContext = void 0;
        this.isValue = void 0;
        this.isSibling = void 0;
        this.path = void 0;
        this.getter = void 0;
        this.map = void 0;
        if (typeof key !== "string") throw new TypeError("ref must be a string, got: " + key);
        this.key = key.trim();
        if (key === "") throw new TypeError("ref must be a non-empty string");
        this.isContext = this.key[0] === prefixes.context;
        this.isValue = this.key[0] === prefixes.value;
        this.isSibling = !this.isContext && !this.isValue;
        let prefix = this.isContext ? prefixes.context : this.isValue ? prefixes.value : "";
        this.path = this.key.slice(prefix.length);
        this.getter = this.path && propertyExprExports.getter(this.path, true);
        this.map = options.map;
      }
      getValue(value, parent, context) {
        let result = this.isContext ? context : this.isValue ? value : parent;
        if (this.getter) result = this.getter(result || {});
        if (this.map) result = this.map(result);
        return result;
      }
      /**
       *
       * @param {*} value
       * @param {Object} options
       * @param {Object=} options.context
       * @param {Object=} options.parent
       */
      cast(value, options) {
        return this.getValue(value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context);
      }
      resolve() {
        return this;
      }
      describe() {
        return {
          type: "ref",
          key: this.key
        };
      }
      toString() {
        return `Ref(${this.key})`;
      }
      static isRef(value) {
        return value && value.__isYupRef;
      }
    }
    Reference.prototype.__isYupRef = true;
    const isAbsent = (value) => value == null;
    function createValidation(config) {
      function validate({
        value,
        path = "",
        options,
        originalValue,
        schema
      }, panic, next) {
        const {
          name,
          test,
          params,
          message,
          skipAbsent
        } = config;
        let {
          parent,
          context,
          abortEarly = schema.spec.abortEarly,
          disableStackTrace = schema.spec.disableStackTrace
        } = options;
        const resolveOptions = {
          value,
          parent,
          context
        };
        function createError(overrides = {}) {
          const nextParams = resolveParams(Object.assign({
            value,
            originalValue,
            label: schema.spec.label,
            path: overrides.path || path,
            spec: schema.spec,
            disableStackTrace: overrides.disableStackTrace || disableStackTrace
          }, params, overrides.params), resolveOptions);
          const error = new ValidationError(ValidationError.formatError(overrides.message || message, nextParams), value, nextParams.path, overrides.type || name, nextParams.disableStackTrace);
          error.params = nextParams;
          return error;
        }
        const invalid = abortEarly ? panic : next;
        let ctx = {
          path,
          parent,
          type: name,
          from: options.from,
          createError,
          resolve(item) {
            return resolveMaybeRef(item, resolveOptions);
          },
          options,
          originalValue,
          schema
        };
        const handleResult = (validOrError) => {
          if (ValidationError.isError(validOrError)) invalid(validOrError);
          else if (!validOrError) invalid(createError());
          else next(null);
        };
        const handleError = (err) => {
          if (ValidationError.isError(err)) invalid(err);
          else panic(err);
        };
        const shouldSkip = skipAbsent && isAbsent(value);
        if (shouldSkip) {
          return handleResult(true);
        }
        let result;
        try {
          var _result;
          result = test.call(ctx, value, ctx);
          if (typeof ((_result = result) == null ? void 0 : _result.then) === "function") {
            if (options.sync) {
              throw new Error(`Validation test of type: "${ctx.type}" returned a Promise during a synchronous validate. This test will finish after the validate call has returned`);
            }
            return Promise.resolve(result).then(handleResult, handleError);
          }
        } catch (err) {
          handleError(err);
          return;
        }
        handleResult(result);
      }
      validate.OPTIONS = config;
      return validate;
    }
    function resolveParams(params, options) {
      if (!params) return params;
      for (const key of Object.keys(params)) {
        params[key] = resolveMaybeRef(params[key], options);
      }
      return params;
    }
    function resolveMaybeRef(item, options) {
      return Reference.isRef(item) ? item.getValue(options.value, options.parent, options.context) : item;
    }
    function getIn(schema, path, value, context = value) {
      let parent, lastPart, lastPartDebug;
      if (!path) return {
        parent,
        parentPath: path,
        schema
      };
      propertyExprExports.forEach(path, (_part, isBracket, isArray2) => {
        let part = isBracket ? _part.slice(1, _part.length - 1) : _part;
        schema = schema.resolve({
          context,
          parent,
          value
        });
        let isTuple = schema.type === "tuple";
        let idx = isArray2 ? parseInt(part, 10) : 0;
        if (schema.innerType || isTuple) {
          if (isTuple && !isArray2) throw new Error(`Yup.reach cannot implicitly index into a tuple type. the path part "${lastPartDebug}" must contain an index to the tuple element, e.g. "${lastPartDebug}[0]"`);
          if (value && idx >= value.length) {
            throw new Error(`Yup.reach cannot resolve an array item at index: ${_part}, in the path: ${path}. because there is no value at that index. `);
          }
          parent = value;
          value = value && value[idx];
          schema = isTuple ? schema.spec.types[idx] : schema.innerType;
        }
        if (!isArray2) {
          if (!schema.fields || !schema.fields[part]) throw new Error(`The schema does not contain the path: ${path}. (failed at: ${lastPartDebug} which is a type: "${schema.type}")`);
          parent = value;
          value = value && value[part];
          schema = schema.fields[part];
        }
        lastPart = part;
        lastPartDebug = isBracket ? "[" + _part + "]" : "." + _part;
      });
      return {
        schema,
        parent,
        parentPath: lastPart
      };
    }
    function reach(obj, path, value, context) {
      return getIn(obj, path, value, context).schema;
    }
    class ReferenceSet extends Set {
      describe() {
        const description = [];
        for (const item of this.values()) {
          description.push(Reference.isRef(item) ? item.describe() : item);
        }
        return description;
      }
      resolveAll(resolve) {
        let result = [];
        for (const item of this.values()) {
          result.push(resolve(item));
        }
        return result;
      }
      clone() {
        return new ReferenceSet(this.values());
      }
      merge(newItems, removeItems) {
        const next = this.clone();
        newItems.forEach((value) => next.add(value));
        removeItems.forEach((value) => next.delete(value));
        return next;
      }
    }
    function clone(src, seen = /* @__PURE__ */ new Map()) {
      if (isSchema(src) || !src || typeof src !== "object") return src;
      if (seen.has(src)) return seen.get(src);
      let copy;
      if (src instanceof Date) {
        copy = new Date(src.getTime());
        seen.set(src, copy);
      } else if (src instanceof RegExp) {
        copy = new RegExp(src);
        seen.set(src, copy);
      } else if (Array.isArray(src)) {
        copy = new Array(src.length);
        seen.set(src, copy);
        for (let i = 0; i < src.length; i++) copy[i] = clone(src[i], seen);
      } else if (src instanceof Map) {
        copy = /* @__PURE__ */ new Map();
        seen.set(src, copy);
        for (const [k, v] of src.entries()) copy.set(k, clone(v, seen));
      } else if (src instanceof Set) {
        copy = /* @__PURE__ */ new Set();
        seen.set(src, copy);
        for (const v of src) copy.add(clone(v, seen));
      } else if (src instanceof Object) {
        copy = {};
        seen.set(src, copy);
        for (const [k, v] of Object.entries(src)) copy[k] = clone(v, seen);
      } else {
        throw Error(`Unable to clone ${src}`);
      }
      return copy;
    }
    function createStandardPath(path) {
      if (!(path != null && path.length)) {
        return void 0;
      }
      const segments = [];
      let currentSegment = "";
      let inBrackets = false;
      let inQuotes = false;
      for (let i = 0; i < path.length; i++) {
        const char = path[i];
        if (char === "[" && !inQuotes) {
          if (currentSegment) {
            segments.push(...currentSegment.split(".").filter(Boolean));
            currentSegment = "";
          }
          inBrackets = true;
          continue;
        }
        if (char === "]" && !inQuotes) {
          if (currentSegment) {
            if (/^\d+$/.test(currentSegment)) {
              segments.push(currentSegment);
            } else {
              segments.push(currentSegment.replace(/^"|"$/g, ""));
            }
            currentSegment = "";
          }
          inBrackets = false;
          continue;
        }
        if (char === '"') {
          inQuotes = !inQuotes;
          continue;
        }
        if (char === "." && !inBrackets && !inQuotes) {
          if (currentSegment) {
            segments.push(currentSegment);
            currentSegment = "";
          }
          continue;
        }
        currentSegment += char;
      }
      if (currentSegment) {
        segments.push(...currentSegment.split(".").filter(Boolean));
      }
      return segments;
    }
    function createStandardIssues(error, parentPath) {
      const path = parentPath ? `${parentPath}.${error.path}` : error.path;
      return error.errors.map((err) => ({
        message: err,
        path: createStandardPath(path)
      }));
    }
    function issuesFromValidationError(error, parentPath) {
      var _error$inner;
      if (!((_error$inner = error.inner) != null && _error$inner.length) && error.errors.length) {
        return createStandardIssues(error, parentPath);
      }
      const path = parentPath ? `${parentPath}.${error.path}` : error.path;
      return error.inner.flatMap((err) => issuesFromValidationError(err, path));
    }
    class Schema {
      constructor(options) {
        this.type = void 0;
        this.deps = [];
        this.tests = void 0;
        this.transforms = void 0;
        this.conditions = [];
        this._mutate = void 0;
        this.internalTests = {};
        this._whitelist = new ReferenceSet();
        this._blacklist = new ReferenceSet();
        this.exclusiveTests = /* @__PURE__ */ Object.create(null);
        this._typeCheck = void 0;
        this.spec = void 0;
        this.tests = [];
        this.transforms = [];
        this.withMutation(() => {
          this.typeError(mixed.notType);
        });
        this.type = options.type;
        this._typeCheck = options.check;
        this.spec = Object.assign({
          strip: false,
          strict: false,
          abortEarly: true,
          recursive: true,
          disableStackTrace: false,
          nullable: false,
          optional: true,
          coerce: true
        }, options == null ? void 0 : options.spec);
        this.withMutation((s) => {
          s.nonNullable();
        });
      }
      // TODO: remove
      get _type() {
        return this.type;
      }
      clone(spec) {
        if (this._mutate) {
          if (spec) Object.assign(this.spec, spec);
          return this;
        }
        const next = Object.create(Object.getPrototypeOf(this));
        next.type = this.type;
        next._typeCheck = this._typeCheck;
        next._whitelist = this._whitelist.clone();
        next._blacklist = this._blacklist.clone();
        next.internalTests = Object.assign({}, this.internalTests);
        next.exclusiveTests = Object.assign({}, this.exclusiveTests);
        next.deps = [...this.deps];
        next.conditions = [...this.conditions];
        next.tests = [...this.tests];
        next.transforms = [...this.transforms];
        next.spec = clone(Object.assign({}, this.spec, spec));
        return next;
      }
      label(label) {
        let next = this.clone();
        next.spec.label = label;
        return next;
      }
      meta(...args) {
        if (args.length === 0) return this.spec.meta;
        let next = this.clone();
        next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);
        return next;
      }
      withMutation(fn) {
        let before = this._mutate;
        this._mutate = true;
        let result = fn(this);
        this._mutate = before;
        return result;
      }
      concat(schema) {
        if (!schema || schema === this) return this;
        if (schema.type !== this.type && this.type !== "mixed") throw new TypeError(`You cannot \`concat()\` schema's of different types: ${this.type} and ${schema.type}`);
        let base = this;
        let combined = schema.clone();
        const mergedSpec = Object.assign({}, base.spec, combined.spec);
        combined.spec = mergedSpec;
        combined.internalTests = Object.assign({}, base.internalTests, combined.internalTests);
        combined._whitelist = base._whitelist.merge(schema._whitelist, schema._blacklist);
        combined._blacklist = base._blacklist.merge(schema._blacklist, schema._whitelist);
        combined.tests = base.tests;
        combined.exclusiveTests = base.exclusiveTests;
        combined.withMutation((next) => {
          schema.tests.forEach((fn) => {
            next.test(fn.OPTIONS);
          });
        });
        combined.transforms = [...base.transforms, ...combined.transforms];
        return combined;
      }
      isType(v) {
        if (v == null) {
          if (this.spec.nullable && v === null) return true;
          if (this.spec.optional && v === void 0) return true;
          return false;
        }
        return this._typeCheck(v);
      }
      resolve(options) {
        let schema = this;
        if (schema.conditions.length) {
          let conditions = schema.conditions;
          schema = schema.clone();
          schema.conditions = [];
          schema = conditions.reduce((prevSchema, condition) => condition.resolve(prevSchema, options), schema);
          schema = schema.resolve(options);
        }
        return schema;
      }
      resolveOptions(options) {
        var _options$strict, _options$abortEarly, _options$recursive, _options$disableStack;
        return Object.assign({}, options, {
          from: options.from || [],
          strict: (_options$strict = options.strict) != null ? _options$strict : this.spec.strict,
          abortEarly: (_options$abortEarly = options.abortEarly) != null ? _options$abortEarly : this.spec.abortEarly,
          recursive: (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive,
          disableStackTrace: (_options$disableStack = options.disableStackTrace) != null ? _options$disableStack : this.spec.disableStackTrace
        });
      }
      /**
       * Run the configured transform pipeline over an input value.
       */
      cast(value, options = {}) {
        let resolvedSchema = this.resolve(Object.assign({
          value
        }, options));
        let allowOptionality = options.assert === "ignore-optionality";
        let result = resolvedSchema._cast(value, options);
        if (options.assert !== false && !resolvedSchema.isType(result)) {
          if (allowOptionality && isAbsent(result)) {
            return result;
          }
          let formattedValue = printValue(value);
          let formattedResult = printValue(result);
          throw new TypeError(`The value of ${options.path || "field"} could not be cast to a value that satisfies the schema type: "${resolvedSchema.type}". 

attempted value: ${formattedValue} 
` + (formattedResult !== formattedValue ? `result of cast: ${formattedResult}` : ""));
        }
        return result;
      }
      _cast(rawValue, options) {
        let value = rawValue === void 0 ? rawValue : this.transforms.reduce((prevValue, fn) => fn.call(this, prevValue, rawValue, this), rawValue);
        if (value === void 0) {
          value = this.getDefault(options);
        }
        return value;
      }
      _validate(_value, options = {}, panic, next) {
        let {
          path,
          originalValue = _value,
          strict = this.spec.strict
        } = options;
        let value = _value;
        if (!strict) {
          value = this._cast(value, Object.assign({
            assert: false
          }, options));
        }
        let initialTests = [];
        for (let test of Object.values(this.internalTests)) {
          if (test) initialTests.push(test);
        }
        this.runTests({
          path,
          value,
          originalValue,
          options,
          tests: initialTests
        }, panic, (initialErrors) => {
          if (initialErrors.length) {
            return next(initialErrors, value);
          }
          this.runTests({
            path,
            value,
            originalValue,
            options,
            tests: this.tests
          }, panic, next);
        });
      }
      /**
       * Executes a set of validations, either schema, produced Tests or a nested
       * schema validate result.
       */
      runTests(runOptions, panic, next) {
        let fired = false;
        let {
          tests,
          value,
          originalValue,
          path,
          options
        } = runOptions;
        let panicOnce = (arg) => {
          if (fired) return;
          fired = true;
          panic(arg, value);
        };
        let nextOnce = (arg) => {
          if (fired) return;
          fired = true;
          next(arg, value);
        };
        let count = tests.length;
        let nestedErrors = [];
        if (!count) return nextOnce([]);
        let args = {
          value,
          originalValue,
          path,
          options,
          schema: this
        };
        for (let i = 0; i < tests.length; i++) {
          const test = tests[i];
          test(args, panicOnce, function finishTestRun(err) {
            if (err) {
              Array.isArray(err) ? nestedErrors.push(...err) : nestedErrors.push(err);
            }
            if (--count <= 0) {
              nextOnce(nestedErrors);
            }
          });
        }
      }
      asNestedTest({
        key,
        index,
        parent,
        parentPath,
        originalParent,
        options
      }) {
        const k = key != null ? key : index;
        if (k == null) {
          throw TypeError("Must include `key` or `index` for nested validations");
        }
        const isIndex2 = typeof k === "number";
        let value = parent[k];
        const testOptions = Object.assign({}, options, {
          // Nested validations fields are always strict:
          //    1. parent isn't strict so the casting will also have cast inner values
          //    2. parent is strict in which case the nested values weren't cast either
          strict: true,
          parent,
          value,
          originalValue: originalParent[k],
          // FIXME: tests depend on `index` being passed around deeply,
          //   we should not let the options.key/index bleed through
          key: void 0,
          // index: undefined,
          [isIndex2 ? "index" : "key"]: k,
          path: isIndex2 || k.includes(".") ? `${parentPath || ""}[${isIndex2 ? k : `"${k}"`}]` : (parentPath ? `${parentPath}.` : "") + key
        });
        return (_, panic, next) => this.resolve(testOptions)._validate(value, testOptions, panic, next);
      }
      validate(value, options) {
        var _options$disableStack2;
        let schema = this.resolve(Object.assign({}, options, {
          value
        }));
        let disableStackTrace = (_options$disableStack2 = options == null ? void 0 : options.disableStackTrace) != null ? _options$disableStack2 : schema.spec.disableStackTrace;
        return new Promise((resolve, reject) => schema._validate(value, options, (error, parsed) => {
          if (ValidationError.isError(error)) error.value = parsed;
          reject(error);
        }, (errors, validated) => {
          if (errors.length) reject(new ValidationError(errors, validated, void 0, void 0, disableStackTrace));
          else resolve(validated);
        }));
      }
      validateSync(value, options) {
        var _options$disableStack3;
        let schema = this.resolve(Object.assign({}, options, {
          value
        }));
        let result;
        let disableStackTrace = (_options$disableStack3 = options == null ? void 0 : options.disableStackTrace) != null ? _options$disableStack3 : schema.spec.disableStackTrace;
        schema._validate(value, Object.assign({}, options, {
          sync: true
        }), (error, parsed) => {
          if (ValidationError.isError(error)) error.value = parsed;
          throw error;
        }, (errors, validated) => {
          if (errors.length) throw new ValidationError(errors, value, void 0, void 0, disableStackTrace);
          result = validated;
        });
        return result;
      }
      isValid(value, options) {
        return this.validate(value, options).then(() => true, (err) => {
          if (ValidationError.isError(err)) return false;
          throw err;
        });
      }
      isValidSync(value, options) {
        try {
          this.validateSync(value, options);
          return true;
        } catch (err) {
          if (ValidationError.isError(err)) return false;
          throw err;
        }
      }
      _getDefault(options) {
        let defaultValue = this.spec.default;
        if (defaultValue == null) {
          return defaultValue;
        }
        return typeof defaultValue === "function" ? defaultValue.call(this, options) : clone(defaultValue);
      }
      getDefault(options) {
        let schema = this.resolve(options || {});
        return schema._getDefault(options);
      }
      default(def) {
        if (arguments.length === 0) {
          return this._getDefault();
        }
        let next = this.clone({
          default: def
        });
        return next;
      }
      strict(isStrict = true) {
        return this.clone({
          strict: isStrict
        });
      }
      nullability(nullable, message) {
        const next = this.clone({
          nullable
        });
        next.internalTests.nullable = createValidation({
          message,
          name: "nullable",
          test(value) {
            return value === null ? this.schema.spec.nullable : true;
          }
        });
        return next;
      }
      optionality(optional, message) {
        const next = this.clone({
          optional
        });
        next.internalTests.optionality = createValidation({
          message,
          name: "optionality",
          test(value) {
            return value === void 0 ? this.schema.spec.optional : true;
          }
        });
        return next;
      }
      optional() {
        return this.optionality(true);
      }
      defined(message = mixed.defined) {
        return this.optionality(false, message);
      }
      nullable() {
        return this.nullability(true);
      }
      nonNullable(message = mixed.notNull) {
        return this.nullability(false, message);
      }
      required(message = mixed.required) {
        return this.clone().withMutation((next) => next.nonNullable(message).defined(message));
      }
      notRequired() {
        return this.clone().withMutation((next) => next.nullable().optional());
      }
      transform(fn) {
        let next = this.clone();
        next.transforms.push(fn);
        return next;
      }
      /**
       * Adds a test function to the schema's queue of tests.
       * tests can be exclusive or non-exclusive.
       *
       * - exclusive tests, will replace any existing tests of the same name.
       * - non-exclusive: can be stacked
       *
       * If a non-exclusive test is added to a schema with an exclusive test of the same name
       * the exclusive test is removed and further tests of the same name will be stacked.
       *
       * If an exclusive test is added to a schema with non-exclusive tests of the same name
       * the previous tests are removed and further tests of the same name will replace each other.
       */
      test(...args) {
        let opts;
        if (args.length === 1) {
          if (typeof args[0] === "function") {
            opts = {
              test: args[0]
            };
          } else {
            opts = args[0];
          }
        } else if (args.length === 2) {
          opts = {
            name: args[0],
            test: args[1]
          };
        } else {
          opts = {
            name: args[0],
            message: args[1],
            test: args[2]
          };
        }
        if (opts.message === void 0) opts.message = mixed.default;
        if (typeof opts.test !== "function") throw new TypeError("`test` is a required parameters");
        let next = this.clone();
        let validate = createValidation(opts);
        let isExclusive = opts.exclusive || opts.name && next.exclusiveTests[opts.name] === true;
        if (opts.exclusive) {
          if (!opts.name) throw new TypeError("Exclusive tests must provide a unique `name` identifying the test");
        }
        if (opts.name) next.exclusiveTests[opts.name] = !!opts.exclusive;
        next.tests = next.tests.filter((fn) => {
          if (fn.OPTIONS.name === opts.name) {
            if (isExclusive) return false;
            if (fn.OPTIONS.test === validate.OPTIONS.test) return false;
          }
          return true;
        });
        next.tests.push(validate);
        return next;
      }
      when(keys2, options) {
        if (!Array.isArray(keys2) && typeof keys2 !== "string") {
          options = keys2;
          keys2 = ".";
        }
        let next = this.clone();
        let deps = toArray(keys2).map((key) => new Reference(key));
        deps.forEach((dep) => {
          if (dep.isSibling) next.deps.push(dep.key);
        });
        next.conditions.push(typeof options === "function" ? new Condition(deps, options) : Condition.fromOptions(deps, options));
        return next;
      }
      typeError(message) {
        let next = this.clone();
        next.internalTests.typeError = createValidation({
          message,
          name: "typeError",
          skipAbsent: true,
          test(value) {
            if (!this.schema._typeCheck(value)) return this.createError({
              params: {
                type: this.schema.type
              }
            });
            return true;
          }
        });
        return next;
      }
      oneOf(enums, message = mixed.oneOf) {
        let next = this.clone();
        enums.forEach((val) => {
          next._whitelist.add(val);
          next._blacklist.delete(val);
        });
        next.internalTests.whiteList = createValidation({
          message,
          name: "oneOf",
          skipAbsent: true,
          test(value) {
            let valids = this.schema._whitelist;
            let resolved = valids.resolveAll(this.resolve);
            return resolved.includes(value) ? true : this.createError({
              params: {
                values: Array.from(valids).join(", "),
                resolved
              }
            });
          }
        });
        return next;
      }
      notOneOf(enums, message = mixed.notOneOf) {
        let next = this.clone();
        enums.forEach((val) => {
          next._blacklist.add(val);
          next._whitelist.delete(val);
        });
        next.internalTests.blacklist = createValidation({
          message,
          name: "notOneOf",
          test(value) {
            let invalids = this.schema._blacklist;
            let resolved = invalids.resolveAll(this.resolve);
            if (resolved.includes(value)) return this.createError({
              params: {
                values: Array.from(invalids).join(", "),
                resolved
              }
            });
            return true;
          }
        });
        return next;
      }
      strip(strip = true) {
        let next = this.clone();
        next.spec.strip = strip;
        return next;
      }
      /**
       * Return a serialized description of the schema including validations, flags, types etc.
       *
       * @param options Provide any needed context for resolving runtime schema alterations (lazy, when conditions, etc).
       */
      describe(options) {
        const next = (options ? this.resolve(options) : this).clone();
        const {
          label,
          meta,
          optional,
          nullable
        } = next.spec;
        const description = {
          meta,
          label,
          optional,
          nullable,
          default: next.getDefault(options),
          type: next.type,
          oneOf: next._whitelist.describe(),
          notOneOf: next._blacklist.describe(),
          tests: next.tests.filter((n, idx, list) => list.findIndex((c) => c.OPTIONS.name === n.OPTIONS.name) === idx).map((fn) => {
            const params = fn.OPTIONS.params && options ? resolveParams(Object.assign({}, fn.OPTIONS.params), options) : fn.OPTIONS.params;
            return {
              name: fn.OPTIONS.name,
              params
            };
          })
        };
        return description;
      }
      get ["~standard"]() {
        const schema = this;
        const standard = {
          version: 1,
          vendor: "yup",
          async validate(value) {
            try {
              const result = await schema.validate(value, {
                abortEarly: false
              });
              return {
                value: result
              };
            } catch (err) {
              if (err instanceof ValidationError) {
                return {
                  issues: issuesFromValidationError(err)
                };
              }
              throw err;
            }
          }
        };
        return standard;
      }
    }
    Schema.prototype.__isYupSchema__ = true;
    for (const method of ["validate", "validateSync"]) Schema.prototype[`${method}At`] = function(path, value, options = {}) {
      const {
        parent,
        parentPath,
        schema
      } = getIn(this, path, value, options.context);
      return schema[method](parent && parent[parentPath], Object.assign({}, options, {
        parent,
        path
      }));
    };
    for (const alias of ["equals", "is"]) Schema.prototype[alias] = Schema.prototype.oneOf;
    for (const alias of ["not", "nope"]) Schema.prototype[alias] = Schema.prototype.notOneOf;
    const returnsTrue = () => true;
    function create$8(spec) {
      return new MixedSchema(spec);
    }
    class MixedSchema extends Schema {
      constructor(spec) {
        super(typeof spec === "function" ? {
          type: "mixed",
          check: spec
        } : Object.assign({
          type: "mixed",
          check: returnsTrue
        }, spec));
      }
    }
    create$8.prototype = MixedSchema.prototype;
    function create$7() {
      return new BooleanSchema();
    }
    class BooleanSchema extends Schema {
      constructor() {
        super({
          type: "boolean",
          check(v) {
            if (v instanceof Boolean) v = v.valueOf();
            return typeof v === "boolean";
          }
        });
        this.withMutation(() => {
          this.transform((value, _raw, ctx) => {
            if (ctx.spec.coerce && !ctx.isType(value)) {
              if (/^(true|1)$/i.test(String(value))) return true;
              if (/^(false|0)$/i.test(String(value))) return false;
            }
            return value;
          });
        });
      }
      isTrue(message = boolean.isValue) {
        return this.test({
          message,
          name: "is-value",
          exclusive: true,
          params: {
            value: "true"
          },
          test(value) {
            return isAbsent(value) || value === true;
          }
        });
      }
      isFalse(message = boolean.isValue) {
        return this.test({
          message,
          name: "is-value",
          exclusive: true,
          params: {
            value: "false"
          },
          test(value) {
            return isAbsent(value) || value === false;
          }
        });
      }
      default(def) {
        return super.default(def);
      }
      defined(msg) {
        return super.defined(msg);
      }
      optional() {
        return super.optional();
      }
      required(msg) {
        return super.required(msg);
      }
      notRequired() {
        return super.notRequired();
      }
      nullable() {
        return super.nullable();
      }
      nonNullable(msg) {
        return super.nonNullable(msg);
      }
      strip(v) {
        return super.strip(v);
      }
    }
    create$7.prototype = BooleanSchema.prototype;
    const isoReg = /^(\d{4}|[+-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,.](\d{1,}))?)?(?:(Z)|([+-])(\d{2})(?::?(\d{2}))?)?)?$/;
    function parseIsoDate(date2) {
      const struct = parseDateStruct(date2);
      if (!struct) return Date.parse ? Date.parse(date2) : Number.NaN;
      if (struct.z === void 0 && struct.plusMinus === void 0) {
        return new Date(struct.year, struct.month, struct.day, struct.hour, struct.minute, struct.second, struct.millisecond).valueOf();
      }
      let totalMinutesOffset = 0;
      if (struct.z !== "Z" && struct.plusMinus !== void 0) {
        totalMinutesOffset = struct.hourOffset * 60 + struct.minuteOffset;
        if (struct.plusMinus === "+") totalMinutesOffset = 0 - totalMinutesOffset;
      }
      return Date.UTC(struct.year, struct.month, struct.day, struct.hour, struct.minute + totalMinutesOffset, struct.second, struct.millisecond);
    }
    function parseDateStruct(date2) {
      var _regexResult$7$length, _regexResult$;
      const regexResult = isoReg.exec(date2);
      if (!regexResult) return null;
      return {
        year: toNumber(regexResult[1]),
        month: toNumber(regexResult[2], 1) - 1,
        day: toNumber(regexResult[3], 1),
        hour: toNumber(regexResult[4]),
        minute: toNumber(regexResult[5]),
        second: toNumber(regexResult[6]),
        millisecond: regexResult[7] ? (
          // allow arbitrary sub-second precision beyond milliseconds
          toNumber(regexResult[7].substring(0, 3))
        ) : 0,
        precision: (_regexResult$7$length = (_regexResult$ = regexResult[7]) == null ? void 0 : _regexResult$.length) != null ? _regexResult$7$length : void 0,
        z: regexResult[8] || void 0,
        plusMinus: regexResult[9] || void 0,
        hourOffset: toNumber(regexResult[10]),
        minuteOffset: toNumber(regexResult[11])
      };
    }
    function toNumber(str, defaultValue = 0) {
      return Number(str) || defaultValue;
    }
    let rEmail = (
      // eslint-disable-next-line
      /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/
    );
    let rUrl = (
      // eslint-disable-next-line
      /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i
    );
    let rUUID = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    let yearMonthDay = "^\\d{4}-\\d{2}-\\d{2}";
    let hourMinuteSecond = "\\d{2}:\\d{2}:\\d{2}";
    let zOrOffset = "(([+-]\\d{2}(:?\\d{2})?)|Z)";
    let rIsoDateTime = new RegExp(`${yearMonthDay}T${hourMinuteSecond}(\\.\\d+)?${zOrOffset}$`);
    let isTrimmed = (value) => isAbsent(value) || value === value.trim();
    let objStringTag = {}.toString();
    function create$6() {
      return new StringSchema();
    }
    class StringSchema extends Schema {
      constructor() {
        super({
          type: "string",
          check(value) {
            if (value instanceof String) value = value.valueOf();
            return typeof value === "string";
          }
        });
        this.withMutation(() => {
          this.transform((value, _raw, ctx) => {
            if (!ctx.spec.coerce || ctx.isType(value)) return value;
            if (Array.isArray(value)) return value;
            const strValue = value != null && value.toString ? value.toString() : value;
            if (strValue === objStringTag) return value;
            return strValue;
          });
        });
      }
      required(message) {
        return super.required(message).withMutation((schema) => schema.test({
          message: message || mixed.required,
          name: "required",
          skipAbsent: true,
          test: (value) => !!value.length
        }));
      }
      notRequired() {
        return super.notRequired().withMutation((schema) => {
          schema.tests = schema.tests.filter((t) => t.OPTIONS.name !== "required");
          return schema;
        });
      }
      length(length, message = string.length) {
        return this.test({
          message,
          name: "length",
          exclusive: true,
          params: {
            length
          },
          skipAbsent: true,
          test(value) {
            return value.length === this.resolve(length);
          }
        });
      }
      min(min, message = string.min) {
        return this.test({
          message,
          name: "min",
          exclusive: true,
          params: {
            min
          },
          skipAbsent: true,
          test(value) {
            return value.length >= this.resolve(min);
          }
        });
      }
      max(max, message = string.max) {
        return this.test({
          name: "max",
          exclusive: true,
          message,
          params: {
            max
          },
          skipAbsent: true,
          test(value) {
            return value.length <= this.resolve(max);
          }
        });
      }
      matches(regex, options) {
        let excludeEmptyString = false;
        let message;
        let name;
        if (options) {
          if (typeof options === "object") {
            ({
              excludeEmptyString = false,
              message,
              name
            } = options);
          } else {
            message = options;
          }
        }
        return this.test({
          name: name || "matches",
          message: message || string.matches,
          params: {
            regex
          },
          skipAbsent: true,
          test: (value) => value === "" && excludeEmptyString || value.search(regex) !== -1
        });
      }
      email(message = string.email) {
        return this.matches(rEmail, {
          name: "email",
          message,
          excludeEmptyString: true
        });
      }
      url(message = string.url) {
        return this.matches(rUrl, {
          name: "url",
          message,
          excludeEmptyString: true
        });
      }
      uuid(message = string.uuid) {
        return this.matches(rUUID, {
          name: "uuid",
          message,
          excludeEmptyString: false
        });
      }
      datetime(options) {
        let message = "";
        let allowOffset;
        let precision;
        if (options) {
          if (typeof options === "object") {
            ({
              message = "",
              allowOffset = false,
              precision = void 0
            } = options);
          } else {
            message = options;
          }
        }
        return this.matches(rIsoDateTime, {
          name: "datetime",
          message: message || string.datetime,
          excludeEmptyString: true
        }).test({
          name: "datetime_offset",
          message: message || string.datetime_offset,
          params: {
            allowOffset
          },
          skipAbsent: true,
          test: (value) => {
            if (!value || allowOffset) return true;
            const struct = parseDateStruct(value);
            if (!struct) return false;
            return !!struct.z;
          }
        }).test({
          name: "datetime_precision",
          message: message || string.datetime_precision,
          params: {
            precision
          },
          skipAbsent: true,
          test: (value) => {
            if (!value || precision == void 0) return true;
            const struct = parseDateStruct(value);
            if (!struct) return false;
            return struct.precision === precision;
          }
        });
      }
      //-- transforms --
      ensure() {
        return this.default("").transform((val) => val === null ? "" : val);
      }
      trim(message = string.trim) {
        return this.transform((val) => val != null ? val.trim() : val).test({
          message,
          name: "trim",
          test: isTrimmed
        });
      }
      lowercase(message = string.lowercase) {
        return this.transform((value) => !isAbsent(value) ? value.toLowerCase() : value).test({
          message,
          name: "string_case",
          exclusive: true,
          skipAbsent: true,
          test: (value) => isAbsent(value) || value === value.toLowerCase()
        });
      }
      uppercase(message = string.uppercase) {
        return this.transform((value) => !isAbsent(value) ? value.toUpperCase() : value).test({
          message,
          name: "string_case",
          exclusive: true,
          skipAbsent: true,
          test: (value) => isAbsent(value) || value === value.toUpperCase()
        });
      }
    }
    create$6.prototype = StringSchema.prototype;
    let isNaN$1 = (value) => value != +value;
    function create$5() {
      return new NumberSchema();
    }
    class NumberSchema extends Schema {
      constructor() {
        super({
          type: "number",
          check(value) {
            if (value instanceof Number) value = value.valueOf();
            return typeof value === "number" && !isNaN$1(value);
          }
        });
        this.withMutation(() => {
          this.transform((value, _raw, ctx) => {
            if (!ctx.spec.coerce) return value;
            let parsed = value;
            if (typeof parsed === "string") {
              parsed = parsed.replace(/\s/g, "");
              if (parsed === "") return NaN;
              parsed = +parsed;
            }
            if (ctx.isType(parsed) || parsed === null) return parsed;
            return parseFloat(parsed);
          });
        });
      }
      min(min, message = number.min) {
        return this.test({
          message,
          name: "min",
          exclusive: true,
          params: {
            min
          },
          skipAbsent: true,
          test(value) {
            return value >= this.resolve(min);
          }
        });
      }
      max(max, message = number.max) {
        return this.test({
          message,
          name: "max",
          exclusive: true,
          params: {
            max
          },
          skipAbsent: true,
          test(value) {
            return value <= this.resolve(max);
          }
        });
      }
      lessThan(less, message = number.lessThan) {
        return this.test({
          message,
          name: "max",
          exclusive: true,
          params: {
            less
          },
          skipAbsent: true,
          test(value) {
            return value < this.resolve(less);
          }
        });
      }
      moreThan(more, message = number.moreThan) {
        return this.test({
          message,
          name: "min",
          exclusive: true,
          params: {
            more
          },
          skipAbsent: true,
          test(value) {
            return value > this.resolve(more);
          }
        });
      }
      positive(msg = number.positive) {
        return this.moreThan(0, msg);
      }
      negative(msg = number.negative) {
        return this.lessThan(0, msg);
      }
      integer(message = number.integer) {
        return this.test({
          name: "integer",
          message,
          skipAbsent: true,
          test: (val) => Number.isInteger(val)
        });
      }
      truncate() {
        return this.transform((value) => !isAbsent(value) ? value | 0 : value);
      }
      round(method) {
        var _method;
        let avail = ["ceil", "floor", "round", "trunc"];
        method = ((_method = method) == null ? void 0 : _method.toLowerCase()) || "round";
        if (method === "trunc") return this.truncate();
        if (avail.indexOf(method.toLowerCase()) === -1) throw new TypeError("Only valid options for round() are: " + avail.join(", "));
        return this.transform((value) => !isAbsent(value) ? Math[method](value) : value);
      }
    }
    create$5.prototype = NumberSchema.prototype;
    let invalidDate = /* @__PURE__ */ new Date("");
    let isDate = (obj) => Object.prototype.toString.call(obj) === "[object Date]";
    function create$4() {
      return new DateSchema();
    }
    class DateSchema extends Schema {
      constructor() {
        super({
          type: "date",
          check(v) {
            return isDate(v) && !isNaN(v.getTime());
          }
        });
        this.withMutation(() => {
          this.transform((value, _raw, ctx) => {
            if (!ctx.spec.coerce || ctx.isType(value) || value === null) return value;
            value = parseIsoDate(value);
            return !isNaN(value) ? new Date(value) : DateSchema.INVALID_DATE;
          });
        });
      }
      prepareParam(ref, name) {
        let param;
        if (!Reference.isRef(ref)) {
          let cast = this.cast(ref);
          if (!this._typeCheck(cast)) throw new TypeError(`\`${name}\` must be a Date or a value that can be \`cast()\` to a Date`);
          param = cast;
        } else {
          param = ref;
        }
        return param;
      }
      min(min, message = date.min) {
        let limit = this.prepareParam(min, "min");
        return this.test({
          message,
          name: "min",
          exclusive: true,
          params: {
            min
          },
          skipAbsent: true,
          test(value) {
            return value >= this.resolve(limit);
          }
        });
      }
      max(max, message = date.max) {
        let limit = this.prepareParam(max, "max");
        return this.test({
          message,
          name: "max",
          exclusive: true,
          params: {
            max
          },
          skipAbsent: true,
          test(value) {
            return value <= this.resolve(limit);
          }
        });
      }
    }
    DateSchema.INVALID_DATE = invalidDate;
    create$4.prototype = DateSchema.prototype;
    create$4.INVALID_DATE = invalidDate;
    function sortFields(fields, excludedEdges = []) {
      let edges = [];
      let nodes = /* @__PURE__ */ new Set();
      let excludes = new Set(excludedEdges.map(([a, b]) => `${a}-${b}`));
      function addNode(depPath, key) {
        let node = propertyExprExports.split(depPath)[0];
        nodes.add(node);
        if (!excludes.has(`${key}-${node}`)) edges.push([key, node]);
      }
      for (const key of Object.keys(fields)) {
        let value = fields[key];
        nodes.add(key);
        if (Reference.isRef(value) && value.isSibling) addNode(value.path, key);
        else if (isSchema(value) && "deps" in value) value.deps.forEach((path) => addNode(path, key));
      }
      return toposort.array(Array.from(nodes), edges).reverse();
    }
    function findIndex(arr, err) {
      let idx = Infinity;
      arr.some((key, ii) => {
        var _err$path;
        if ((_err$path = err.path) != null && _err$path.includes(key)) {
          idx = ii;
          return true;
        }
      });
      return idx;
    }
    function sortByKeyOrder(keys2) {
      return (a, b) => {
        return findIndex(keys2, a) - findIndex(keys2, b);
      };
    }
    const parseJson = (value, _, ctx) => {
      if (typeof value !== "string") {
        return value;
      }
      let parsed = value;
      try {
        parsed = JSON.parse(value);
      } catch (err) {
      }
      return ctx.isType(parsed) ? parsed : value;
    };
    function deepPartial(schema) {
      if ("fields" in schema) {
        const partial = {};
        for (const [key, fieldSchema] of Object.entries(schema.fields)) {
          partial[key] = deepPartial(fieldSchema);
        }
        return schema.setFields(partial);
      }
      if (schema.type === "array") {
        const nextArray = schema.optional();
        if (nextArray.innerType) nextArray.innerType = deepPartial(nextArray.innerType);
        return nextArray;
      }
      if (schema.type === "tuple") {
        return schema.optional().clone({
          types: schema.spec.types.map(deepPartial)
        });
      }
      if ("optional" in schema) {
        return schema.optional();
      }
      return schema;
    }
    const deepHas = (obj, p) => {
      const path = [...propertyExprExports.normalizePath(p)];
      if (path.length === 1) return path[0] in obj;
      let last = path.pop();
      let parent = propertyExprExports.getter(propertyExprExports.join(path), true)(obj);
      return !!(parent && last in parent);
    };
    let isObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]";
    function unknown(ctx, value) {
      let known = Object.keys(ctx.fields);
      return Object.keys(value).filter((key) => known.indexOf(key) === -1);
    }
    const defaultSort = sortByKeyOrder([]);
    function create$3(spec) {
      return new ObjectSchema(spec);
    }
    class ObjectSchema extends Schema {
      constructor(spec) {
        super({
          type: "object",
          check(value) {
            return isObject(value) || typeof value === "function";
          }
        });
        this.fields = /* @__PURE__ */ Object.create(null);
        this._sortErrors = defaultSort;
        this._nodes = [];
        this._excludedEdges = [];
        this.withMutation(() => {
          if (spec) {
            this.shape(spec);
          }
        });
      }
      _cast(_value, options = {}) {
        var _options$stripUnknown;
        let value = super._cast(_value, options);
        if (value === void 0) return this.getDefault(options);
        if (!this._typeCheck(value)) return value;
        let fields = this.fields;
        let strip = (_options$stripUnknown = options.stripUnknown) != null ? _options$stripUnknown : this.spec.noUnknown;
        let props = [].concat(this._nodes, Object.keys(value).filter((v) => !this._nodes.includes(v)));
        let intermediateValue = {};
        let innerOptions = Object.assign({}, options, {
          parent: intermediateValue,
          __validating: options.__validating || false
        });
        let isChanged = false;
        for (const prop of props) {
          let field = fields[prop];
          let exists = prop in value;
          if (field) {
            let fieldValue;
            let inputValue = value[prop];
            innerOptions.path = (options.path ? `${options.path}.` : "") + prop;
            field = field.resolve({
              value: inputValue,
              context: options.context,
              parent: intermediateValue
            });
            let fieldSpec = field instanceof Schema ? field.spec : void 0;
            let strict = fieldSpec == null ? void 0 : fieldSpec.strict;
            if (fieldSpec != null && fieldSpec.strip) {
              isChanged = isChanged || prop in value;
              continue;
            }
            fieldValue = !options.__validating || !strict ? (
              // TODO: use _cast, this is double resolving
              field.cast(value[prop], innerOptions)
            ) : value[prop];
            if (fieldValue !== void 0) {
              intermediateValue[prop] = fieldValue;
            }
          } else if (exists && !strip) {
            intermediateValue[prop] = value[prop];
          }
          if (exists !== prop in intermediateValue || intermediateValue[prop] !== value[prop]) {
            isChanged = true;
          }
        }
        return isChanged ? intermediateValue : value;
      }
      _validate(_value, options = {}, panic, next) {
        let {
          from = [],
          originalValue = _value,
          recursive = this.spec.recursive
        } = options;
        options.from = [{
          schema: this,
          value: originalValue
        }, ...from];
        options.__validating = true;
        options.originalValue = originalValue;
        super._validate(_value, options, panic, (objectErrors, value) => {
          if (!recursive || !isObject(value)) {
            next(objectErrors, value);
            return;
          }
          originalValue = originalValue || value;
          let tests = [];
          for (let key of this._nodes) {
            let field = this.fields[key];
            if (!field || Reference.isRef(field)) {
              continue;
            }
            tests.push(field.asNestedTest({
              options,
              key,
              parent: value,
              parentPath: options.path,
              originalParent: originalValue
            }));
          }
          this.runTests({
            tests,
            value,
            originalValue,
            options
          }, panic, (fieldErrors) => {
            next(fieldErrors.sort(this._sortErrors).concat(objectErrors), value);
          });
        });
      }
      clone(spec) {
        const next = super.clone(spec);
        next.fields = Object.assign({}, this.fields);
        next._nodes = this._nodes;
        next._excludedEdges = this._excludedEdges;
        next._sortErrors = this._sortErrors;
        return next;
      }
      concat(schema) {
        let next = super.concat(schema);
        let nextFields = next.fields;
        for (let [field, schemaOrRef] of Object.entries(this.fields)) {
          const target = nextFields[field];
          nextFields[field] = target === void 0 ? schemaOrRef : target;
        }
        return next.withMutation((s) => (
          // XXX: excludes here is wrong
          s.setFields(nextFields, [...this._excludedEdges, ...schema._excludedEdges])
        ));
      }
      _getDefault(options) {
        if ("default" in this.spec) {
          return super._getDefault(options);
        }
        if (!this._nodes.length) {
          return void 0;
        }
        let dft = {};
        this._nodes.forEach((key) => {
          var _innerOptions;
          const field = this.fields[key];
          let innerOptions = options;
          if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
            innerOptions = Object.assign({}, innerOptions, {
              parent: innerOptions.value,
              value: innerOptions.value[key]
            });
          }
          dft[key] = field && "getDefault" in field ? field.getDefault(innerOptions) : void 0;
        });
        return dft;
      }
      setFields(shape, excludedEdges) {
        let next = this.clone();
        next.fields = shape;
        next._nodes = sortFields(shape, excludedEdges);
        next._sortErrors = sortByKeyOrder(Object.keys(shape));
        if (excludedEdges) next._excludedEdges = excludedEdges;
        return next;
      }
      shape(additions, excludes = []) {
        return this.clone().withMutation((next) => {
          let edges = next._excludedEdges;
          if (excludes.length) {
            if (!Array.isArray(excludes[0])) excludes = [excludes];
            edges = [...next._excludedEdges, ...excludes];
          }
          return next.setFields(Object.assign(next.fields, additions), edges);
        });
      }
      partial() {
        const partial = {};
        for (const [key, schema] of Object.entries(this.fields)) {
          partial[key] = "optional" in schema && schema.optional instanceof Function ? schema.optional() : schema;
        }
        return this.setFields(partial);
      }
      deepPartial() {
        const next = deepPartial(this);
        return next;
      }
      pick(keys2) {
        const picked = {};
        for (const key of keys2) {
          if (this.fields[key]) picked[key] = this.fields[key];
        }
        return this.setFields(picked, this._excludedEdges.filter(([a, b]) => keys2.includes(a) && keys2.includes(b)));
      }
      omit(keys2) {
        const remaining = [];
        for (const key of Object.keys(this.fields)) {
          if (keys2.includes(key)) continue;
          remaining.push(key);
        }
        return this.pick(remaining);
      }
      from(from, to, alias) {
        let fromGetter = propertyExprExports.getter(from, true);
        return this.transform((obj) => {
          if (!obj) return obj;
          let newObj = obj;
          if (deepHas(obj, from)) {
            newObj = Object.assign({}, obj);
            if (!alias) delete newObj[from];
            newObj[to] = fromGetter(obj);
          }
          return newObj;
        });
      }
      /** Parse an input JSON string to an object */
      json() {
        return this.transform(parseJson);
      }
      /**
       * Similar to `noUnknown` but only validates that an object is the right shape without stripping the unknown keys
       */
      exact(message) {
        return this.test({
          name: "exact",
          exclusive: true,
          message: message || object.exact,
          test(value) {
            if (value == null) return true;
            const unknownKeys = unknown(this.schema, value);
            return unknownKeys.length === 0 || this.createError({
              params: {
                properties: unknownKeys.join(", ")
              }
            });
          }
        });
      }
      stripUnknown() {
        return this.clone({
          noUnknown: true
        });
      }
      noUnknown(noAllow = true, message = object.noUnknown) {
        if (typeof noAllow !== "boolean") {
          message = noAllow;
          noAllow = true;
        }
        let next = this.test({
          name: "noUnknown",
          exclusive: true,
          message,
          test(value) {
            if (value == null) return true;
            const unknownKeys = unknown(this.schema, value);
            return !noAllow || unknownKeys.length === 0 || this.createError({
              params: {
                unknown: unknownKeys.join(", ")
              }
            });
          }
        });
        next.spec.noUnknown = noAllow;
        return next;
      }
      unknown(allow = true, message = object.noUnknown) {
        return this.noUnknown(!allow, message);
      }
      transformKeys(fn) {
        return this.transform((obj) => {
          if (!obj) return obj;
          const result = {};
          for (const key of Object.keys(obj)) result[fn(key)] = obj[key];
          return result;
        });
      }
      camelCase() {
        return this.transformKeys(tinyCaseExports.camelCase);
      }
      snakeCase() {
        return this.transformKeys(tinyCaseExports.snakeCase);
      }
      constantCase() {
        return this.transformKeys((key) => tinyCaseExports.snakeCase(key).toUpperCase());
      }
      describe(options) {
        const next = (options ? this.resolve(options) : this).clone();
        const base = super.describe(options);
        base.fields = {};
        for (const [key, value] of Object.entries(next.fields)) {
          var _innerOptions2;
          let innerOptions = options;
          if ((_innerOptions2 = innerOptions) != null && _innerOptions2.value) {
            innerOptions = Object.assign({}, innerOptions, {
              parent: innerOptions.value,
              value: innerOptions.value[key]
            });
          }
          base.fields[key] = value.describe(innerOptions);
        }
        return base;
      }
    }
    create$3.prototype = ObjectSchema.prototype;
    function create$2(type) {
      return new ArraySchema(type);
    }
    class ArraySchema extends Schema {
      constructor(type) {
        super({
          type: "array",
          spec: {
            types: type
          },
          check(v) {
            return Array.isArray(v);
          }
        });
        this.innerType = void 0;
        this.innerType = type;
      }
      _cast(_value, _opts) {
        const value = super._cast(_value, _opts);
        if (!this._typeCheck(value) || !this.innerType) {
          return value;
        }
        let isChanged = false;
        const castArray = value.map((v, idx) => {
          const castElement = this.innerType.cast(v, Object.assign({}, _opts, {
            path: `${_opts.path || ""}[${idx}]`
          }));
          if (castElement !== v) {
            isChanged = true;
          }
          return castElement;
        });
        return isChanged ? castArray : value;
      }
      _validate(_value, options = {}, panic, next) {
        var _options$recursive;
        let innerType = this.innerType;
        let recursive = (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive;
        options.originalValue != null ? options.originalValue : _value;
        super._validate(_value, options, panic, (arrayErrors, value) => {
          var _options$originalValu2;
          if (!recursive || !innerType || !this._typeCheck(value)) {
            next(arrayErrors, value);
            return;
          }
          let tests = new Array(value.length);
          for (let index = 0; index < value.length; index++) {
            var _options$originalValu;
            tests[index] = innerType.asNestedTest({
              options,
              index,
              parent: value,
              parentPath: options.path,
              originalParent: (_options$originalValu = options.originalValue) != null ? _options$originalValu : _value
            });
          }
          this.runTests({
            value,
            tests,
            originalValue: (_options$originalValu2 = options.originalValue) != null ? _options$originalValu2 : _value,
            options
          }, panic, (innerTypeErrors) => next(innerTypeErrors.concat(arrayErrors), value));
        });
      }
      clone(spec) {
        const next = super.clone(spec);
        next.innerType = this.innerType;
        return next;
      }
      /** Parse an input JSON string to an object */
      json() {
        return this.transform(parseJson);
      }
      concat(schema) {
        let next = super.concat(schema);
        next.innerType = this.innerType;
        if (schema.innerType)
          next.innerType = next.innerType ? (
            // @ts-expect-error Lazy doesn't have concat and will break
            next.innerType.concat(schema.innerType)
          ) : schema.innerType;
        return next;
      }
      of(schema) {
        let next = this.clone();
        if (!isSchema(schema)) throw new TypeError("`array.of()` sub-schema must be a valid yup schema not: " + printValue(schema));
        next.innerType = schema;
        next.spec = Object.assign({}, next.spec, {
          types: schema
        });
        return next;
      }
      length(length, message = array.length) {
        return this.test({
          message,
          name: "length",
          exclusive: true,
          params: {
            length
          },
          skipAbsent: true,
          test(value) {
            return value.length === this.resolve(length);
          }
        });
      }
      min(min, message) {
        message = message || array.min;
        return this.test({
          message,
          name: "min",
          exclusive: true,
          params: {
            min
          },
          skipAbsent: true,
          // FIXME(ts): Array<typeof T>
          test(value) {
            return value.length >= this.resolve(min);
          }
        });
      }
      max(max, message) {
        message = message || array.max;
        return this.test({
          message,
          name: "max",
          exclusive: true,
          params: {
            max
          },
          skipAbsent: true,
          test(value) {
            return value.length <= this.resolve(max);
          }
        });
      }
      ensure() {
        return this.default(() => []).transform((val, original2) => {
          if (this._typeCheck(val)) return val;
          return original2 == null ? [] : [].concat(original2);
        });
      }
      compact(rejector) {
        let reject = !rejector ? (v) => !!v : (v, i, a) => !rejector(v, i, a);
        return this.transform((values) => values != null ? values.filter(reject) : values);
      }
      describe(options) {
        const next = (options ? this.resolve(options) : this).clone();
        const base = super.describe(options);
        if (next.innerType) {
          var _innerOptions;
          let innerOptions = options;
          if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
            innerOptions = Object.assign({}, innerOptions, {
              parent: innerOptions.value,
              value: innerOptions.value[0]
            });
          }
          base.innerType = next.innerType.describe(innerOptions);
        }
        return base;
      }
    }
    create$2.prototype = ArraySchema.prototype;
    function create$1(schemas) {
      return new TupleSchema(schemas);
    }
    class TupleSchema extends Schema {
      constructor(schemas) {
        super({
          type: "tuple",
          spec: {
            types: schemas
          },
          check(v) {
            const types = this.spec.types;
            return Array.isArray(v) && v.length === types.length;
          }
        });
        this.withMutation(() => {
          this.typeError(tuple.notType);
        });
      }
      _cast(inputValue, options) {
        const {
          types
        } = this.spec;
        const value = super._cast(inputValue, options);
        if (!this._typeCheck(value)) {
          return value;
        }
        let isChanged = false;
        const castArray = types.map((type, idx) => {
          const castElement = type.cast(value[idx], Object.assign({}, options, {
            path: `${options.path || ""}[${idx}]`
          }));
          if (castElement !== value[idx]) isChanged = true;
          return castElement;
        });
        return isChanged ? castArray : value;
      }
      _validate(_value, options = {}, panic, next) {
        let itemTypes = this.spec.types;
        super._validate(_value, options, panic, (tupleErrors, value) => {
          var _options$originalValu2;
          if (!this._typeCheck(value)) {
            next(tupleErrors, value);
            return;
          }
          let tests = [];
          for (let [index, itemSchema] of itemTypes.entries()) {
            var _options$originalValu;
            tests[index] = itemSchema.asNestedTest({
              options,
              index,
              parent: value,
              parentPath: options.path,
              originalParent: (_options$originalValu = options.originalValue) != null ? _options$originalValu : _value
            });
          }
          this.runTests({
            value,
            tests,
            originalValue: (_options$originalValu2 = options.originalValue) != null ? _options$originalValu2 : _value,
            options
          }, panic, (innerTypeErrors) => next(innerTypeErrors.concat(tupleErrors), value));
        });
      }
      describe(options) {
        const next = (options ? this.resolve(options) : this).clone();
        const base = super.describe(options);
        base.innerType = next.spec.types.map((schema, index) => {
          var _innerOptions;
          let innerOptions = options;
          if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
            innerOptions = Object.assign({}, innerOptions, {
              parent: innerOptions.value,
              value: innerOptions.value[index]
            });
          }
          return schema.describe(innerOptions);
        });
        return base;
      }
    }
    create$1.prototype = TupleSchema.prototype;
    function create(builder) {
      return new Lazy(builder);
    }
    function catchValidationError(fn) {
      try {
        return fn();
      } catch (err) {
        if (ValidationError.isError(err)) return Promise.reject(err);
        throw err;
      }
    }
    class Lazy {
      constructor(builder) {
        this.type = "lazy";
        this.__isYupSchema__ = true;
        this.spec = void 0;
        this._resolve = (value, options = {}) => {
          let schema = this.builder(value, options);
          if (!isSchema(schema)) throw new TypeError("lazy() functions must return a valid schema");
          if (this.spec.optional) schema = schema.optional();
          return schema.resolve(options);
        };
        this.builder = builder;
        this.spec = {
          meta: void 0,
          optional: false
        };
      }
      clone(spec) {
        const next = new Lazy(this.builder);
        next.spec = Object.assign({}, this.spec, spec);
        return next;
      }
      optionality(optional) {
        const next = this.clone({
          optional
        });
        return next;
      }
      optional() {
        return this.optionality(true);
      }
      resolve(options) {
        return this._resolve(options.value, options);
      }
      cast(value, options) {
        return this._resolve(value, options).cast(value, options);
      }
      asNestedTest(config) {
        let {
          key,
          index,
          parent,
          options
        } = config;
        let value = parent[index != null ? index : key];
        return this._resolve(value, Object.assign({}, options, {
          value,
          parent
        })).asNestedTest(config);
      }
      validate(value, options) {
        return catchValidationError(() => this._resolve(value, options).validate(value, options));
      }
      validateSync(value, options) {
        return this._resolve(value, options).validateSync(value, options);
      }
      validateAt(path, value, options) {
        return catchValidationError(() => this._resolve(value, options).validateAt(path, value, options));
      }
      validateSyncAt(path, value, options) {
        return this._resolve(value, options).validateSyncAt(path, value, options);
      }
      isValid(value, options) {
        try {
          return this._resolve(value, options).isValid(value, options);
        } catch (err) {
          if (ValidationError.isError(err)) {
            return Promise.resolve(false);
          }
          throw err;
        }
      }
      isValidSync(value, options) {
        return this._resolve(value, options).isValidSync(value, options);
      }
      describe(options) {
        return options ? this.resolve(options).describe(options) : {
          type: "lazy",
          meta: this.spec.meta,
          label: void 0
        };
      }
      meta(...args) {
        if (args.length === 0) return this.spec.meta;
        let next = this.clone();
        next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);
        return next;
      }
      get ["~standard"]() {
        const schema = this;
        const standard = {
          version: 1,
          vendor: "yup",
          async validate(value) {
            try {
              const result = await schema.validate(value, {
                abortEarly: false
              });
              return {
                value: result
              };
            } catch (err) {
              if (ValidationError.isError(err)) {
                return {
                  issues: issuesFromValidationError(err)
                };
              }
              throw err;
            }
          }
        };
        return standard;
      }
    }
    function setLocale(custom) {
      Object.keys(custom).forEach((type) => {
        Object.keys(custom[type]).forEach((method) => {
          locale[type][method] = custom[type][method];
        });
      });
    }
    function addMethod(schemaType, name, fn) {
      if (!schemaType || !isSchema(schemaType.prototype)) throw new TypeError("You must provide a yup schema constructor function");
      if (typeof name !== "string") throw new TypeError("A Method name must be provided");
      if (typeof fn !== "function") throw new TypeError("Method function must be provided");
      schemaType.prototype[name] = fn;
    }
    const _0x5f2ca2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      ArraySchema,
      BooleanSchema,
      DateSchema,
      LazySchema: Lazy,
      MixedSchema,
      NumberSchema,
      ObjectSchema,
      Schema,
      StringSchema,
      TupleSchema,
      ValidationError,
      addMethod,
      array: create$2,
      bool: create$7,
      boolean: create$7,
      date: create$4,
      defaultLocale: locale,
      getIn,
      isSchema,
      lazy: create,
      mixed: create$8,
      number: create$5,
      object: create$3,
      printValue,
      reach,
      ref: create$9,
      setLocale,
      string: create$6,
      tuple: create$1
    }, Symbol.toStringTag, { value: "Module" }));
    const _0x187613 = _0x3aeb;
    (function(_0x13096f, _0x860dfe) {
      const _0x5c0cd3 = _0x3aeb, _0x976b8e = _0x13096f();
      while (!![]) {
        try {
          const _0x270265 = parseInt(_0x5c0cd3(160)) / 1 + parseInt(_0x5c0cd3(164)) / 2 + parseInt(_0x5c0cd3(165)) / 3 * (parseInt(_0x5c0cd3(175)) / 4) + parseInt(_0x5c0cd3(171)) / 5 + parseInt(_0x5c0cd3(167)) / 6 * (parseInt(_0x5c0cd3(178)) / 7) + parseInt(_0x5c0cd3(179)) / 8 * (-parseInt(_0x5c0cd3(173)) / 9) + -parseInt(_0x5c0cd3(172)) / 10 * (parseInt(_0x5c0cd3(161)) / 11);
          if (_0x270265 === _0x860dfe) break;
          else _0x976b8e["push"](_0x976b8e["shift"]());
        } catch (_0x8da372) {
          _0x976b8e["push"](_0x976b8e["shift"]());
        }
      }
    })(_0x3827, 845508);
    function _0x3827() {
      const _0xa70ddc = ["notRequired", "4485565eHatxG", "1038930whLNts", "1035171DarPJL", "First name is required", "16gtuDpA", "email", "matches", "42GIyMhU", "32gtFYNn", "Mobile number is required", "string", "97033SwqhYh", "154EvlUun", "Email is required", "Mobile number must be 10 digits", "2631976xmKrAY", "49437bBifvg", "required", "384036WMEIPp", "Message is required", "object"];
      _0x3827 = function() {
        return _0xa70ddc;
      };
      return _0x3827();
    }
    const initialValues = { "firstname": "", "lastname": "", "email": "", "mobile": "", "description": "" };
    function _0x3aeb(_0x3ff89a, _0x531bc3) {
      const _0x382788 = _0x3827();
      return _0x3aeb = function(_0x3aebcc, _0x15c064) {
        _0x3aebcc = _0x3aebcc - 159;
        let _0x278c7c = _0x382788[_0x3aebcc];
        return _0x278c7c;
      }, _0x3aeb(_0x3ff89a, _0x531bc3);
    }
    const validationSchema = _0x5f2ca2[_0x187613(169)]({ "firstname": _0x5f2ca2[_0x187613(159)]()[_0x187613(166)](_0x187613(174)), "lastname": _0x5f2ca2[_0x187613(159)]()[_0x187613(170)](), "mobile": _0x5f2ca2[_0x187613(159)]()[_0x187613(177)](/^[0-9]{10}$/, _0x187613(163))[_0x187613(166)](_0x187613(180)), "email": create$6()[_0x187613(176)]("Invalid email format")[_0x187613(166)](_0x187613(162)), "description": _0x5f2ca2[_0x187613(159)]()[_0x187613(166)](_0x187613(168)) });
    function formatProdErrorMessage$1(code) {
      return `Minified Redux error #${code}; visit https://redux.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;
    }
    var $$observable = /* @__PURE__ */ (() => typeof Symbol === "function" && Symbol.observable || "@@observable")();
    var symbol_observable_default = $$observable;
    var randomString = () => Math.random().toString(36).substring(7).split("").join(".");
    var ActionTypes = {
      INIT: `@@redux/INIT${/* @__PURE__ */ randomString()}`,
      REPLACE: `@@redux/REPLACE${/* @__PURE__ */ randomString()}`,
      PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString()}`
    };
    var actionTypes_default = ActionTypes;
    function isPlainObject$1(obj) {
      if (typeof obj !== "object" || obj === null)
        return false;
      let proto = obj;
      while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
      }
      return Object.getPrototypeOf(obj) === proto || Object.getPrototypeOf(obj) === null;
    }
    function createStore(reducer, preloadedState, enhancer) {
      if (typeof reducer !== "function") {
        throw new Error(formatProdErrorMessage$1(2));
      }
      if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
        throw new Error(formatProdErrorMessage$1(0));
      }
      if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
        enhancer = preloadedState;
        preloadedState = void 0;
      }
      if (typeof enhancer !== "undefined") {
        if (typeof enhancer !== "function") {
          throw new Error(formatProdErrorMessage$1(1));
        }
        return enhancer(createStore)(reducer, preloadedState);
      }
      let currentReducer = reducer;
      let currentState = preloadedState;
      let currentListeners = /* @__PURE__ */ new Map();
      let nextListeners = currentListeners;
      let listenerIdCounter = 0;
      let isDispatching = false;
      function ensureCanMutateNextListeners() {
        if (nextListeners === currentListeners) {
          nextListeners = /* @__PURE__ */ new Map();
          currentListeners.forEach((listener, key) => {
            nextListeners.set(key, listener);
          });
        }
      }
      function getState() {
        if (isDispatching) {
          throw new Error(formatProdErrorMessage$1(3));
        }
        return currentState;
      }
      function subscribe(listener) {
        if (typeof listener !== "function") {
          throw new Error(formatProdErrorMessage$1(4));
        }
        if (isDispatching) {
          throw new Error(formatProdErrorMessage$1(5));
        }
        let isSubscribed = true;
        ensureCanMutateNextListeners();
        const listenerId = listenerIdCounter++;
        nextListeners.set(listenerId, listener);
        return function unsubscribe() {
          if (!isSubscribed) {
            return;
          }
          if (isDispatching) {
            throw new Error(formatProdErrorMessage$1(6));
          }
          isSubscribed = false;
          ensureCanMutateNextListeners();
          nextListeners.delete(listenerId);
          currentListeners = null;
        };
      }
      function dispatch(action) {
        if (!isPlainObject$1(action)) {
          throw new Error(formatProdErrorMessage$1(7));
        }
        if (typeof action.type === "undefined") {
          throw new Error(formatProdErrorMessage$1(8));
        }
        if (typeof action.type !== "string") {
          throw new Error(formatProdErrorMessage$1(17));
        }
        if (isDispatching) {
          throw new Error(formatProdErrorMessage$1(9));
        }
        try {
          isDispatching = true;
          currentState = currentReducer(currentState, action);
        } finally {
          isDispatching = false;
        }
        const listeners = currentListeners = nextListeners;
        listeners.forEach((listener) => {
          listener();
        });
        return action;
      }
      function replaceReducer(nextReducer) {
        if (typeof nextReducer !== "function") {
          throw new Error(formatProdErrorMessage$1(10));
        }
        currentReducer = nextReducer;
        dispatch({
          type: actionTypes_default.REPLACE
        });
      }
      function observable() {
        const outerSubscribe = subscribe;
        return {
          /**
           * The minimal observable subscription method.
           * @param observer Any object that can be used as an observer.
           * The observer object should have a `next` method.
           * @returns An object with an `unsubscribe` method that can
           * be used to unsubscribe the observable from the store, and prevent further
           * emission of values from the observable.
           */
          subscribe(observer) {
            if (typeof observer !== "object" || observer === null) {
              throw new Error(formatProdErrorMessage$1(11));
            }
            function observeState() {
              const observerAsObserver = observer;
              if (observerAsObserver.next) {
                observerAsObserver.next(getState());
              }
            }
            observeState();
            const unsubscribe = outerSubscribe(observeState);
            return {
              unsubscribe
            };
          },
          [symbol_observable_default]() {
            return this;
          }
        };
      }
      dispatch({
        type: actionTypes_default.INIT
      });
      const store2 = {
        dispatch,
        subscribe,
        getState,
        replaceReducer,
        [symbol_observable_default]: observable
      };
      return store2;
    }
    function assertReducerShape(reducers) {
      Object.keys(reducers).forEach((key) => {
        const reducer = reducers[key];
        const initialState2 = reducer(void 0, {
          type: actionTypes_default.INIT
        });
        if (typeof initialState2 === "undefined") {
          throw new Error(formatProdErrorMessage$1(12));
        }
        if (typeof reducer(void 0, {
          type: actionTypes_default.PROBE_UNKNOWN_ACTION()
        }) === "undefined") {
          throw new Error(formatProdErrorMessage$1(13));
        }
      });
    }
    function combineReducers(reducers) {
      const reducerKeys = Object.keys(reducers);
      const finalReducers = {};
      for (let i = 0; i < reducerKeys.length; i++) {
        const key = reducerKeys[i];
        if (typeof reducers[key] === "function") {
          finalReducers[key] = reducers[key];
        }
      }
      const finalReducerKeys = Object.keys(finalReducers);
      let shapeAssertionError;
      try {
        assertReducerShape(finalReducers);
      } catch (e) {
        shapeAssertionError = e;
      }
      return function combination(state = {}, action) {
        if (shapeAssertionError) {
          throw shapeAssertionError;
        }
        let hasChanged = false;
        const nextState = {};
        for (let i = 0; i < finalReducerKeys.length; i++) {
          const key = finalReducerKeys[i];
          const reducer = finalReducers[key];
          const previousStateForKey = state[key];
          const nextStateForKey = reducer(previousStateForKey, action);
          if (typeof nextStateForKey === "undefined") {
            action && action.type;
            throw new Error(formatProdErrorMessage$1(14));
          }
          nextState[key] = nextStateForKey;
          hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
        }
        hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
        return hasChanged ? nextState : state;
      };
    }
    function compose(...funcs) {
      if (funcs.length === 0) {
        return (arg) => arg;
      }
      if (funcs.length === 1) {
        return funcs[0];
      }
      return funcs.reduce((a, b) => (...args) => a(b(...args)));
    }
    function applyMiddleware(...middlewares) {
      return (createStore2) => (reducer, preloadedState) => {
        const store2 = createStore2(reducer, preloadedState);
        let dispatch = () => {
          throw new Error(formatProdErrorMessage$1(15));
        };
        const middlewareAPI = {
          getState: store2.getState,
          dispatch: (action, ...args) => dispatch(action, ...args)
        };
        const chain = middlewares.map((middleware) => middleware(middlewareAPI));
        dispatch = compose(...chain)(store2.dispatch);
        return {
          ...store2,
          dispatch
        };
      };
    }
    function isAction(action) {
      return isPlainObject$1(action) && "type" in action && typeof action.type === "string";
    }
    var NOTHING = Symbol.for("immer-nothing");
    var DRAFTABLE = Symbol.for("immer-draftable");
    var DRAFT_STATE = Symbol.for("immer-state");
    function die(error, ...args) {
      throw new Error(
        `[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`
      );
    }
    var getPrototypeOf = Object.getPrototypeOf;
    function isDraft(value) {
      return !!value && !!value[DRAFT_STATE];
    }
    function isDraftable(value) {
      var _a;
      if (!value)
        return false;
      return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!((_a = value.constructor) == null ? void 0 : _a[DRAFTABLE]) || isMap(value) || isSet(value);
    }
    var objectCtorString = Object.prototype.constructor.toString();
    function isPlainObject(value) {
      if (!value || typeof value !== "object")
        return false;
      const proto = getPrototypeOf(value);
      if (proto === null) {
        return true;
      }
      const Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
      if (Ctor === Object)
        return true;
      return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
    }
    function original(value) {
      if (!isDraft(value))
        die(15, value);
      return value[DRAFT_STATE].base_;
    }
    function each(obj, iter) {
      if (getArchtype(obj) === 0) {
        Reflect.ownKeys(obj).forEach((key) => {
          iter(key, obj[key], obj);
        });
      } else {
        obj.forEach((entry, index) => iter(index, entry, obj));
      }
    }
    function getArchtype(thing) {
      const state = thing[DRAFT_STATE];
      return state ? state.type_ : Array.isArray(thing) ? 1 : isMap(thing) ? 2 : isSet(thing) ? 3 : 0;
    }
    function has(thing, prop) {
      return getArchtype(thing) === 2 ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
    }
    function get(thing, prop) {
      return getArchtype(thing) === 2 ? thing.get(prop) : thing[prop];
    }
    function set(thing, propOrOldValue, value) {
      const t = getArchtype(thing);
      if (t === 2)
        thing.set(propOrOldValue, value);
      else if (t === 3) {
        thing.add(value);
      } else
        thing[propOrOldValue] = value;
    }
    function is$1(x, y) {
      if (x === y) {
        return x !== 0 || 1 / x === 1 / y;
      } else {
        return x !== x && y !== y;
      }
    }
    function isMap(target) {
      return target instanceof Map;
    }
    function isSet(target) {
      return target instanceof Set;
    }
    function latest(state) {
      return state.copy_ || state.base_;
    }
    function shallowCopy(base, strict) {
      if (isMap(base)) {
        return new Map(base);
      }
      if (isSet(base)) {
        return new Set(base);
      }
      if (Array.isArray(base))
        return Array.prototype.slice.call(base);
      const isPlain = isPlainObject(base);
      if (strict === true || strict === "class_only" && !isPlain) {
        const descriptors = Object.getOwnPropertyDescriptors(base);
        delete descriptors[DRAFT_STATE];
        let keys2 = Reflect.ownKeys(descriptors);
        for (let i = 0; i < keys2.length; i++) {
          const key = keys2[i];
          const desc = descriptors[key];
          if (desc.writable === false) {
            desc.writable = true;
            desc.configurable = true;
          }
          if (desc.get || desc.set)
            descriptors[key] = {
              configurable: true,
              writable: true,
              // could live with !!desc.set as well here...
              enumerable: desc.enumerable,
              value: base[key]
            };
        }
        return Object.create(getPrototypeOf(base), descriptors);
      } else {
        const proto = getPrototypeOf(base);
        if (proto !== null && isPlain) {
          return { ...base };
        }
        const obj = Object.create(proto);
        return Object.assign(obj, base);
      }
    }
    function freeze(obj, deep = false) {
      if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))
        return obj;
      if (getArchtype(obj) > 1) {
        obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
      }
      Object.freeze(obj);
      if (deep)
        Object.entries(obj).forEach(([key, value]) => freeze(value, true));
      return obj;
    }
    function dontMutateFrozenCollections() {
      die(2);
    }
    function isFrozen(obj) {
      return Object.isFrozen(obj);
    }
    var plugins = {};
    function getPlugin(pluginKey) {
      const plugin = plugins[pluginKey];
      if (!plugin) {
        die(0, pluginKey);
      }
      return plugin;
    }
    function loadPlugin(pluginKey, implementation) {
      if (!plugins[pluginKey])
        plugins[pluginKey] = implementation;
    }
    var currentScope;
    function getCurrentScope() {
      return currentScope;
    }
    function createScope(parent_, immer_) {
      return {
        drafts_: [],
        parent_,
        immer_,
        // Whenever the modified draft contains a draft from another scope, we
        // need to prevent auto-freezing so the unowned draft can be finalized.
        canAutoFreeze_: true,
        unfinalizedDrafts_: 0
      };
    }
    function usePatchesInScope(scope, patchListener) {
      if (patchListener) {
        getPlugin("Patches");
        scope.patches_ = [];
        scope.inversePatches_ = [];
        scope.patchListener_ = patchListener;
      }
    }
    function revokeScope(scope) {
      leaveScope(scope);
      scope.drafts_.forEach(revokeDraft);
      scope.drafts_ = null;
    }
    function leaveScope(scope) {
      if (scope === currentScope) {
        currentScope = scope.parent_;
      }
    }
    function enterScope(immer2) {
      return currentScope = createScope(currentScope, immer2);
    }
    function revokeDraft(draft) {
      const state = draft[DRAFT_STATE];
      if (state.type_ === 0 || state.type_ === 1)
        state.revoke_();
      else
        state.revoked_ = true;
    }
    function processResult(result, scope) {
      scope.unfinalizedDrafts_ = scope.drafts_.length;
      const baseDraft = scope.drafts_[0];
      const isReplaced = result !== void 0 && result !== baseDraft;
      if (isReplaced) {
        if (baseDraft[DRAFT_STATE].modified_) {
          revokeScope(scope);
          die(4);
        }
        if (isDraftable(result)) {
          result = finalize(scope, result);
          if (!scope.parent_)
            maybeFreeze(scope, result);
        }
        if (scope.patches_) {
          getPlugin("Patches").generateReplacementPatches_(
            baseDraft[DRAFT_STATE].base_,
            result,
            scope.patches_,
            scope.inversePatches_
          );
        }
      } else {
        result = finalize(scope, baseDraft, []);
      }
      revokeScope(scope);
      if (scope.patches_) {
        scope.patchListener_(scope.patches_, scope.inversePatches_);
      }
      return result !== NOTHING ? result : void 0;
    }
    function finalize(rootScope, value, path) {
      if (isFrozen(value))
        return value;
      const state = value[DRAFT_STATE];
      if (!state) {
        each(
          value,
          (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path)
        );
        return value;
      }
      if (state.scope_ !== rootScope)
        return value;
      if (!state.modified_) {
        maybeFreeze(rootScope, state.base_, true);
        return state.base_;
      }
      if (!state.finalized_) {
        state.finalized_ = true;
        state.scope_.unfinalizedDrafts_--;
        const result = state.copy_;
        let resultEach = result;
        let isSet2 = false;
        if (state.type_ === 3) {
          resultEach = new Set(result);
          result.clear();
          isSet2 = true;
        }
        each(
          resultEach,
          (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path, isSet2)
        );
        maybeFreeze(rootScope, result, false);
        if (path && rootScope.patches_) {
          getPlugin("Patches").generatePatches_(
            state,
            path,
            rootScope.patches_,
            rootScope.inversePatches_
          );
        }
      }
      return state.copy_;
    }
    function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
      if (isDraft(childValue)) {
        const path = rootPath && parentState && parentState.type_ !== 3 && // Set objects are atomic since they have no keys.
        !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
        const res = finalize(rootScope, childValue, path);
        set(targetObject, prop, res);
        if (isDraft(res)) {
          rootScope.canAutoFreeze_ = false;
        } else
          return;
      } else if (targetIsSet) {
        targetObject.add(childValue);
      }
      if (isDraftable(childValue) && !isFrozen(childValue)) {
        if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
          return;
        }
        finalize(rootScope, childValue);
        if ((!parentState || !parentState.scope_.parent_) && typeof prop !== "symbol" && Object.prototype.propertyIsEnumerable.call(targetObject, prop))
          maybeFreeze(rootScope, childValue);
      }
    }
    function maybeFreeze(scope, value, deep = false) {
      if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
        freeze(value, deep);
      }
    }
    function createProxyProxy(base, parent) {
      const isArray2 = Array.isArray(base);
      const state = {
        type_: isArray2 ? 1 : 0,
        // Track which produce call this is associated with.
        scope_: parent ? parent.scope_ : getCurrentScope(),
        // True for both shallow and deep changes.
        modified_: false,
        // Used during finalization.
        finalized_: false,
        // Track which properties have been assigned (true) or deleted (false).
        assigned_: {},
        // The parent draft state.
        parent_: parent,
        // The base state.
        base_: base,
        // The base proxy.
        draft_: null,
        // set below
        // The base copy with any updated values.
        copy_: null,
        // Called by the `produce` function.
        revoke_: null,
        isManual_: false
      };
      let target = state;
      let traps = objectTraps;
      if (isArray2) {
        target = [state];
        traps = arrayTraps;
      }
      const { revoke, proxy } = Proxy.revocable(target, traps);
      state.draft_ = proxy;
      state.revoke_ = revoke;
      return proxy;
    }
    var objectTraps = {
      get(state, prop) {
        if (prop === DRAFT_STATE)
          return state;
        const source = latest(state);
        if (!has(source, prop)) {
          return readPropFromProto(state, source, prop);
        }
        const value = source[prop];
        if (state.finalized_ || !isDraftable(value)) {
          return value;
        }
        if (value === peek(state.base_, prop)) {
          prepareCopy(state);
          return state.copy_[prop] = createProxy(value, state);
        }
        return value;
      },
      has(state, prop) {
        return prop in latest(state);
      },
      ownKeys(state) {
        return Reflect.ownKeys(latest(state));
      },
      set(state, prop, value) {
        const desc = getDescriptorFromProto(latest(state), prop);
        if (desc == null ? void 0 : desc.set) {
          desc.set.call(state.draft_, value);
          return true;
        }
        if (!state.modified_) {
          const current2 = peek(latest(state), prop);
          const currentState = current2 == null ? void 0 : current2[DRAFT_STATE];
          if (currentState && currentState.base_ === value) {
            state.copy_[prop] = value;
            state.assigned_[prop] = false;
            return true;
          }
          if (is$1(value, current2) && (value !== void 0 || has(state.base_, prop)))
            return true;
          prepareCopy(state);
          markChanged(state);
        }
        if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'
        (value !== void 0 || prop in state.copy_) || // special case: NaN
        Number.isNaN(value) && Number.isNaN(state.copy_[prop]))
          return true;
        state.copy_[prop] = value;
        state.assigned_[prop] = true;
        return true;
      },
      deleteProperty(state, prop) {
        if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
          state.assigned_[prop] = false;
          prepareCopy(state);
          markChanged(state);
        } else {
          delete state.assigned_[prop];
        }
        if (state.copy_) {
          delete state.copy_[prop];
        }
        return true;
      },
      // Note: We never coerce `desc.value` into an Immer draft, because we can't make
      // the same guarantee in ES5 mode.
      getOwnPropertyDescriptor(state, prop) {
        const owner = latest(state);
        const desc = Reflect.getOwnPropertyDescriptor(owner, prop);
        if (!desc)
          return desc;
        return {
          writable: true,
          configurable: state.type_ !== 1 || prop !== "length",
          enumerable: desc.enumerable,
          value: owner[prop]
        };
      },
      defineProperty() {
        die(11);
      },
      getPrototypeOf(state) {
        return getPrototypeOf(state.base_);
      },
      setPrototypeOf() {
        die(12);
      }
    };
    var arrayTraps = {};
    each(objectTraps, (key, fn) => {
      arrayTraps[key] = function() {
        arguments[0] = arguments[0][0];
        return fn.apply(this, arguments);
      };
    });
    arrayTraps.deleteProperty = function(state, prop) {
      return arrayTraps.set.call(this, state, prop, void 0);
    };
    arrayTraps.set = function(state, prop, value) {
      return objectTraps.set.call(this, state[0], prop, value, state[0]);
    };
    function peek(draft, prop) {
      const state = draft[DRAFT_STATE];
      const source = state ? latest(state) : draft;
      return source[prop];
    }
    function readPropFromProto(state, source, prop) {
      var _a;
      const desc = getDescriptorFromProto(source, prop);
      return desc ? `value` in desc ? desc.value : (
        // This is a very special case, if the prop is a getter defined by the
        // prototype, we should invoke it with the draft as context!
        (_a = desc.get) == null ? void 0 : _a.call(state.draft_)
      ) : void 0;
    }
    function getDescriptorFromProto(source, prop) {
      if (!(prop in source))
        return void 0;
      let proto = getPrototypeOf(source);
      while (proto) {
        const desc = Object.getOwnPropertyDescriptor(proto, prop);
        if (desc)
          return desc;
        proto = getPrototypeOf(proto);
      }
      return void 0;
    }
    function markChanged(state) {
      if (!state.modified_) {
        state.modified_ = true;
        if (state.parent_) {
          markChanged(state.parent_);
        }
      }
    }
    function prepareCopy(state) {
      if (!state.copy_) {
        state.copy_ = shallowCopy(
          state.base_,
          state.scope_.immer_.useStrictShallowCopy_
        );
      }
    }
    var Immer2 = class {
      constructor(config) {
        this.autoFreeze_ = true;
        this.useStrictShallowCopy_ = false;
        this.produce = (base, recipe, patchListener) => {
          if (typeof base === "function" && typeof recipe !== "function") {
            const defaultBase = recipe;
            recipe = base;
            const self2 = this;
            return function curriedProduce(base2 = defaultBase, ...args) {
              return self2.produce(base2, (draft) => recipe.call(this, draft, ...args));
            };
          }
          if (typeof recipe !== "function")
            die(6);
          if (patchListener !== void 0 && typeof patchListener !== "function")
            die(7);
          let result;
          if (isDraftable(base)) {
            const scope = enterScope(this);
            const proxy = createProxy(base, void 0);
            let hasError = true;
            try {
              result = recipe(proxy);
              hasError = false;
            } finally {
              if (hasError)
                revokeScope(scope);
              else
                leaveScope(scope);
            }
            usePatchesInScope(scope, patchListener);
            return processResult(result, scope);
          } else if (!base || typeof base !== "object") {
            result = recipe(base);
            if (result === void 0)
              result = base;
            if (result === NOTHING)
              result = void 0;
            if (this.autoFreeze_)
              freeze(result, true);
            if (patchListener) {
              const p = [];
              const ip = [];
              getPlugin("Patches").generateReplacementPatches_(base, result, p, ip);
              patchListener(p, ip);
            }
            return result;
          } else
            die(1, base);
        };
        this.produceWithPatches = (base, recipe) => {
          if (typeof base === "function") {
            return (state, ...args) => this.produceWithPatches(state, (draft) => base(draft, ...args));
          }
          let patches, inversePatches;
          const result = this.produce(base, recipe, (p, ip) => {
            patches = p;
            inversePatches = ip;
          });
          return [result, patches, inversePatches];
        };
        if (typeof (config == null ? void 0 : config.autoFreeze) === "boolean")
          this.setAutoFreeze(config.autoFreeze);
        if (typeof (config == null ? void 0 : config.useStrictShallowCopy) === "boolean")
          this.setUseStrictShallowCopy(config.useStrictShallowCopy);
      }
      createDraft(base) {
        if (!isDraftable(base))
          die(8);
        if (isDraft(base))
          base = current(base);
        const scope = enterScope(this);
        const proxy = createProxy(base, void 0);
        proxy[DRAFT_STATE].isManual_ = true;
        leaveScope(scope);
        return proxy;
      }
      finishDraft(draft, patchListener) {
        const state = draft && draft[DRAFT_STATE];
        if (!state || !state.isManual_)
          die(9);
        const { scope_: scope } = state;
        usePatchesInScope(scope, patchListener);
        return processResult(void 0, scope);
      }
      /**
       * Pass true to automatically freeze all copies created by Immer.
       *
       * By default, auto-freezing is enabled.
       */
      setAutoFreeze(value) {
        this.autoFreeze_ = value;
      }
      /**
       * Pass true to enable strict shallow copy.
       *
       * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
       */
      setUseStrictShallowCopy(value) {
        this.useStrictShallowCopy_ = value;
      }
      applyPatches(base, patches) {
        let i;
        for (i = patches.length - 1; i >= 0; i--) {
          const patch = patches[i];
          if (patch.path.length === 0 && patch.op === "replace") {
            base = patch.value;
            break;
          }
        }
        if (i > -1) {
          patches = patches.slice(i + 1);
        }
        const applyPatchesImpl = getPlugin("Patches").applyPatches_;
        if (isDraft(base)) {
          return applyPatchesImpl(base, patches);
        }
        return this.produce(
          base,
          (draft) => applyPatchesImpl(draft, patches)
        );
      }
    };
    function createProxy(value, parent) {
      const draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : createProxyProxy(value, parent);
      const scope = parent ? parent.scope_ : getCurrentScope();
      scope.drafts_.push(draft);
      return draft;
    }
    function current(value) {
      if (!isDraft(value))
        die(10, value);
      return currentImpl(value);
    }
    function currentImpl(value) {
      if (!isDraftable(value) || isFrozen(value))
        return value;
      const state = value[DRAFT_STATE];
      let copy;
      if (state) {
        if (!state.modified_)
          return state.base_;
        state.finalized_ = true;
        copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);
      } else {
        copy = shallowCopy(value, true);
      }
      each(copy, (key, childValue) => {
        set(copy, key, currentImpl(childValue));
      });
      if (state) {
        state.finalized_ = false;
      }
      return copy;
    }
    function enablePatches() {
      const errorOffset = 16;
      const REPLACE = "replace";
      const ADD = "add";
      const REMOVE = "remove";
      function generatePatches_(state, basePath, patches, inversePatches) {
        switch (state.type_) {
          case 0:
          case 2:
            return generatePatchesFromAssigned(
              state,
              basePath,
              patches,
              inversePatches
            );
          case 1:
            return generateArrayPatches(state, basePath, patches, inversePatches);
          case 3:
            return generateSetPatches(
              state,
              basePath,
              patches,
              inversePatches
            );
        }
      }
      function generateArrayPatches(state, basePath, patches, inversePatches) {
        let { base_, assigned_ } = state;
        let copy_ = state.copy_;
        if (copy_.length < base_.length) {
          [base_, copy_] = [copy_, base_];
          [patches, inversePatches] = [inversePatches, patches];
        }
        for (let i = 0; i < base_.length; i++) {
          if (assigned_[i] && copy_[i] !== base_[i]) {
            const path = basePath.concat([i]);
            patches.push({
              op: REPLACE,
              path,
              // Need to maybe clone it, as it can in fact be the original value
              // due to the base/copy inversion at the start of this function
              value: clonePatchValueIfNeeded(copy_[i])
            });
            inversePatches.push({
              op: REPLACE,
              path,
              value: clonePatchValueIfNeeded(base_[i])
            });
          }
        }
        for (let i = base_.length; i < copy_.length; i++) {
          const path = basePath.concat([i]);
          patches.push({
            op: ADD,
            path,
            // Need to maybe clone it, as it can in fact be the original value
            // due to the base/copy inversion at the start of this function
            value: clonePatchValueIfNeeded(copy_[i])
          });
        }
        for (let i = copy_.length - 1; base_.length <= i; --i) {
          const path = basePath.concat([i]);
          inversePatches.push({
            op: REMOVE,
            path
          });
        }
      }
      function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {
        const { base_, copy_ } = state;
        each(state.assigned_, (key, assignedValue) => {
          const origValue = get(base_, key);
          const value = get(copy_, key);
          const op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;
          if (origValue === value && op === REPLACE)
            return;
          const path = basePath.concat(key);
          patches.push(op === REMOVE ? { op, path } : { op, path, value });
          inversePatches.push(
            op === ADD ? { op: REMOVE, path } : op === REMOVE ? { op: ADD, path, value: clonePatchValueIfNeeded(origValue) } : { op: REPLACE, path, value: clonePatchValueIfNeeded(origValue) }
          );
        });
      }
      function generateSetPatches(state, basePath, patches, inversePatches) {
        let { base_, copy_ } = state;
        let i = 0;
        base_.forEach((value) => {
          if (!copy_.has(value)) {
            const path = basePath.concat([i]);
            patches.push({
              op: REMOVE,
              path,
              value
            });
            inversePatches.unshift({
              op: ADD,
              path,
              value
            });
          }
          i++;
        });
        i = 0;
        copy_.forEach((value) => {
          if (!base_.has(value)) {
            const path = basePath.concat([i]);
            patches.push({
              op: ADD,
              path,
              value
            });
            inversePatches.unshift({
              op: REMOVE,
              path,
              value
            });
          }
          i++;
        });
      }
      function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {
        patches.push({
          op: REPLACE,
          path: [],
          value: replacement === NOTHING ? void 0 : replacement
        });
        inversePatches.push({
          op: REPLACE,
          path: [],
          value: baseValue
        });
      }
      function applyPatches_(draft, patches) {
        patches.forEach((patch) => {
          const { path, op } = patch;
          let base = draft;
          for (let i = 0; i < path.length - 1; i++) {
            const parentType = getArchtype(base);
            let p = path[i];
            if (typeof p !== "string" && typeof p !== "number") {
              p = "" + p;
            }
            if ((parentType === 0 || parentType === 1) && (p === "__proto__" || p === "constructor"))
              die(errorOffset + 3);
            if (typeof base === "function" && p === "prototype")
              die(errorOffset + 3);
            base = get(base, p);
            if (typeof base !== "object")
              die(errorOffset + 2, path.join("/"));
          }
          const type = getArchtype(base);
          const value = deepClonePatchValue(patch.value);
          const key = path[path.length - 1];
          switch (op) {
            case REPLACE:
              switch (type) {
                case 2:
                  return base.set(key, value);
                case 3:
                  die(errorOffset);
                default:
                  return base[key] = value;
              }
            case ADD:
              switch (type) {
                case 1:
                  return key === "-" ? base.push(value) : base.splice(key, 0, value);
                case 2:
                  return base.set(key, value);
                case 3:
                  return base.add(value);
                default:
                  return base[key] = value;
              }
            case REMOVE:
              switch (type) {
                case 1:
                  return base.splice(key, 1);
                case 2:
                  return base.delete(key);
                case 3:
                  return base.delete(patch.value);
                default:
                  return delete base[key];
              }
            default:
              die(errorOffset + 1, op);
          }
        });
        return draft;
      }
      function deepClonePatchValue(obj) {
        if (!isDraftable(obj))
          return obj;
        if (Array.isArray(obj))
          return obj.map(deepClonePatchValue);
        if (isMap(obj))
          return new Map(
            Array.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])
          );
        if (isSet(obj))
          return new Set(Array.from(obj).map(deepClonePatchValue));
        const cloned = Object.create(getPrototypeOf(obj));
        for (const key in obj)
          cloned[key] = deepClonePatchValue(obj[key]);
        if (has(obj, DRAFTABLE))
          cloned[DRAFTABLE] = obj[DRAFTABLE];
        return cloned;
      }
      function clonePatchValueIfNeeded(obj) {
        if (isDraft(obj)) {
          return deepClonePatchValue(obj);
        } else
          return obj;
      }
      loadPlugin("Patches", {
        applyPatches_,
        generatePatches_,
        generateReplacementPatches_
      });
    }
    var immer = new Immer2();
    var produce = immer.produce;
    var produceWithPatches = immer.produceWithPatches.bind(
      immer
    );
    immer.setAutoFreeze.bind(immer);
    immer.setUseStrictShallowCopy.bind(immer);
    var applyPatches = immer.applyPatches.bind(immer);
    immer.createDraft.bind(immer);
    immer.finishDraft.bind(immer);
    function assertIsFunction(func, errorMessage = `expected a function, instead received ${typeof func}`) {
      if (typeof func !== "function") {
        throw new TypeError(errorMessage);
      }
    }
    function assertIsObject(object2, errorMessage = `expected an object, instead received ${typeof object2}`) {
      if (typeof object2 !== "object") {
        throw new TypeError(errorMessage);
      }
    }
    function assertIsArrayOfFunctions(array2, errorMessage = `expected all items to be functions, instead received the following types: `) {
      if (!array2.every((item) => typeof item === "function")) {
        const itemTypes = array2.map(
          (item) => typeof item === "function" ? `function ${item.name || "unnamed"}()` : typeof item
        ).join(", ");
        throw new TypeError(`${errorMessage}[${itemTypes}]`);
      }
    }
    var ensureIsArray = (item) => {
      return Array.isArray(item) ? item : [item];
    };
    function getDependencies(createSelectorArgs) {
      const dependencies = Array.isArray(createSelectorArgs[0]) ? createSelectorArgs[0] : createSelectorArgs;
      assertIsArrayOfFunctions(
        dependencies,
        `createSelector expects all input-selectors to be functions, but received the following types: `
      );
      return dependencies;
    }
    function collectInputSelectorResults(dependencies, inputSelectorArgs) {
      const inputSelectorResults = [];
      const { length } = dependencies;
      for (let i = 0; i < length; i++) {
        inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs));
      }
      return inputSelectorResults;
    }
    var StrongRef = class {
      constructor(value) {
        this.value = value;
      }
      deref() {
        return this.value;
      }
    };
    var Ref = typeof WeakRef !== "undefined" ? WeakRef : StrongRef;
    var UNTERMINATED = 0;
    var TERMINATED = 1;
    function createCacheNode() {
      return {
        s: UNTERMINATED,
        v: void 0,
        o: null,
        p: null
      };
    }
    function weakMapMemoize(func, options = {}) {
      let fnNode = createCacheNode();
      const { resultEqualityCheck } = options;
      let lastResult;
      let resultsCount = 0;
      function memoized() {
        var _a;
        let cacheNode = fnNode;
        const { length } = arguments;
        for (let i = 0, l = length; i < l; i++) {
          const arg = arguments[i];
          if (typeof arg === "function" || typeof arg === "object" && arg !== null) {
            let objectCache = cacheNode.o;
            if (objectCache === null) {
              cacheNode.o = objectCache = /* @__PURE__ */ new WeakMap();
            }
            const objectNode = objectCache.get(arg);
            if (objectNode === void 0) {
              cacheNode = createCacheNode();
              objectCache.set(arg, cacheNode);
            } else {
              cacheNode = objectNode;
            }
          } else {
            let primitiveCache = cacheNode.p;
            if (primitiveCache === null) {
              cacheNode.p = primitiveCache = /* @__PURE__ */ new Map();
            }
            const primitiveNode = primitiveCache.get(arg);
            if (primitiveNode === void 0) {
              cacheNode = createCacheNode();
              primitiveCache.set(arg, cacheNode);
            } else {
              cacheNode = primitiveNode;
            }
          }
        }
        const terminatedNode = cacheNode;
        let result;
        if (cacheNode.s === TERMINATED) {
          result = cacheNode.v;
        } else {
          result = func.apply(null, arguments);
          resultsCount++;
          if (resultEqualityCheck) {
            const lastResultValue = ((_a = lastResult == null ? void 0 : lastResult.deref) == null ? void 0 : _a.call(lastResult)) ?? lastResult;
            if (lastResultValue != null && resultEqualityCheck(lastResultValue, result)) {
              result = lastResultValue;
              resultsCount !== 0 && resultsCount--;
            }
            const needsWeakRef = typeof result === "object" && result !== null || typeof result === "function";
            lastResult = needsWeakRef ? new Ref(result) : result;
          }
        }
        terminatedNode.s = TERMINATED;
        terminatedNode.v = result;
        return result;
      }
      memoized.clearCache = () => {
        fnNode = createCacheNode();
        memoized.resetResultsCount();
      };
      memoized.resultsCount = () => resultsCount;
      memoized.resetResultsCount = () => {
        resultsCount = 0;
      };
      return memoized;
    }
    function createSelectorCreator(memoizeOrOptions, ...memoizeOptionsFromArgs) {
      const createSelectorCreatorOptions = typeof memoizeOrOptions === "function" ? {
        memoize: memoizeOrOptions,
        memoizeOptions: memoizeOptionsFromArgs
      } : memoizeOrOptions;
      const createSelector2 = (...createSelectorArgs) => {
        let recomputations = 0;
        let dependencyRecomputations = 0;
        let lastResult;
        let directlyPassedOptions = {};
        let resultFunc = createSelectorArgs.pop();
        if (typeof resultFunc === "object") {
          directlyPassedOptions = resultFunc;
          resultFunc = createSelectorArgs.pop();
        }
        assertIsFunction(
          resultFunc,
          `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`
        );
        const combinedOptions = {
          ...createSelectorCreatorOptions,
          ...directlyPassedOptions
        };
        const {
          memoize: memoize2,
          memoizeOptions = [],
          argsMemoize = weakMapMemoize,
          argsMemoizeOptions = []
        } = combinedOptions;
        const finalMemoizeOptions = ensureIsArray(memoizeOptions);
        const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions);
        const dependencies = getDependencies(createSelectorArgs);
        const memoizedResultFunc = memoize2(function recomputationWrapper() {
          recomputations++;
          return resultFunc.apply(
            null,
            arguments
          );
        }, ...finalMemoizeOptions);
        const selector = argsMemoize(function dependenciesChecker() {
          dependencyRecomputations++;
          const inputSelectorResults = collectInputSelectorResults(
            dependencies,
            arguments
          );
          lastResult = memoizedResultFunc.apply(null, inputSelectorResults);
          return lastResult;
        }, ...finalArgsMemoizeOptions);
        return Object.assign(selector, {
          resultFunc,
          memoizedResultFunc,
          dependencies,
          dependencyRecomputations: () => dependencyRecomputations,
          resetDependencyRecomputations: () => {
            dependencyRecomputations = 0;
          },
          lastResult: () => lastResult,
          recomputations: () => recomputations,
          resetRecomputations: () => {
            recomputations = 0;
          },
          memoize: memoize2,
          argsMemoize
        });
      };
      Object.assign(createSelector2, {
        withTypes: () => createSelector2
      });
      return createSelector2;
    }
    var createSelector = /* @__PURE__ */ createSelectorCreator(weakMapMemoize);
    var createStructuredSelector = Object.assign(
      (inputSelectorsObject, selectorCreator = createSelector) => {
        assertIsObject(
          inputSelectorsObject,
          `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof inputSelectorsObject}`
        );
        const inputSelectorKeys = Object.keys(inputSelectorsObject);
        const dependencies = inputSelectorKeys.map(
          (key) => inputSelectorsObject[key]
        );
        const structuredSelector = selectorCreator(
          dependencies,
          (...inputSelectorResults) => {
            return inputSelectorResults.reduce((composition, value, index) => {
              composition[inputSelectorKeys[index]] = value;
              return composition;
            }, {});
          }
        );
        return structuredSelector;
      },
      { withTypes: () => createStructuredSelector }
    );
    function createThunkMiddleware(extraArgument) {
      const middleware = ({ dispatch, getState }) => (next) => (action) => {
        if (typeof action === "function") {
          return action(dispatch, getState, extraArgument);
        }
        return next(action);
      };
      return middleware;
    }
    var thunk = createThunkMiddleware();
    var withExtraArgument = createThunkMiddleware;
    var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
      if (arguments.length === 0) return void 0;
      if (typeof arguments[0] === "object") return compose;
      return compose.apply(null, arguments);
    };
    var hasMatchFunction = (v) => {
      return v && typeof v.match === "function";
    };
    function createAction(type, prepareAction) {
      function actionCreator(...args) {
        if (prepareAction) {
          let prepared = prepareAction(...args);
          if (!prepared) {
            throw new Error(formatProdErrorMessage(0));
          }
          return {
            type,
            payload: prepared.payload,
            ..."meta" in prepared && {
              meta: prepared.meta
            },
            ..."error" in prepared && {
              error: prepared.error
            }
          };
        }
        return {
          type,
          payload: args[0]
        };
      }
      actionCreator.toString = () => `${type}`;
      actionCreator.type = type;
      actionCreator.match = (action) => isAction(action) && action.type === type;
      return actionCreator;
    }
    var Tuple = class _Tuple extends Array {
      constructor(...items) {
        super(...items);
        Object.setPrototypeOf(this, _Tuple.prototype);
      }
      static get [Symbol.species]() {
        return _Tuple;
      }
      concat(...arr) {
        return super.concat.apply(this, arr);
      }
      prepend(...arr) {
        if (arr.length === 1 && Array.isArray(arr[0])) {
          return new _Tuple(...arr[0].concat(this));
        }
        return new _Tuple(...arr.concat(this));
      }
    };
    function freezeDraftable(val) {
      return isDraftable(val) ? produce(val, () => {
      }) : val;
    }
    function getOrInsertComputed(map, key, compute) {
      if (map.has(key)) return map.get(key);
      return map.set(key, compute(key)).get(key);
    }
    function isBoolean(x) {
      return typeof x === "boolean";
    }
    var buildGetDefaultMiddleware = () => function getDefaultMiddleware(options) {
      const {
        thunk: thunk$1 = true,
        immutableCheck = true,
        serializableCheck = true,
        actionCreatorCheck = true
      } = options ?? {};
      let middlewareArray = new Tuple();
      if (thunk$1) {
        if (isBoolean(thunk$1)) {
          middlewareArray.push(thunk);
        } else {
          middlewareArray.push(withExtraArgument(thunk$1.extraArgument));
        }
      }
      return middlewareArray;
    };
    var SHOULD_AUTOBATCH = "RTK_autoBatch";
    var prepareAutoBatched = () => (payload) => ({
      payload,
      meta: {
        [SHOULD_AUTOBATCH]: true
      }
    });
    var createQueueWithTimer = (timeout) => {
      return (notify) => {
        setTimeout(notify, timeout);
      };
    };
    var autoBatchEnhancer = (options = {
      type: "raf"
    }) => (next) => (...args) => {
      const store2 = next(...args);
      let notifying = true;
      let shouldNotifyAtEndOfTick = false;
      let notificationQueued = false;
      const listeners = /* @__PURE__ */ new Set();
      const queueCallback = options.type === "tick" ? queueMicrotask : options.type === "raf" ? (
        // requestAnimationFrame won't exist in SSR environments. Fall back to a vague approximation just to keep from erroring.
        typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame : createQueueWithTimer(10)
      ) : options.type === "callback" ? options.queueNotification : createQueueWithTimer(options.timeout);
      const notifyListeners = () => {
        notificationQueued = false;
        if (shouldNotifyAtEndOfTick) {
          shouldNotifyAtEndOfTick = false;
          listeners.forEach((l) => l());
        }
      };
      return Object.assign({}, store2, {
        // Override the base `store.subscribe` method to keep original listeners
        // from running if we're delaying notifications
        subscribe(listener2) {
          const wrappedListener = () => notifying && listener2();
          const unsubscribe = store2.subscribe(wrappedListener);
          listeners.add(listener2);
          return () => {
            unsubscribe();
            listeners.delete(listener2);
          };
        },
        // Override the base `store.dispatch` method so that we can check actions
        // for the `shouldAutoBatch` flag and determine if batching is active
        dispatch(action) {
          var _a;
          try {
            notifying = !((_a = action == null ? void 0 : action.meta) == null ? void 0 : _a[SHOULD_AUTOBATCH]);
            shouldNotifyAtEndOfTick = !notifying;
            if (shouldNotifyAtEndOfTick) {
              if (!notificationQueued) {
                notificationQueued = true;
                queueCallback(notifyListeners);
              }
            }
            return store2.dispatch(action);
          } finally {
            notifying = true;
          }
        }
      });
    };
    var buildGetDefaultEnhancers = (middlewareEnhancer) => function getDefaultEnhancers(options) {
      const {
        autoBatch = true
      } = options ?? {};
      let enhancerArray = new Tuple(middlewareEnhancer);
      if (autoBatch) {
        enhancerArray.push(autoBatchEnhancer(typeof autoBatch === "object" ? autoBatch : void 0));
      }
      return enhancerArray;
    };
    function configureStore(options) {
      const getDefaultMiddleware = buildGetDefaultMiddleware();
      const {
        reducer = void 0,
        middleware,
        devTools = true,
        preloadedState = void 0,
        enhancers = void 0
      } = options || {};
      let rootReducer;
      if (typeof reducer === "function") {
        rootReducer = reducer;
      } else if (isPlainObject$1(reducer)) {
        rootReducer = combineReducers(reducer);
      } else {
        throw new Error(formatProdErrorMessage(1));
      }
      let finalMiddleware;
      if (typeof middleware === "function") {
        finalMiddleware = middleware(getDefaultMiddleware);
      } else {
        finalMiddleware = getDefaultMiddleware();
      }
      let finalCompose = compose;
      if (devTools) {
        finalCompose = composeWithDevTools({
          // Enable capture of stack traces for dispatched Redux actions
          trace: false,
          ...typeof devTools === "object" && devTools
        });
      }
      const middlewareEnhancer = applyMiddleware(...finalMiddleware);
      const getDefaultEnhancers = buildGetDefaultEnhancers(middlewareEnhancer);
      let storeEnhancers = typeof enhancers === "function" ? enhancers(getDefaultEnhancers) : getDefaultEnhancers();
      const composedEnhancer = finalCompose(...storeEnhancers);
      return createStore(rootReducer, preloadedState, composedEnhancer);
    }
    function executeReducerBuilderCallback(builderCallback) {
      const actionsMap = {};
      const actionMatchers = [];
      let defaultCaseReducer;
      const builder = {
        addCase(typeOrActionCreator, reducer) {
          const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
          if (!type) {
            throw new Error(formatProdErrorMessage(28));
          }
          if (type in actionsMap) {
            throw new Error(formatProdErrorMessage(29));
          }
          actionsMap[type] = reducer;
          return builder;
        },
        addMatcher(matcher, reducer) {
          actionMatchers.push({
            matcher,
            reducer
          });
          return builder;
        },
        addDefaultCase(reducer) {
          defaultCaseReducer = reducer;
          return builder;
        }
      };
      builderCallback(builder);
      return [actionsMap, actionMatchers, defaultCaseReducer];
    }
    function isStateFunction(x) {
      return typeof x === "function";
    }
    function createReducer(initialState2, mapOrBuilderCallback) {
      let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] = executeReducerBuilderCallback(mapOrBuilderCallback);
      let getInitialState;
      if (isStateFunction(initialState2)) {
        getInitialState = () => freezeDraftable(initialState2());
      } else {
        const frozenInitialState = freezeDraftable(initialState2);
        getInitialState = () => frozenInitialState;
      }
      function reducer(state = getInitialState(), action) {
        let caseReducers = [actionsMap[action.type], ...finalActionMatchers.filter(({
          matcher
        }) => matcher(action)).map(({
          reducer: reducer2
        }) => reducer2)];
        if (caseReducers.filter((cr) => !!cr).length === 0) {
          caseReducers = [finalDefaultCaseReducer];
        }
        return caseReducers.reduce((previousState, caseReducer) => {
          if (caseReducer) {
            if (isDraft(previousState)) {
              const draft = previousState;
              const result = caseReducer(draft, action);
              if (result === void 0) {
                return previousState;
              }
              return result;
            } else if (!isDraftable(previousState)) {
              const result = caseReducer(previousState, action);
              if (result === void 0) {
                if (previousState === null) {
                  return previousState;
                }
                throw Error("A case reducer on a non-draftable value must not return undefined");
              }
              return result;
            } else {
              return produce(previousState, (draft) => {
                return caseReducer(draft, action);
              });
            }
          }
          return previousState;
        }, state);
      }
      reducer.getInitialState = getInitialState;
      return reducer;
    }
    var matches = (matcher, action) => {
      if (hasMatchFunction(matcher)) {
        return matcher.match(action);
      } else {
        return matcher(action);
      }
    };
    function isAnyOf(...matchers) {
      return (action) => {
        return matchers.some((matcher) => matches(matcher, action));
      };
    }
    function isAllOf(...matchers) {
      return (action) => {
        return matchers.every((matcher) => matches(matcher, action));
      };
    }
    function hasExpectedRequestMetadata(action, validStatus) {
      if (!action || !action.meta) return false;
      const hasValidRequestId = typeof action.meta.requestId === "string";
      const hasValidRequestStatus = validStatus.indexOf(action.meta.requestStatus) > -1;
      return hasValidRequestId && hasValidRequestStatus;
    }
    function isAsyncThunkArray(a) {
      return typeof a[0] === "function" && "pending" in a[0] && "fulfilled" in a[0] && "rejected" in a[0];
    }
    function isPending(...asyncThunks) {
      if (asyncThunks.length === 0) {
        return (action) => hasExpectedRequestMetadata(action, ["pending"]);
      }
      if (!isAsyncThunkArray(asyncThunks)) {
        return isPending()(asyncThunks[0]);
      }
      return isAnyOf(...asyncThunks.map((asyncThunk) => asyncThunk.pending));
    }
    function isRejected(...asyncThunks) {
      if (asyncThunks.length === 0) {
        return (action) => hasExpectedRequestMetadata(action, ["rejected"]);
      }
      if (!isAsyncThunkArray(asyncThunks)) {
        return isRejected()(asyncThunks[0]);
      }
      return isAnyOf(...asyncThunks.map((asyncThunk) => asyncThunk.rejected));
    }
    function isRejectedWithValue(...asyncThunks) {
      const hasFlag = (action) => {
        return action && action.meta && action.meta.rejectedWithValue;
      };
      if (asyncThunks.length === 0) {
        return isAllOf(isRejected(...asyncThunks), hasFlag);
      }
      if (!isAsyncThunkArray(asyncThunks)) {
        return isRejectedWithValue()(asyncThunks[0]);
      }
      return isAllOf(isRejected(...asyncThunks), hasFlag);
    }
    function isFulfilled(...asyncThunks) {
      if (asyncThunks.length === 0) {
        return (action) => hasExpectedRequestMetadata(action, ["fulfilled"]);
      }
      if (!isAsyncThunkArray(asyncThunks)) {
        return isFulfilled()(asyncThunks[0]);
      }
      return isAnyOf(...asyncThunks.map((asyncThunk) => asyncThunk.fulfilled));
    }
    function isAsyncThunkAction(...asyncThunks) {
      if (asyncThunks.length === 0) {
        return (action) => hasExpectedRequestMetadata(action, ["pending", "fulfilled", "rejected"]);
      }
      if (!isAsyncThunkArray(asyncThunks)) {
        return isAsyncThunkAction()(asyncThunks[0]);
      }
      return isAnyOf(...asyncThunks.flatMap((asyncThunk) => [asyncThunk.pending, asyncThunk.rejected, asyncThunk.fulfilled]));
    }
    var urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW";
    var nanoid = (size = 21) => {
      let id = "";
      let i = size;
      while (i--) {
        id += urlAlphabet[Math.random() * 64 | 0];
      }
      return id;
    };
    var commonProperties = ["name", "message", "stack", "code"];
    var RejectWithValue = class {
      constructor(payload, meta) {
        /*
        type-only property to distinguish between RejectWithValue and FulfillWithMeta
        does not exist at runtime
        */
        __publicField(this, "_type");
        this.payload = payload;
        this.meta = meta;
      }
    };
    var FulfillWithMeta = class {
      constructor(payload, meta) {
        /*
        type-only property to distinguish between RejectWithValue and FulfillWithMeta
        does not exist at runtime
        */
        __publicField(this, "_type");
        this.payload = payload;
        this.meta = meta;
      }
    };
    var miniSerializeError = (value) => {
      if (typeof value === "object" && value !== null) {
        const simpleError = {};
        for (const property of commonProperties) {
          if (typeof value[property] === "string") {
            simpleError[property] = value[property];
          }
        }
        return simpleError;
      }
      return {
        message: String(value)
      };
    };
    var externalAbortMessage = "External signal was aborted";
    var createAsyncThunk = /* @__PURE__ */ (() => {
      function createAsyncThunk2(typePrefix, payloadCreator, options) {
        const fulfilled = createAction(typePrefix + "/fulfilled", (payload, requestId, arg, meta) => ({
          payload,
          meta: {
            ...meta || {},
            arg,
            requestId,
            requestStatus: "fulfilled"
          }
        }));
        const pending = createAction(typePrefix + "/pending", (requestId, arg, meta) => ({
          payload: void 0,
          meta: {
            ...meta || {},
            arg,
            requestId,
            requestStatus: "pending"
          }
        }));
        const rejected = createAction(typePrefix + "/rejected", (error, requestId, arg, payload, meta) => ({
          payload,
          error: (options && options.serializeError || miniSerializeError)(error || "Rejected"),
          meta: {
            ...meta || {},
            arg,
            requestId,
            rejectedWithValue: !!payload,
            requestStatus: "rejected",
            aborted: (error == null ? void 0 : error.name) === "AbortError",
            condition: (error == null ? void 0 : error.name) === "ConditionError"
          }
        }));
        function actionCreator(arg, {
          signal
        } = {}) {
          return (dispatch, getState, extra) => {
            const requestId = (options == null ? void 0 : options.idGenerator) ? options.idGenerator(arg) : nanoid();
            const abortController = new AbortController();
            let abortHandler;
            let abortReason;
            function abort(reason) {
              abortReason = reason;
              abortController.abort();
            }
            if (signal) {
              if (signal.aborted) {
                abort(externalAbortMessage);
              } else {
                signal.addEventListener("abort", () => abort(externalAbortMessage), {
                  once: true
                });
              }
            }
            const promise = async function() {
              var _a, _b;
              let finalAction;
              try {
                let conditionResult = (_a = options == null ? void 0 : options.condition) == null ? void 0 : _a.call(options, arg, {
                  getState,
                  extra
                });
                if (isThenable(conditionResult)) {
                  conditionResult = await conditionResult;
                }
                if (conditionResult === false || abortController.signal.aborted) {
                  throw {
                    name: "ConditionError",
                    message: "Aborted due to condition callback returning false."
                  };
                }
                const abortedPromise = new Promise((_, reject) => {
                  abortHandler = () => {
                    reject({
                      name: "AbortError",
                      message: abortReason || "Aborted"
                    });
                  };
                  abortController.signal.addEventListener("abort", abortHandler);
                });
                dispatch(pending(requestId, arg, (_b = options == null ? void 0 : options.getPendingMeta) == null ? void 0 : _b.call(options, {
                  requestId,
                  arg
                }, {
                  getState,
                  extra
                })));
                finalAction = await Promise.race([abortedPromise, Promise.resolve(payloadCreator(arg, {
                  dispatch,
                  getState,
                  extra,
                  requestId,
                  signal: abortController.signal,
                  abort,
                  rejectWithValue: (value, meta) => {
                    return new RejectWithValue(value, meta);
                  },
                  fulfillWithValue: (value, meta) => {
                    return new FulfillWithMeta(value, meta);
                  }
                })).then((result) => {
                  if (result instanceof RejectWithValue) {
                    throw result;
                  }
                  if (result instanceof FulfillWithMeta) {
                    return fulfilled(result.payload, requestId, arg, result.meta);
                  }
                  return fulfilled(result, requestId, arg);
                })]);
              } catch (err) {
                finalAction = err instanceof RejectWithValue ? rejected(null, requestId, arg, err.payload, err.meta) : rejected(err, requestId, arg);
              } finally {
                if (abortHandler) {
                  abortController.signal.removeEventListener("abort", abortHandler);
                }
              }
              const skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;
              if (!skipDispatch) {
                dispatch(finalAction);
              }
              return finalAction;
            }();
            return Object.assign(promise, {
              abort,
              requestId,
              arg,
              unwrap() {
                return promise.then(unwrapResult);
              }
            });
          };
        }
        return Object.assign(actionCreator, {
          pending,
          rejected,
          fulfilled,
          settled: isAnyOf(rejected, fulfilled),
          typePrefix
        });
      }
      createAsyncThunk2.withTypes = () => createAsyncThunk2;
      return createAsyncThunk2;
    })();
    function unwrapResult(action) {
      if (action.meta && action.meta.rejectedWithValue) {
        throw action.payload;
      }
      if (action.error) {
        throw action.error;
      }
      return action.payload;
    }
    function isThenable(value) {
      return value !== null && typeof value === "object" && typeof value.then === "function";
    }
    var asyncThunkSymbol = /* @__PURE__ */ Symbol.for("rtk-slice-createasyncthunk");
    function getType(slice, actionKey) {
      return `${slice}/${actionKey}`;
    }
    function buildCreateSlice({
      creators
    } = {}) {
      var _a;
      const cAT = (_a = creators == null ? void 0 : creators.asyncThunk) == null ? void 0 : _a[asyncThunkSymbol];
      return function createSlice2(options) {
        const {
          name,
          reducerPath = name
        } = options;
        if (!name) {
          throw new Error(formatProdErrorMessage(11));
        }
        const reducers = (typeof options.reducers === "function" ? options.reducers(buildReducerCreators()) : options.reducers) || {};
        const reducerNames = Object.keys(reducers);
        const context = {
          sliceCaseReducersByName: {},
          sliceCaseReducersByType: {},
          actionCreators: {},
          sliceMatchers: []
        };
        const contextMethods = {
          addCase(typeOrActionCreator, reducer2) {
            const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
            if (!type) {
              throw new Error(formatProdErrorMessage(12));
            }
            if (type in context.sliceCaseReducersByType) {
              throw new Error(formatProdErrorMessage(13));
            }
            context.sliceCaseReducersByType[type] = reducer2;
            return contextMethods;
          },
          addMatcher(matcher, reducer2) {
            context.sliceMatchers.push({
              matcher,
              reducer: reducer2
            });
            return contextMethods;
          },
          exposeAction(name2, actionCreator) {
            context.actionCreators[name2] = actionCreator;
            return contextMethods;
          },
          exposeCaseReducer(name2, reducer2) {
            context.sliceCaseReducersByName[name2] = reducer2;
            return contextMethods;
          }
        };
        reducerNames.forEach((reducerName) => {
          const reducerDefinition = reducers[reducerName];
          const reducerDetails = {
            reducerName,
            type: getType(name, reducerName),
            createNotation: typeof options.reducers === "function"
          };
          if (isAsyncThunkSliceReducerDefinition(reducerDefinition)) {
            handleThunkCaseReducerDefinition(reducerDetails, reducerDefinition, contextMethods, cAT);
          } else {
            handleNormalReducerDefinition(reducerDetails, reducerDefinition, contextMethods);
          }
        });
        function buildReducer() {
          const [extraReducers = {}, actionMatchers = [], defaultCaseReducer = void 0] = typeof options.extraReducers === "function" ? executeReducerBuilderCallback(options.extraReducers) : [options.extraReducers];
          const finalCaseReducers = {
            ...extraReducers,
            ...context.sliceCaseReducersByType
          };
          return createReducer(options.initialState, (builder) => {
            for (let key in finalCaseReducers) {
              builder.addCase(key, finalCaseReducers[key]);
            }
            for (let sM of context.sliceMatchers) {
              builder.addMatcher(sM.matcher, sM.reducer);
            }
            for (let m of actionMatchers) {
              builder.addMatcher(m.matcher, m.reducer);
            }
            if (defaultCaseReducer) {
              builder.addDefaultCase(defaultCaseReducer);
            }
          });
        }
        const selectSelf = (state) => state;
        const injectedSelectorCache = /* @__PURE__ */ new Map();
        const injectedStateCache = /* @__PURE__ */ new WeakMap();
        let _reducer;
        function reducer(state, action) {
          if (!_reducer) _reducer = buildReducer();
          return _reducer(state, action);
        }
        function getInitialState() {
          if (!_reducer) _reducer = buildReducer();
          return _reducer.getInitialState();
        }
        function makeSelectorProps(reducerPath2, injected = false) {
          function selectSlice(state) {
            let sliceState = state[reducerPath2];
            if (typeof sliceState === "undefined") {
              if (injected) {
                sliceState = getOrInsertComputed(injectedStateCache, selectSlice, getInitialState);
              }
            }
            return sliceState;
          }
          function getSelectors(selectState = selectSelf) {
            const selectorCache = getOrInsertComputed(injectedSelectorCache, injected, () => /* @__PURE__ */ new WeakMap());
            return getOrInsertComputed(selectorCache, selectState, () => {
              const map = {};
              for (const [name2, selector] of Object.entries(options.selectors ?? {})) {
                map[name2] = wrapSelector(selector, selectState, () => getOrInsertComputed(injectedStateCache, selectState, getInitialState), injected);
              }
              return map;
            });
          }
          return {
            reducerPath: reducerPath2,
            getSelectors,
            get selectors() {
              return getSelectors(selectSlice);
            },
            selectSlice
          };
        }
        const slice = {
          name,
          reducer,
          actions: context.actionCreators,
          caseReducers: context.sliceCaseReducersByName,
          getInitialState,
          ...makeSelectorProps(reducerPath),
          injectInto(injectable, {
            reducerPath: pathOpt,
            ...config
          } = {}) {
            const newReducerPath = pathOpt ?? reducerPath;
            injectable.inject({
              reducerPath: newReducerPath,
              reducer
            }, config);
            return {
              ...slice,
              ...makeSelectorProps(newReducerPath, true)
            };
          }
        };
        return slice;
      };
    }
    function wrapSelector(selector, selectState, getInitialState, injected) {
      function wrapper(rootState, ...args) {
        let sliceState = selectState(rootState);
        if (typeof sliceState === "undefined") {
          if (injected) {
            sliceState = getInitialState();
          }
        }
        return selector(sliceState, ...args);
      }
      wrapper.unwrapped = selector;
      return wrapper;
    }
    var createSlice = /* @__PURE__ */ buildCreateSlice();
    function buildReducerCreators() {
      function asyncThunk(payloadCreator, config) {
        return {
          _reducerDefinitionType: "asyncThunk",
          payloadCreator,
          ...config
        };
      }
      asyncThunk.withTypes = () => asyncThunk;
      return {
        reducer(caseReducer) {
          return Object.assign({
            // hack so the wrapping function has the same name as the original
            // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original
            [caseReducer.name](...args) {
              return caseReducer(...args);
            }
          }[caseReducer.name], {
            _reducerDefinitionType: "reducer"
            /* reducer */
          });
        },
        preparedReducer(prepare, reducer) {
          return {
            _reducerDefinitionType: "reducerWithPrepare",
            prepare,
            reducer
          };
        },
        asyncThunk
      };
    }
    function handleNormalReducerDefinition({
      type,
      reducerName,
      createNotation
    }, maybeReducerWithPrepare, context) {
      let caseReducer;
      let prepareCallback;
      if ("reducer" in maybeReducerWithPrepare) {
        if (createNotation && !isCaseReducerWithPrepareDefinition(maybeReducerWithPrepare)) {
          throw new Error(formatProdErrorMessage(17));
        }
        caseReducer = maybeReducerWithPrepare.reducer;
        prepareCallback = maybeReducerWithPrepare.prepare;
      } else {
        caseReducer = maybeReducerWithPrepare;
      }
      context.addCase(type, caseReducer).exposeCaseReducer(reducerName, caseReducer).exposeAction(reducerName, prepareCallback ? createAction(type, prepareCallback) : createAction(type));
    }
    function isAsyncThunkSliceReducerDefinition(reducerDefinition) {
      return reducerDefinition._reducerDefinitionType === "asyncThunk";
    }
    function isCaseReducerWithPrepareDefinition(reducerDefinition) {
      return reducerDefinition._reducerDefinitionType === "reducerWithPrepare";
    }
    function handleThunkCaseReducerDefinition({
      type,
      reducerName
    }, reducerDefinition, context, cAT) {
      if (!cAT) {
        throw new Error(formatProdErrorMessage(18));
      }
      const {
        payloadCreator,
        fulfilled,
        pending,
        rejected,
        settled,
        options
      } = reducerDefinition;
      const thunk2 = cAT(type, payloadCreator, options);
      context.exposeAction(reducerName, thunk2);
      if (fulfilled) {
        context.addCase(thunk2.fulfilled, fulfilled);
      }
      if (pending) {
        context.addCase(thunk2.pending, pending);
      }
      if (rejected) {
        context.addCase(thunk2.rejected, rejected);
      }
      if (settled) {
        context.addMatcher(thunk2.settled, settled);
      }
      context.exposeCaseReducer(reducerName, {
        fulfilled: fulfilled || noop,
        pending: pending || noop,
        rejected: rejected || noop,
        settled: settled || noop
      });
    }
    function noop() {
    }
    function formatProdErrorMessage(code) {
      return `Minified Redux Toolkit error #${code}; visit https://redux-toolkit.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;
    }
    var SchemaError = class extends Error {
      /**
       * Creates a schema error with useful information.
       *
       * @param issues The schema issues.
       */
      constructor(issues) {
        super(issues[0].message);
        /**
         * The schema issues.
         */
        __publicField(this, "issues");
        this.name = "SchemaError";
        this.issues = issues;
      }
    };
    var QueryStatus = /* @__PURE__ */ ((QueryStatus2) => {
      QueryStatus2["uninitialized"] = "uninitialized";
      QueryStatus2["pending"] = "pending";
      QueryStatus2["fulfilled"] = "fulfilled";
      QueryStatus2["rejected"] = "rejected";
      return QueryStatus2;
    })(QueryStatus || {});
    function getRequestStatusFlags(status) {
      return {
        status,
        isUninitialized: status === "uninitialized",
        isLoading: status === "pending",
        isSuccess: status === "fulfilled",
        isError: status === "rejected"
        /* rejected */
      };
    }
    var isPlainObject2 = isPlainObject$1;
    function copyWithStructuralSharing(oldObj, newObj) {
      if (oldObj === newObj || !(isPlainObject2(oldObj) && isPlainObject2(newObj) || Array.isArray(oldObj) && Array.isArray(newObj))) {
        return newObj;
      }
      const newKeys = Object.keys(newObj);
      const oldKeys = Object.keys(oldObj);
      let isSameObject = newKeys.length === oldKeys.length;
      const mergeObj = Array.isArray(newObj) ? [] : {};
      for (const key of newKeys) {
        mergeObj[key] = copyWithStructuralSharing(oldObj[key], newObj[key]);
        if (isSameObject) isSameObject = oldObj[key] === mergeObj[key];
      }
      return isSameObject ? oldObj : mergeObj;
    }
    function countObjectKeys(obj) {
      let count = 0;
      for (const _key in obj) {
        count++;
      }
      return count;
    }
    var flatten = (arr) => [].concat(...arr);
    function isAbsoluteUrl(url) {
      return new RegExp(`(^|:)//`).test(url);
    }
    function isDocumentVisible() {
      if (typeof document === "undefined") {
        return true;
      }
      return document.visibilityState !== "hidden";
    }
    function isNotNullish(v) {
      return v != null;
    }
    function isOnline() {
      return typeof navigator === "undefined" ? true : navigator.onLine === void 0 ? true : navigator.onLine;
    }
    var withoutTrailingSlash = (url) => url.replace(/\/$/, "");
    var withoutLeadingSlash = (url) => url.replace(/^\//, "");
    function joinUrls(base, url) {
      if (!base) {
        return url;
      }
      if (!url) {
        return base;
      }
      if (isAbsoluteUrl(url)) {
        return url;
      }
      const delimiter = base.endsWith("/") || !url.startsWith("?") ? "/" : "";
      base = withoutTrailingSlash(base);
      url = withoutLeadingSlash(url);
      return `${base}${delimiter}${url}`;
    }
    function getOrInsert(map, key, value) {
      if (map.has(key)) return map.get(key);
      return map.set(key, value).get(key);
    }
    var defaultFetchFn = (...args) => fetch(...args);
    var defaultValidateStatus = (response) => response.status >= 200 && response.status <= 299;
    var defaultIsJsonContentType = (headers) => (
      /*applicat*/
      /ion\/(vnd\.api\+)?json/.test(headers.get("content-type") || "")
    );
    function stripUndefined(obj) {
      if (!isPlainObject$1(obj)) {
        return obj;
      }
      const copy = {
        ...obj
      };
      for (const [k, v] of Object.entries(copy)) {
        if (v === void 0) delete copy[k];
      }
      return copy;
    }
    function fetchBaseQuery({
      baseUrl,
      prepareHeaders = (x) => x,
      fetchFn = defaultFetchFn,
      paramsSerializer,
      isJsonContentType = defaultIsJsonContentType,
      jsonContentType = "application/json",
      jsonReplacer,
      timeout: defaultTimeout,
      responseHandler: globalResponseHandler,
      validateStatus: globalValidateStatus,
      ...baseFetchOptions
    } = {}) {
      if (typeof fetch === "undefined" && fetchFn === defaultFetchFn) {
        console.warn("Warning: `fetch` is not available. Please supply a custom `fetchFn` property to use `fetchBaseQuery` on SSR environments.");
      }
      return async (arg, api, extraOptions) => {
        const {
          getState,
          extra,
          endpoint,
          forced,
          type
        } = api;
        let meta;
        let {
          url,
          headers = new Headers(baseFetchOptions.headers),
          params = void 0,
          responseHandler = globalResponseHandler ?? "json",
          validateStatus = globalValidateStatus ?? defaultValidateStatus,
          timeout = defaultTimeout,
          ...rest
        } = typeof arg == "string" ? {
          url: arg
        } : arg;
        let abortController, signal = api.signal;
        if (timeout) {
          abortController = new AbortController();
          api.signal.addEventListener("abort", abortController.abort);
          signal = abortController.signal;
        }
        let config = {
          ...baseFetchOptions,
          signal,
          ...rest
        };
        headers = new Headers(stripUndefined(headers));
        config.headers = await prepareHeaders(headers, {
          getState,
          arg,
          extra,
          endpoint,
          forced,
          type,
          extraOptions
        }) || headers;
        const isJsonifiable = (body) => typeof body === "object" && (isPlainObject$1(body) || Array.isArray(body) || typeof body.toJSON === "function");
        if (!config.headers.has("content-type") && isJsonifiable(config.body)) {
          config.headers.set("content-type", jsonContentType);
        }
        if (isJsonifiable(config.body) && isJsonContentType(config.headers)) {
          config.body = JSON.stringify(config.body, jsonReplacer);
        }
        if (params) {
          const divider = ~url.indexOf("?") ? "&" : "?";
          const query = paramsSerializer ? paramsSerializer(params) : new URLSearchParams(stripUndefined(params));
          url += divider + query;
        }
        url = joinUrls(baseUrl, url);
        const request = new Request(url, config);
        const requestClone = new Request(url, config);
        meta = {
          request: requestClone
        };
        let response, timedOut = false, timeoutId = abortController && setTimeout(() => {
          timedOut = true;
          abortController.abort();
        }, timeout);
        try {
          response = await fetchFn(request);
        } catch (e) {
          return {
            error: {
              status: timedOut ? "TIMEOUT_ERROR" : "FETCH_ERROR",
              error: String(e)
            },
            meta
          };
        } finally {
          if (timeoutId) clearTimeout(timeoutId);
          abortController == null ? void 0 : abortController.signal.removeEventListener("abort", abortController.abort);
        }
        const responseClone = response.clone();
        meta.response = responseClone;
        let resultData;
        let responseText = "";
        try {
          let handleResponseError;
          await Promise.all([
            handleResponse(response, responseHandler).then((r) => resultData = r, (e) => handleResponseError = e),
            // see https://github.com/node-fetch/node-fetch/issues/665#issuecomment-538995182
            // we *have* to "use up" both streams at the same time or they will stop running in node-fetch scenarios
            responseClone.text().then((r) => responseText = r, () => {
            })
          ]);
          if (handleResponseError) throw handleResponseError;
        } catch (e) {
          return {
            error: {
              status: "PARSING_ERROR",
              originalStatus: response.status,
              data: responseText,
              error: String(e)
            },
            meta
          };
        }
        return validateStatus(response, resultData) ? {
          data: resultData,
          meta
        } : {
          error: {
            status: response.status,
            data: resultData
          },
          meta
        };
      };
      async function handleResponse(response, responseHandler) {
        if (typeof responseHandler === "function") {
          return responseHandler(response);
        }
        if (responseHandler === "content-type") {
          responseHandler = isJsonContentType(response.headers) ? "json" : "text";
        }
        if (responseHandler === "json") {
          const text = await response.text();
          return text.length ? JSON.parse(text) : null;
        }
        return response.text();
      }
    }
    var HandledError = class {
      constructor(value, meta = void 0) {
        this.value = value;
        this.meta = meta;
      }
    };
    var onFocus = /* @__PURE__ */ createAction("__rtkq/focused");
    var onFocusLost = /* @__PURE__ */ createAction("__rtkq/unfocused");
    var onOnline = /* @__PURE__ */ createAction("__rtkq/online");
    var onOffline = /* @__PURE__ */ createAction("__rtkq/offline");
    function isQueryDefinition$1(e) {
      return e.type === "query";
    }
    function isMutationDefinition$1(e) {
      return e.type === "mutation";
    }
    function isInfiniteQueryDefinition$1(e) {
      return e.type === "infinitequery";
    }
    function isAnyQueryDefinition(e) {
      return isQueryDefinition$1(e) || isInfiniteQueryDefinition$1(e);
    }
    function calculateProvidedBy(description, result, error, queryArg, meta, assertTagTypes) {
      if (isFunction(description)) {
        return description(result, error, queryArg, meta).filter(isNotNullish).map(expandTagDescription).map(assertTagTypes);
      }
      if (Array.isArray(description)) {
        return description.map(expandTagDescription).map(assertTagTypes);
      }
      return [];
    }
    function isFunction(t) {
      return typeof t === "function";
    }
    function expandTagDescription(description) {
      return typeof description === "string" ? {
        type: description
      } : description;
    }
    function asSafePromise(promise, fallback) {
      return promise.catch(fallback);
    }
    var forceQueryFnSymbol = Symbol("forceQueryFn");
    var isUpsertQuery = (arg) => typeof arg[forceQueryFnSymbol] === "function";
    function buildInitiate({
      serializeQueryArgs,
      queryThunk,
      infiniteQueryThunk,
      mutationThunk,
      api,
      context
    }) {
      const runningQueries = /* @__PURE__ */ new Map();
      const runningMutations = /* @__PURE__ */ new Map();
      const {
        unsubscribeQueryResult,
        removeMutationResult,
        updateSubscriptionOptions
      } = api.internalActions;
      return {
        buildInitiateQuery,
        buildInitiateInfiniteQuery,
        buildInitiateMutation,
        getRunningQueryThunk,
        getRunningMutationThunk,
        getRunningQueriesThunk,
        getRunningMutationsThunk
      };
      function getRunningQueryThunk(endpointName, queryArgs) {
        return (dispatch) => {
          var _a;
          const endpointDefinition = context.endpointDefinitions[endpointName];
          const queryCacheKey = serializeQueryArgs({
            queryArgs,
            endpointDefinition,
            endpointName
          });
          return (_a = runningQueries.get(dispatch)) == null ? void 0 : _a[queryCacheKey];
        };
      }
      function getRunningMutationThunk(_endpointName, fixedCacheKeyOrRequestId) {
        return (dispatch) => {
          var _a;
          return (_a = runningMutations.get(dispatch)) == null ? void 0 : _a[fixedCacheKeyOrRequestId];
        };
      }
      function getRunningQueriesThunk() {
        return (dispatch) => Object.values(runningQueries.get(dispatch) || {}).filter(isNotNullish);
      }
      function getRunningMutationsThunk() {
        return (dispatch) => Object.values(runningMutations.get(dispatch) || {}).filter(isNotNullish);
      }
      function buildInitiateAnyQuery(endpointName, endpointDefinition) {
        const queryAction = (arg, {
          subscribe = true,
          forceRefetch,
          subscriptionOptions,
          [forceQueryFnSymbol]: forceQueryFn,
          ...rest
        } = {}) => (dispatch, getState) => {
          var _a;
          const queryCacheKey = serializeQueryArgs({
            queryArgs: arg,
            endpointDefinition,
            endpointName
          });
          let thunk2;
          const commonThunkArgs = {
            ...rest,
            type: "query",
            subscribe,
            forceRefetch,
            subscriptionOptions,
            endpointName,
            originalArgs: arg,
            queryCacheKey,
            [forceQueryFnSymbol]: forceQueryFn
          };
          if (isQueryDefinition$1(endpointDefinition)) {
            thunk2 = queryThunk(commonThunkArgs);
          } else {
            const {
              direction,
              initialPageParam
            } = rest;
            thunk2 = infiniteQueryThunk({
              ...commonThunkArgs,
              // Supply these even if undefined. This helps with a field existence
              // check over in `buildSlice.ts`
              direction,
              initialPageParam
            });
          }
          const selector = api.endpoints[endpointName].select(arg);
          const thunkResult = dispatch(thunk2);
          const stateAfter = selector(getState());
          const {
            requestId,
            abort
          } = thunkResult;
          const skippedSynchronously = stateAfter.requestId !== requestId;
          const runningQuery = (_a = runningQueries.get(dispatch)) == null ? void 0 : _a[queryCacheKey];
          const selectFromState = () => selector(getState());
          const statePromise = Object.assign(forceQueryFn ? (
            // a query has been forced (upsertQueryData)
            // -> we want to resolve it once data has been written with the data that will be written
            thunkResult.then(selectFromState)
          ) : skippedSynchronously && !runningQuery ? (
            // a query has been skipped due to a condition and we do not have any currently running query
            // -> we want to resolve it immediately with the current data
            Promise.resolve(stateAfter)
          ) : (
            // query just started or one is already in flight
            // -> wait for the running query, then resolve with data from after that
            Promise.all([runningQuery, thunkResult]).then(selectFromState)
          ), {
            arg,
            requestId,
            subscriptionOptions,
            queryCacheKey,
            abort,
            async unwrap() {
              const result = await statePromise;
              if (result.isError) {
                throw result.error;
              }
              return result.data;
            },
            refetch: () => dispatch(queryAction(arg, {
              subscribe: false,
              forceRefetch: true
            })),
            unsubscribe() {
              if (subscribe) dispatch(unsubscribeQueryResult({
                queryCacheKey,
                requestId
              }));
            },
            updateSubscriptionOptions(options) {
              statePromise.subscriptionOptions = options;
              dispatch(updateSubscriptionOptions({
                endpointName,
                requestId,
                queryCacheKey,
                options
              }));
            }
          });
          if (!runningQuery && !skippedSynchronously && !forceQueryFn) {
            const running = getOrInsert(runningQueries, dispatch, {});
            running[queryCacheKey] = statePromise;
            statePromise.then(() => {
              delete running[queryCacheKey];
              if (!countObjectKeys(running)) {
                runningQueries.delete(dispatch);
              }
            });
          }
          return statePromise;
        };
        return queryAction;
      }
      function buildInitiateQuery(endpointName, endpointDefinition) {
        const queryAction = buildInitiateAnyQuery(endpointName, endpointDefinition);
        return queryAction;
      }
      function buildInitiateInfiniteQuery(endpointName, endpointDefinition) {
        const infiniteQueryAction = buildInitiateAnyQuery(endpointName, endpointDefinition);
        return infiniteQueryAction;
      }
      function buildInitiateMutation(endpointName) {
        return (arg, {
          track = true,
          fixedCacheKey
        } = {}) => (dispatch, getState) => {
          const thunk2 = mutationThunk({
            type: "mutation",
            endpointName,
            originalArgs: arg,
            track,
            fixedCacheKey
          });
          const thunkResult = dispatch(thunk2);
          const {
            requestId,
            abort,
            unwrap
          } = thunkResult;
          const returnValuePromise = asSafePromise(thunkResult.unwrap().then((data) => ({
            data
          })), (error) => ({
            error
          }));
          const reset = () => {
            dispatch(removeMutationResult({
              requestId,
              fixedCacheKey
            }));
          };
          const ret = Object.assign(returnValuePromise, {
            arg: thunkResult.arg,
            requestId,
            abort,
            unwrap,
            reset
          });
          const running = runningMutations.get(dispatch) || {};
          runningMutations.set(dispatch, running);
          running[requestId] = ret;
          ret.then(() => {
            delete running[requestId];
            if (!countObjectKeys(running)) {
              runningMutations.delete(dispatch);
            }
          });
          if (fixedCacheKey) {
            running[fixedCacheKey] = ret;
            ret.then(() => {
              if (running[fixedCacheKey] === ret) {
                delete running[fixedCacheKey];
                if (!countObjectKeys(running)) {
                  runningMutations.delete(dispatch);
                }
              }
            });
          }
          return ret;
        };
      }
    }
    var NamedSchemaError = class extends SchemaError {
      constructor(issues, value, schemaName, _bqMeta) {
        super(issues);
        this.value = value;
        this.schemaName = schemaName;
        this._bqMeta = _bqMeta;
      }
    };
    async function parseWithSchema(schema, data, schemaName, bqMeta) {
      const result = await schema["~standard"].validate(data);
      if (result.issues) {
        throw new NamedSchemaError(result.issues, data, schemaName, bqMeta);
      }
      return result.value;
    }
    function defaultTransformResponse(baseQueryReturnValue) {
      return baseQueryReturnValue;
    }
    var addShouldAutoBatch = (arg = {}) => {
      return {
        ...arg,
        [SHOULD_AUTOBATCH]: true
      };
    };
    function buildThunks({
      reducerPath,
      baseQuery,
      context: {
        endpointDefinitions
      },
      serializeQueryArgs,
      api,
      assertTagType,
      selectors,
      onSchemaFailure,
      catchSchemaFailure: globalCatchSchemaFailure,
      skipSchemaValidation: globalSkipSchemaValidation
    }) {
      const patchQueryData = (endpointName, arg, patches, updateProvided) => (dispatch, getState) => {
        const endpointDefinition = endpointDefinitions[endpointName];
        const queryCacheKey = serializeQueryArgs({
          queryArgs: arg,
          endpointDefinition,
          endpointName
        });
        dispatch(api.internalActions.queryResultPatched({
          queryCacheKey,
          patches
        }));
        if (!updateProvided) {
          return;
        }
        const newValue = api.endpoints[endpointName].select(arg)(
          // Work around TS 4.1 mismatch
          getState()
        );
        const providedTags = calculateProvidedBy(endpointDefinition.providesTags, newValue.data, void 0, arg, {}, assertTagType);
        dispatch(api.internalActions.updateProvidedBy([{
          queryCacheKey,
          providedTags
        }]));
      };
      function addToStart(items, item, max = 0) {
        const newItems = [item, ...items];
        return max && newItems.length > max ? newItems.slice(0, -1) : newItems;
      }
      function addToEnd(items, item, max = 0) {
        const newItems = [...items, item];
        return max && newItems.length > max ? newItems.slice(1) : newItems;
      }
      const updateQueryData = (endpointName, arg, updateRecipe, updateProvided = true) => (dispatch, getState) => {
        const endpointDefinition = api.endpoints[endpointName];
        const currentState = endpointDefinition.select(arg)(
          // Work around TS 4.1 mismatch
          getState()
        );
        const ret = {
          patches: [],
          inversePatches: [],
          undo: () => dispatch(api.util.patchQueryData(endpointName, arg, ret.inversePatches, updateProvided))
        };
        if (currentState.status === "uninitialized") {
          return ret;
        }
        let newValue;
        if ("data" in currentState) {
          if (isDraftable(currentState.data)) {
            const [value, patches, inversePatches] = produceWithPatches(currentState.data, updateRecipe);
            ret.patches.push(...patches);
            ret.inversePatches.push(...inversePatches);
            newValue = value;
          } else {
            newValue = updateRecipe(currentState.data);
            ret.patches.push({
              op: "replace",
              path: [],
              value: newValue
            });
            ret.inversePatches.push({
              op: "replace",
              path: [],
              value: currentState.data
            });
          }
        }
        if (ret.patches.length === 0) {
          return ret;
        }
        dispatch(api.util.patchQueryData(endpointName, arg, ret.patches, updateProvided));
        return ret;
      };
      const upsertQueryData = (endpointName, arg, value) => (dispatch) => {
        const res = dispatch(api.endpoints[endpointName].initiate(arg, {
          subscribe: false,
          forceRefetch: true,
          [forceQueryFnSymbol]: () => ({
            data: value
          })
        }));
        return res;
      };
      const getTransformCallbackForEndpoint = (endpointDefinition, transformFieldName) => {
        return endpointDefinition.query && endpointDefinition[transformFieldName] ? endpointDefinition[transformFieldName] : defaultTransformResponse;
      };
      const executeEndpoint = async (arg, {
        signal,
        abort,
        rejectWithValue,
        fulfillWithValue,
        dispatch,
        getState,
        extra
      }) => {
        var _a, _b;
        const endpointDefinition = endpointDefinitions[arg.endpointName];
        const {
          metaSchema,
          skipSchemaValidation = globalSkipSchemaValidation
        } = endpointDefinition;
        try {
          let transformResponse = getTransformCallbackForEndpoint(endpointDefinition, "transformResponse");
          const baseQueryApi = {
            signal,
            abort,
            dispatch,
            getState,
            extra,
            endpoint: arg.endpointName,
            type: arg.type,
            forced: arg.type === "query" ? isForcedQuery(arg, getState()) : void 0,
            queryCacheKey: arg.type === "query" ? arg.queryCacheKey : void 0
          };
          const forceQueryFn = arg.type === "query" ? arg[forceQueryFnSymbol] : void 0;
          let finalQueryReturnValue;
          const fetchPage = async (data, param, maxPages, previous) => {
            if (param == null && data.pages.length) {
              return Promise.resolve({
                data
              });
            }
            const finalQueryArg = {
              queryArg: arg.originalArgs,
              pageParam: param
            };
            const pageResponse = await executeRequest(finalQueryArg);
            const addTo = previous ? addToStart : addToEnd;
            return {
              data: {
                pages: addTo(data.pages, pageResponse.data, maxPages),
                pageParams: addTo(data.pageParams, param, maxPages)
              },
              meta: pageResponse.meta
            };
          };
          async function executeRequest(finalQueryArg) {
            let result;
            const {
              extraOptions,
              argSchema,
              rawResponseSchema,
              responseSchema
            } = endpointDefinition;
            if (argSchema && !skipSchemaValidation) {
              finalQueryArg = await parseWithSchema(
                argSchema,
                finalQueryArg,
                "argSchema",
                {}
                // we don't have a meta yet, so we can't pass it
              );
            }
            if (forceQueryFn) {
              result = forceQueryFn();
            } else if (endpointDefinition.query) {
              result = await baseQuery(endpointDefinition.query(finalQueryArg), baseQueryApi, extraOptions);
            } else {
              result = await endpointDefinition.queryFn(finalQueryArg, baseQueryApi, extraOptions, (arg2) => baseQuery(arg2, baseQueryApi, extraOptions));
            }
            if (typeof process !== "undefined" && false) ;
            if (result.error) throw new HandledError(result.error, result.meta);
            let {
              data
            } = result;
            if (rawResponseSchema && !skipSchemaValidation) {
              data = await parseWithSchema(rawResponseSchema, result.data, "rawResponseSchema", result.meta);
            }
            let transformedResponse = await transformResponse(data, result.meta, finalQueryArg);
            if (responseSchema && !skipSchemaValidation) {
              transformedResponse = await parseWithSchema(responseSchema, transformedResponse, "responseSchema", result.meta);
            }
            return {
              ...result,
              data: transformedResponse
            };
          }
          if (arg.type === "query" && "infiniteQueryOptions" in endpointDefinition) {
            const {
              infiniteQueryOptions
            } = endpointDefinition;
            const {
              maxPages = Infinity
            } = infiniteQueryOptions;
            let result;
            const blankData = {
              pages: [],
              pageParams: []
            };
            const cachedData = (_a = selectors.selectQueryEntry(getState(), arg.queryCacheKey)) == null ? void 0 : _a.data;
            const isForcedQueryNeedingRefetch = (
              // arg.forceRefetch
              isForcedQuery(arg, getState()) && !arg.direction
            );
            const existingData = isForcedQueryNeedingRefetch || !cachedData ? blankData : cachedData;
            if ("direction" in arg && arg.direction && existingData.pages.length) {
              const previous = arg.direction === "backward";
              const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;
              const param = pageParamFn(infiniteQueryOptions, existingData, arg.originalArgs);
              result = await fetchPage(existingData, param, maxPages, previous);
            } else {
              const {
                initialPageParam = infiniteQueryOptions.initialPageParam
              } = arg;
              const cachedPageParams = (cachedData == null ? void 0 : cachedData.pageParams) ?? [];
              const firstPageParam = cachedPageParams[0] ?? initialPageParam;
              const totalPages = cachedPageParams.length;
              result = await fetchPage(existingData, firstPageParam, maxPages);
              if (forceQueryFn) {
                result = {
                  data: result.data.pages[0]
                };
              }
              for (let i = 1; i < totalPages; i++) {
                const param = getNextPageParam(infiniteQueryOptions, result.data, arg.originalArgs);
                result = await fetchPage(result.data, param, maxPages);
              }
            }
            finalQueryReturnValue = result;
          } else {
            finalQueryReturnValue = await executeRequest(arg.originalArgs);
          }
          if (metaSchema && !skipSchemaValidation && finalQueryReturnValue.meta) {
            finalQueryReturnValue.meta = await parseWithSchema(metaSchema, finalQueryReturnValue.meta, "metaSchema", finalQueryReturnValue.meta);
          }
          return fulfillWithValue(finalQueryReturnValue.data, addShouldAutoBatch({
            fulfilledTimeStamp: Date.now(),
            baseQueryMeta: finalQueryReturnValue.meta
          }));
        } catch (error) {
          let caughtError = error;
          if (caughtError instanceof HandledError) {
            let transformErrorResponse = getTransformCallbackForEndpoint(endpointDefinition, "transformErrorResponse");
            const {
              rawErrorResponseSchema,
              errorResponseSchema
            } = endpointDefinition;
            let {
              value,
              meta
            } = caughtError;
            try {
              if (rawErrorResponseSchema && !skipSchemaValidation) {
                value = await parseWithSchema(rawErrorResponseSchema, value, "rawErrorResponseSchema", meta);
              }
              if (metaSchema && !skipSchemaValidation) {
                meta = await parseWithSchema(metaSchema, meta, "metaSchema", meta);
              }
              let transformedErrorResponse = await transformErrorResponse(value, meta, arg.originalArgs);
              if (errorResponseSchema && !skipSchemaValidation) {
                transformedErrorResponse = await parseWithSchema(errorResponseSchema, transformedErrorResponse, "errorResponseSchema", meta);
              }
              return rejectWithValue(transformedErrorResponse, addShouldAutoBatch({
                baseQueryMeta: meta
              }));
            } catch (e) {
              caughtError = e;
            }
          }
          try {
            if (caughtError instanceof NamedSchemaError) {
              const info = {
                endpoint: arg.endpointName,
                arg: arg.originalArgs,
                type: arg.type,
                queryCacheKey: arg.type === "query" ? arg.queryCacheKey : void 0
              };
              (_b = endpointDefinition.onSchemaFailure) == null ? void 0 : _b.call(endpointDefinition, caughtError, info);
              onSchemaFailure == null ? void 0 : onSchemaFailure(caughtError, info);
              const {
                catchSchemaFailure = globalCatchSchemaFailure
              } = endpointDefinition;
              if (catchSchemaFailure) {
                return rejectWithValue(catchSchemaFailure(caughtError, info), addShouldAutoBatch({
                  baseQueryMeta: caughtError._bqMeta
                }));
              }
            }
          } catch (e) {
            caughtError = e;
          }
          {
            console.error(caughtError);
          }
          throw caughtError;
        }
      };
      function isForcedQuery(arg, state) {
        const requestState = selectors.selectQueryEntry(state, arg.queryCacheKey);
        const baseFetchOnMountOrArgChange = selectors.selectConfig(state).refetchOnMountOrArgChange;
        const fulfilledVal = requestState == null ? void 0 : requestState.fulfilledTimeStamp;
        const refetchVal = arg.forceRefetch ?? (arg.subscribe && baseFetchOnMountOrArgChange);
        if (refetchVal) {
          return refetchVal === true || (Number(/* @__PURE__ */ new Date()) - Number(fulfilledVal)) / 1e3 >= refetchVal;
        }
        return false;
      }
      const createQueryThunk = () => {
        const generatedQueryThunk = createAsyncThunk(`${reducerPath}/executeQuery`, executeEndpoint, {
          getPendingMeta({
            arg
          }) {
            const endpointDefinition = endpointDefinitions[arg.endpointName];
            return addShouldAutoBatch({
              startedTimeStamp: Date.now(),
              ...isInfiniteQueryDefinition$1(endpointDefinition) ? {
                direction: arg.direction
              } : {}
            });
          },
          condition(queryThunkArg, {
            getState
          }) {
            var _a;
            const state = getState();
            const requestState = selectors.selectQueryEntry(state, queryThunkArg.queryCacheKey);
            const fulfilledVal = requestState == null ? void 0 : requestState.fulfilledTimeStamp;
            const currentArg = queryThunkArg.originalArgs;
            const previousArg = requestState == null ? void 0 : requestState.originalArgs;
            const endpointDefinition = endpointDefinitions[queryThunkArg.endpointName];
            const direction = queryThunkArg.direction;
            if (isUpsertQuery(queryThunkArg)) {
              return true;
            }
            if ((requestState == null ? void 0 : requestState.status) === "pending") {
              return false;
            }
            if (isForcedQuery(queryThunkArg, state)) {
              return true;
            }
            if (isQueryDefinition$1(endpointDefinition) && ((_a = endpointDefinition == null ? void 0 : endpointDefinition.forceRefetch) == null ? void 0 : _a.call(endpointDefinition, {
              currentArg,
              previousArg,
              endpointState: requestState,
              state
            }))) {
              return true;
            }
            if (fulfilledVal && !direction) {
              return false;
            }
            return true;
          },
          dispatchConditionRejection: true
        });
        return generatedQueryThunk;
      };
      const queryThunk = createQueryThunk();
      const infiniteQueryThunk = createQueryThunk();
      const mutationThunk = createAsyncThunk(`${reducerPath}/executeMutation`, executeEndpoint, {
        getPendingMeta() {
          return addShouldAutoBatch({
            startedTimeStamp: Date.now()
          });
        }
      });
      const hasTheForce = (options) => "force" in options;
      const hasMaxAge = (options) => "ifOlderThan" in options;
      const prefetch = (endpointName, arg, options) => (dispatch, getState) => {
        const force = hasTheForce(options) && options.force;
        const maxAge = hasMaxAge(options) && options.ifOlderThan;
        const queryAction = (force2 = true) => {
          const options2 = {
            forceRefetch: force2,
            isPrefetch: true
          };
          return api.endpoints[endpointName].initiate(arg, options2);
        };
        const latestStateValue = api.endpoints[endpointName].select(arg)(getState());
        if (force) {
          dispatch(queryAction());
        } else if (maxAge) {
          const lastFulfilledTs = latestStateValue == null ? void 0 : latestStateValue.fulfilledTimeStamp;
          if (!lastFulfilledTs) {
            dispatch(queryAction());
            return;
          }
          const shouldRetrigger = (Number(/* @__PURE__ */ new Date()) - Number(new Date(lastFulfilledTs))) / 1e3 >= maxAge;
          if (shouldRetrigger) {
            dispatch(queryAction());
          }
        } else {
          dispatch(queryAction(false));
        }
      };
      function matchesEndpoint(endpointName) {
        return (action) => {
          var _a, _b;
          return ((_b = (_a = action == null ? void 0 : action.meta) == null ? void 0 : _a.arg) == null ? void 0 : _b.endpointName) === endpointName;
        };
      }
      function buildMatchThunkActions(thunk2, endpointName) {
        return {
          matchPending: isAllOf(isPending(thunk2), matchesEndpoint(endpointName)),
          matchFulfilled: isAllOf(isFulfilled(thunk2), matchesEndpoint(endpointName)),
          matchRejected: isAllOf(isRejected(thunk2), matchesEndpoint(endpointName))
        };
      }
      return {
        queryThunk,
        mutationThunk,
        infiniteQueryThunk,
        prefetch,
        updateQueryData,
        upsertQueryData,
        patchQueryData,
        buildMatchThunkActions
      };
    }
    function getNextPageParam(options, {
      pages,
      pageParams
    }, queryArg) {
      const lastIndex = pages.length - 1;
      return options.getNextPageParam(pages[lastIndex], pages, pageParams[lastIndex], pageParams, queryArg);
    }
    function getPreviousPageParam(options, {
      pages,
      pageParams
    }, queryArg) {
      var _a;
      return (_a = options.getPreviousPageParam) == null ? void 0 : _a.call(options, pages[0], pages, pageParams[0], pageParams, queryArg);
    }
    function calculateProvidedByThunk(action, type, endpointDefinitions, assertTagType) {
      return calculateProvidedBy(endpointDefinitions[action.meta.arg.endpointName][type], isFulfilled(action) ? action.payload : void 0, isRejectedWithValue(action) ? action.payload : void 0, action.meta.arg.originalArgs, "baseQueryMeta" in action.meta ? action.meta.baseQueryMeta : void 0, assertTagType);
    }
    function updateQuerySubstateIfExists(state, queryCacheKey, update) {
      const substate = state[queryCacheKey];
      if (substate) {
        update(substate);
      }
    }
    function getMutationCacheKey(id) {
      return ("arg" in id ? id.arg.fixedCacheKey : id.fixedCacheKey) ?? id.requestId;
    }
    function updateMutationSubstateIfExists(state, id, update) {
      const substate = state[getMutationCacheKey(id)];
      if (substate) {
        update(substate);
      }
    }
    var initialState = {};
    function buildSlice({
      reducerPath,
      queryThunk,
      mutationThunk,
      serializeQueryArgs,
      context: {
        endpointDefinitions: definitions,
        apiUid,
        extractRehydrationInfo,
        hasRehydrationInfo
      },
      assertTagType,
      config
    }) {
      const resetApiState = createAction(`${reducerPath}/resetApiState`);
      function writePendingCacheEntry(draft, arg, upserting, meta) {
        var _a;
        draft[_a = arg.queryCacheKey] ?? (draft[_a] = {
          status: "uninitialized",
          endpointName: arg.endpointName
        });
        updateQuerySubstateIfExists(draft, arg.queryCacheKey, (substate) => {
          substate.status = "pending";
          substate.requestId = upserting && substate.requestId ? (
            // for `upsertQuery` **updates**, keep the current `requestId`
            substate.requestId
          ) : (
            // for normal queries or `upsertQuery` **inserts** always update the `requestId`
            meta.requestId
          );
          if (arg.originalArgs !== void 0) {
            substate.originalArgs = arg.originalArgs;
          }
          substate.startedTimeStamp = meta.startedTimeStamp;
          const endpointDefinition = definitions[meta.arg.endpointName];
          if (isInfiniteQueryDefinition$1(endpointDefinition) && "direction" in arg) {
            substate.direction = arg.direction;
          }
        });
      }
      function writeFulfilledCacheEntry(draft, meta, payload, upserting) {
        updateQuerySubstateIfExists(draft, meta.arg.queryCacheKey, (substate) => {
          if (substate.requestId !== meta.requestId && !upserting) return;
          const {
            merge
          } = definitions[meta.arg.endpointName];
          substate.status = "fulfilled";
          if (merge) {
            if (substate.data !== void 0) {
              const {
                fulfilledTimeStamp,
                arg,
                baseQueryMeta,
                requestId
              } = meta;
              let newData = produce(substate.data, (draftSubstateData) => {
                return merge(draftSubstateData, payload, {
                  arg: arg.originalArgs,
                  baseQueryMeta,
                  fulfilledTimeStamp,
                  requestId
                });
              });
              substate.data = newData;
            } else {
              substate.data = payload;
            }
          } else {
            substate.data = definitions[meta.arg.endpointName].structuralSharing ?? true ? copyWithStructuralSharing(isDraft(substate.data) ? original(substate.data) : substate.data, payload) : payload;
          }
          delete substate.error;
          substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;
        });
      }
      const querySlice = createSlice({
        name: `${reducerPath}/queries`,
        initialState,
        reducers: {
          removeQueryResult: {
            reducer(draft, {
              payload: {
                queryCacheKey
              }
            }) {
              delete draft[queryCacheKey];
            },
            prepare: prepareAutoBatched()
          },
          cacheEntriesUpserted: {
            reducer(draft, action) {
              for (const entry of action.payload) {
                const {
                  queryDescription: arg,
                  value
                } = entry;
                writePendingCacheEntry(draft, arg, true, {
                  arg,
                  requestId: action.meta.requestId,
                  startedTimeStamp: action.meta.timestamp
                });
                writeFulfilledCacheEntry(
                  draft,
                  {
                    arg,
                    requestId: action.meta.requestId,
                    fulfilledTimeStamp: action.meta.timestamp,
                    baseQueryMeta: {}
                  },
                  value,
                  // We know we're upserting here
                  true
                );
              }
            },
            prepare: (payload) => {
              const queryDescriptions = payload.map((entry) => {
                const {
                  endpointName,
                  arg,
                  value
                } = entry;
                const endpointDefinition = definitions[endpointName];
                const queryDescription = {
                  type: "query",
                  endpointName,
                  originalArgs: entry.arg,
                  queryCacheKey: serializeQueryArgs({
                    queryArgs: arg,
                    endpointDefinition,
                    endpointName
                  })
                };
                return {
                  queryDescription,
                  value
                };
              });
              const result = {
                payload: queryDescriptions,
                meta: {
                  [SHOULD_AUTOBATCH]: true,
                  requestId: nanoid(),
                  timestamp: Date.now()
                }
              };
              return result;
            }
          },
          queryResultPatched: {
            reducer(draft, {
              payload: {
                queryCacheKey,
                patches
              }
            }) {
              updateQuerySubstateIfExists(draft, queryCacheKey, (substate) => {
                substate.data = applyPatches(substate.data, patches.concat());
              });
            },
            prepare: prepareAutoBatched()
          }
        },
        extraReducers(builder) {
          builder.addCase(queryThunk.pending, (draft, {
            meta,
            meta: {
              arg
            }
          }) => {
            const upserting = isUpsertQuery(arg);
            writePendingCacheEntry(draft, arg, upserting, meta);
          }).addCase(queryThunk.fulfilled, (draft, {
            meta,
            payload
          }) => {
            const upserting = isUpsertQuery(meta.arg);
            writeFulfilledCacheEntry(draft, meta, payload, upserting);
          }).addCase(queryThunk.rejected, (draft, {
            meta: {
              condition,
              arg,
              requestId
            },
            error,
            payload
          }) => {
            updateQuerySubstateIfExists(draft, arg.queryCacheKey, (substate) => {
              if (condition) ;
              else {
                if (substate.requestId !== requestId) return;
                substate.status = "rejected";
                substate.error = payload ?? error;
              }
            });
          }).addMatcher(hasRehydrationInfo, (draft, action) => {
            const {
              queries
            } = extractRehydrationInfo(action);
            for (const [key, entry] of Object.entries(queries)) {
              if (
                // do not rehydrate entries that were currently in flight.
                (entry == null ? void 0 : entry.status) === "fulfilled" || (entry == null ? void 0 : entry.status) === "rejected"
              ) {
                draft[key] = entry;
              }
            }
          });
        }
      });
      const mutationSlice = createSlice({
        name: `${reducerPath}/mutations`,
        initialState,
        reducers: {
          removeMutationResult: {
            reducer(draft, {
              payload
            }) {
              const cacheKey = getMutationCacheKey(payload);
              if (cacheKey in draft) {
                delete draft[cacheKey];
              }
            },
            prepare: prepareAutoBatched()
          }
        },
        extraReducers(builder) {
          builder.addCase(mutationThunk.pending, (draft, {
            meta,
            meta: {
              requestId,
              arg,
              startedTimeStamp
            }
          }) => {
            if (!arg.track) return;
            draft[getMutationCacheKey(meta)] = {
              requestId,
              status: "pending",
              endpointName: arg.endpointName,
              startedTimeStamp
            };
          }).addCase(mutationThunk.fulfilled, (draft, {
            payload,
            meta
          }) => {
            if (!meta.arg.track) return;
            updateMutationSubstateIfExists(draft, meta, (substate) => {
              if (substate.requestId !== meta.requestId) return;
              substate.status = "fulfilled";
              substate.data = payload;
              substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;
            });
          }).addCase(mutationThunk.rejected, (draft, {
            payload,
            error,
            meta
          }) => {
            if (!meta.arg.track) return;
            updateMutationSubstateIfExists(draft, meta, (substate) => {
              if (substate.requestId !== meta.requestId) return;
              substate.status = "rejected";
              substate.error = payload ?? error;
            });
          }).addMatcher(hasRehydrationInfo, (draft, action) => {
            const {
              mutations
            } = extractRehydrationInfo(action);
            for (const [key, entry] of Object.entries(mutations)) {
              if (
                // do not rehydrate entries that were currently in flight.
                ((entry == null ? void 0 : entry.status) === "fulfilled" || (entry == null ? void 0 : entry.status) === "rejected") && // only rehydrate endpoints that were persisted using a `fixedCacheKey`
                key !== (entry == null ? void 0 : entry.requestId)
              ) {
                draft[key] = entry;
              }
            }
          });
        }
      });
      const initialInvalidationState = {
        tags: {},
        keys: {}
      };
      const invalidationSlice = createSlice({
        name: `${reducerPath}/invalidation`,
        initialState: initialInvalidationState,
        reducers: {
          updateProvidedBy: {
            reducer(draft, action) {
              var _a, _b, _c;
              for (const {
                queryCacheKey,
                providedTags
              } of action.payload) {
                removeCacheKeyFromTags(draft, queryCacheKey);
                for (const {
                  type,
                  id
                } of providedTags) {
                  const subscribedQueries = (_b = (_a = draft.tags)[type] ?? (_a[type] = {}))[_c = id || "__internal_without_id"] ?? (_b[_c] = []);
                  const alreadySubscribed = subscribedQueries.includes(queryCacheKey);
                  if (!alreadySubscribed) {
                    subscribedQueries.push(queryCacheKey);
                  }
                }
                draft.keys[queryCacheKey] = providedTags;
              }
            },
            prepare: prepareAutoBatched()
          }
        },
        extraReducers(builder) {
          builder.addCase(querySlice.actions.removeQueryResult, (draft, {
            payload: {
              queryCacheKey
            }
          }) => {
            removeCacheKeyFromTags(draft, queryCacheKey);
          }).addMatcher(hasRehydrationInfo, (draft, action) => {
            var _a, _b, _c;
            const {
              provided
            } = extractRehydrationInfo(action);
            for (const [type, incomingTags] of Object.entries(provided)) {
              for (const [id, cacheKeys] of Object.entries(incomingTags)) {
                const subscribedQueries = (_b = (_a = draft.tags)[type] ?? (_a[type] = {}))[_c = id || "__internal_without_id"] ?? (_b[_c] = []);
                for (const queryCacheKey of cacheKeys) {
                  const alreadySubscribed = subscribedQueries.includes(queryCacheKey);
                  if (!alreadySubscribed) {
                    subscribedQueries.push(queryCacheKey);
                  }
                }
              }
            }
          }).addMatcher(isAnyOf(isFulfilled(queryThunk), isRejectedWithValue(queryThunk)), (draft, action) => {
            writeProvidedTagsForQueries(draft, [action]);
          }).addMatcher(querySlice.actions.cacheEntriesUpserted.match, (draft, action) => {
            const mockActions = action.payload.map(({
              queryDescription,
              value
            }) => {
              return {
                type: "UNKNOWN",
                payload: value,
                meta: {
                  requestStatus: "fulfilled",
                  requestId: "UNKNOWN",
                  arg: queryDescription
                }
              };
            });
            writeProvidedTagsForQueries(draft, mockActions);
          });
        }
      });
      function removeCacheKeyFromTags(draft, queryCacheKey) {
        var _a;
        const existingTags = draft.keys[queryCacheKey] ?? [];
        for (const tag of existingTags) {
          const tagType = tag.type;
          const tagId = tag.id ?? "__internal_without_id";
          const tagSubscriptions = (_a = draft.tags[tagType]) == null ? void 0 : _a[tagId];
          if (tagSubscriptions) {
            draft.tags[tagType][tagId] = tagSubscriptions.filter((qc) => qc !== queryCacheKey);
          }
        }
        delete draft.keys[queryCacheKey];
      }
      function writeProvidedTagsForQueries(draft, actions2) {
        const providedByEntries = actions2.map((action) => {
          const providedTags = calculateProvidedByThunk(action, "providesTags", definitions, assertTagType);
          const {
            queryCacheKey
          } = action.meta.arg;
          return {
            queryCacheKey,
            providedTags
          };
        });
        invalidationSlice.caseReducers.updateProvidedBy(draft, invalidationSlice.actions.updateProvidedBy(providedByEntries));
      }
      const subscriptionSlice = createSlice({
        name: `${reducerPath}/subscriptions`,
        initialState,
        reducers: {
          updateSubscriptionOptions(d, a) {
          },
          unsubscribeQueryResult(d, a) {
          },
          internal_getRTKQSubscriptions() {
          }
        }
      });
      const internalSubscriptionsSlice = createSlice({
        name: `${reducerPath}/internalSubscriptions`,
        initialState,
        reducers: {
          subscriptionsUpdated: {
            reducer(state, action) {
              return applyPatches(state, action.payload);
            },
            prepare: prepareAutoBatched()
          }
        }
      });
      const configSlice = createSlice({
        name: `${reducerPath}/config`,
        initialState: {
          online: isOnline(),
          focused: isDocumentVisible(),
          middlewareRegistered: false,
          ...config
        },
        reducers: {
          middlewareRegistered(state, {
            payload
          }) {
            state.middlewareRegistered = state.middlewareRegistered === "conflict" || apiUid !== payload ? "conflict" : true;
          }
        },
        extraReducers: (builder) => {
          builder.addCase(onOnline, (state) => {
            state.online = true;
          }).addCase(onOffline, (state) => {
            state.online = false;
          }).addCase(onFocus, (state) => {
            state.focused = true;
          }).addCase(onFocusLost, (state) => {
            state.focused = false;
          }).addMatcher(hasRehydrationInfo, (draft) => ({
            ...draft
          }));
        }
      });
      const combinedReducer = combineReducers({
        queries: querySlice.reducer,
        mutations: mutationSlice.reducer,
        provided: invalidationSlice.reducer,
        subscriptions: internalSubscriptionsSlice.reducer,
        config: configSlice.reducer
      });
      const reducer = (state, action) => combinedReducer(resetApiState.match(action) ? void 0 : state, action);
      const actions = {
        ...configSlice.actions,
        ...querySlice.actions,
        ...subscriptionSlice.actions,
        ...internalSubscriptionsSlice.actions,
        ...mutationSlice.actions,
        ...invalidationSlice.actions,
        resetApiState
      };
      return {
        reducer,
        actions
      };
    }
    var skipToken = /* @__PURE__ */ Symbol.for("RTKQ/skipToken");
    var initialSubState = {
      status: "uninitialized"
      /* uninitialized */
    };
    var defaultQuerySubState = /* @__PURE__ */ produce(initialSubState, () => {
    });
    var defaultMutationSubState = /* @__PURE__ */ produce(initialSubState, () => {
    });
    function buildSelectors({
      serializeQueryArgs,
      reducerPath,
      createSelector: createSelector2
    }) {
      const selectSkippedQuery = (state) => defaultQuerySubState;
      const selectSkippedMutation = (state) => defaultMutationSubState;
      return {
        buildQuerySelector,
        buildInfiniteQuerySelector,
        buildMutationSelector,
        selectInvalidatedBy,
        selectCachedArgsForQuery,
        selectApiState,
        selectQueries,
        selectMutations,
        selectQueryEntry,
        selectConfig
      };
      function withRequestFlags(substate) {
        return {
          ...substate,
          ...getRequestStatusFlags(substate.status)
        };
      }
      function selectApiState(rootState) {
        const state = rootState[reducerPath];
        return state;
      }
      function selectQueries(rootState) {
        var _a;
        return (_a = selectApiState(rootState)) == null ? void 0 : _a.queries;
      }
      function selectQueryEntry(rootState, cacheKey) {
        var _a;
        return (_a = selectQueries(rootState)) == null ? void 0 : _a[cacheKey];
      }
      function selectMutations(rootState) {
        var _a;
        return (_a = selectApiState(rootState)) == null ? void 0 : _a.mutations;
      }
      function selectConfig(rootState) {
        var _a;
        return (_a = selectApiState(rootState)) == null ? void 0 : _a.config;
      }
      function buildAnyQuerySelector(endpointName, endpointDefinition, combiner) {
        return (queryArgs) => {
          if (queryArgs === skipToken) {
            return createSelector2(selectSkippedQuery, combiner);
          }
          const serializedArgs = serializeQueryArgs({
            queryArgs,
            endpointDefinition,
            endpointName
          });
          const selectQuerySubstate = (state) => selectQueryEntry(state, serializedArgs) ?? defaultQuerySubState;
          return createSelector2(selectQuerySubstate, combiner);
        };
      }
      function buildQuerySelector(endpointName, endpointDefinition) {
        return buildAnyQuerySelector(endpointName, endpointDefinition, withRequestFlags);
      }
      function buildInfiniteQuerySelector(endpointName, endpointDefinition) {
        const {
          infiniteQueryOptions
        } = endpointDefinition;
        function withInfiniteQueryResultFlags(substate) {
          const stateWithRequestFlags = {
            ...substate,
            ...getRequestStatusFlags(substate.status)
          };
          const {
            isLoading,
            isError,
            direction
          } = stateWithRequestFlags;
          const isForward = direction === "forward";
          const isBackward = direction === "backward";
          return {
            ...stateWithRequestFlags,
            hasNextPage: getHasNextPage(infiniteQueryOptions, stateWithRequestFlags.data, stateWithRequestFlags.originalArgs),
            hasPreviousPage: getHasPreviousPage(infiniteQueryOptions, stateWithRequestFlags.data, stateWithRequestFlags.originalArgs),
            isFetchingNextPage: isLoading && isForward,
            isFetchingPreviousPage: isLoading && isBackward,
            isFetchNextPageError: isError && isForward,
            isFetchPreviousPageError: isError && isBackward
          };
        }
        return buildAnyQuerySelector(endpointName, endpointDefinition, withInfiniteQueryResultFlags);
      }
      function buildMutationSelector() {
        return (id) => {
          let mutationId;
          if (typeof id === "object") {
            mutationId = getMutationCacheKey(id) ?? skipToken;
          } else {
            mutationId = id;
          }
          const selectMutationSubstate = (state) => {
            var _a, _b;
            return ((_b = (_a = selectApiState(state)) == null ? void 0 : _a.mutations) == null ? void 0 : _b[mutationId]) ?? defaultMutationSubState;
          };
          const finalSelectMutationSubstate = mutationId === skipToken ? selectSkippedMutation : selectMutationSubstate;
          return createSelector2(finalSelectMutationSubstate, withRequestFlags);
        };
      }
      function selectInvalidatedBy(state, tags) {
        const apiState = state[reducerPath];
        const toInvalidate = /* @__PURE__ */ new Set();
        for (const tag of tags.filter(isNotNullish).map(expandTagDescription)) {
          const provided = apiState.provided.tags[tag.type];
          if (!provided) {
            continue;
          }
          let invalidateSubscriptions = (tag.id !== void 0 ? (
            // id given: invalidate all queries that provide this type & id
            provided[tag.id]
          ) : (
            // no id: invalidate all queries that provide this type
            flatten(Object.values(provided))
          )) ?? [];
          for (const invalidate of invalidateSubscriptions) {
            toInvalidate.add(invalidate);
          }
        }
        return flatten(Array.from(toInvalidate.values()).map((queryCacheKey) => {
          const querySubState = apiState.queries[queryCacheKey];
          return querySubState ? [{
            queryCacheKey,
            endpointName: querySubState.endpointName,
            originalArgs: querySubState.originalArgs
          }] : [];
        }));
      }
      function selectCachedArgsForQuery(state, queryName) {
        return Object.values(selectQueries(state)).filter(
          (entry) => (entry == null ? void 0 : entry.endpointName) === queryName && entry.status !== "uninitialized"
          /* uninitialized */
        ).map((entry) => entry.originalArgs);
      }
      function getHasNextPage(options, data, queryArg) {
        if (!data) return false;
        return getNextPageParam(options, data, queryArg) != null;
      }
      function getHasPreviousPage(options, data, queryArg) {
        if (!data || !options.getPreviousPageParam) return false;
        return getPreviousPageParam(options, data, queryArg) != null;
      }
    }
    var cache = WeakMap ? /* @__PURE__ */ new WeakMap() : void 0;
    var defaultSerializeQueryArgs = ({
      endpointName,
      queryArgs
    }) => {
      let serialized = "";
      const cached = cache == null ? void 0 : cache.get(queryArgs);
      if (typeof cached === "string") {
        serialized = cached;
      } else {
        const stringified = JSON.stringify(queryArgs, (key, value) => {
          value = typeof value === "bigint" ? {
            $bigint: value.toString()
          } : value;
          value = isPlainObject$1(value) ? Object.keys(value).sort().reduce((acc, key2) => {
            acc[key2] = value[key2];
            return acc;
          }, {}) : value;
          return value;
        });
        if (isPlainObject$1(queryArgs)) {
          cache == null ? void 0 : cache.set(queryArgs, stringified);
        }
        serialized = stringified;
      }
      return `${endpointName}(${serialized})`;
    };
    function buildCreateApi(...modules) {
      return function baseCreateApi(options) {
        const extractRehydrationInfo = weakMapMemoize((action) => {
          var _a;
          return (_a = options.extractRehydrationInfo) == null ? void 0 : _a.call(options, action, {
            reducerPath: options.reducerPath ?? "api"
          });
        });
        const optionsWithDefaults = {
          reducerPath: "api",
          keepUnusedDataFor: 60,
          refetchOnMountOrArgChange: false,
          refetchOnFocus: false,
          refetchOnReconnect: false,
          invalidationBehavior: "delayed",
          ...options,
          extractRehydrationInfo,
          serializeQueryArgs(queryArgsApi) {
            let finalSerializeQueryArgs = defaultSerializeQueryArgs;
            if ("serializeQueryArgs" in queryArgsApi.endpointDefinition) {
              const endpointSQA = queryArgsApi.endpointDefinition.serializeQueryArgs;
              finalSerializeQueryArgs = (queryArgsApi2) => {
                const initialResult = endpointSQA(queryArgsApi2);
                if (typeof initialResult === "string") {
                  return initialResult;
                } else {
                  return defaultSerializeQueryArgs({
                    ...queryArgsApi2,
                    queryArgs: initialResult
                  });
                }
              };
            } else if (options.serializeQueryArgs) {
              finalSerializeQueryArgs = options.serializeQueryArgs;
            }
            return finalSerializeQueryArgs(queryArgsApi);
          },
          tagTypes: [...options.tagTypes || []]
        };
        const context = {
          endpointDefinitions: {},
          batch(fn) {
            fn();
          },
          apiUid: nanoid(),
          extractRehydrationInfo,
          hasRehydrationInfo: weakMapMemoize((action) => extractRehydrationInfo(action) != null)
        };
        const api = {
          injectEndpoints,
          enhanceEndpoints({
            addTagTypes,
            endpoints
          }) {
            if (addTagTypes) {
              for (const eT of addTagTypes) {
                if (!optionsWithDefaults.tagTypes.includes(eT)) {
                  optionsWithDefaults.tagTypes.push(eT);
                }
              }
            }
            if (endpoints) {
              for (const [endpointName, partialDefinition] of Object.entries(endpoints)) {
                if (typeof partialDefinition === "function") {
                  partialDefinition(context.endpointDefinitions[endpointName]);
                } else {
                  Object.assign(context.endpointDefinitions[endpointName] || {}, partialDefinition);
                }
              }
            }
            return api;
          }
        };
        const initializedModules = modules.map((m) => m.init(api, optionsWithDefaults, context));
        function injectEndpoints(inject) {
          const evaluatedEndpoints = inject.endpoints({
            query: (x) => ({
              ...x,
              type: "query"
              /* query */
            }),
            mutation: (x) => ({
              ...x,
              type: "mutation"
              /* mutation */
            }),
            infiniteQuery: (x) => ({
              ...x,
              type: "infinitequery"
              /* infinitequery */
            })
          });
          for (const [endpointName, definition] of Object.entries(evaluatedEndpoints)) {
            if (inject.overrideExisting !== true && endpointName in context.endpointDefinitions) {
              if (inject.overrideExisting === "throw") {
                throw new Error(formatProdErrorMessage(39));
              }
              continue;
            }
            context.endpointDefinitions[endpointName] = definition;
            for (const m of initializedModules) {
              m.injectEndpoint(endpointName, definition);
            }
          }
          return api;
        }
        return api.injectEndpoints({
          endpoints: options.endpoints
        });
      };
    }
    function safeAssign$1(target, ...args) {
      return Object.assign(target, ...args);
    }
    var buildBatchedActionsHandler = ({
      api,
      queryThunk,
      internalState
    }) => {
      const subscriptionsPrefix = `${api.reducerPath}/subscriptions`;
      let previousSubscriptions = null;
      let updateSyncTimer = null;
      const {
        updateSubscriptionOptions,
        unsubscribeQueryResult
      } = api.internalActions;
      const actuallyMutateSubscriptions = (mutableState, action) => {
        var _a, _b, _c;
        if (updateSubscriptionOptions.match(action)) {
          const {
            queryCacheKey,
            requestId,
            options
          } = action.payload;
          if ((_a = mutableState == null ? void 0 : mutableState[queryCacheKey]) == null ? void 0 : _a[requestId]) {
            mutableState[queryCacheKey][requestId] = options;
          }
          return true;
        }
        if (unsubscribeQueryResult.match(action)) {
          const {
            queryCacheKey,
            requestId
          } = action.payload;
          if (mutableState[queryCacheKey]) {
            delete mutableState[queryCacheKey][requestId];
          }
          return true;
        }
        if (api.internalActions.removeQueryResult.match(action)) {
          delete mutableState[action.payload.queryCacheKey];
          return true;
        }
        if (queryThunk.pending.match(action)) {
          const {
            meta: {
              arg,
              requestId
            }
          } = action;
          const substate = mutableState[_b = arg.queryCacheKey] ?? (mutableState[_b] = {});
          substate[`${requestId}_running`] = {};
          if (arg.subscribe) {
            substate[requestId] = arg.subscriptionOptions ?? substate[requestId] ?? {};
          }
          return true;
        }
        let mutated = false;
        if (queryThunk.fulfilled.match(action) || queryThunk.rejected.match(action)) {
          const state = mutableState[action.meta.arg.queryCacheKey] || {};
          const key = `${action.meta.requestId}_running`;
          mutated || (mutated = !!state[key]);
          delete state[key];
        }
        if (queryThunk.rejected.match(action)) {
          const {
            meta: {
              condition,
              arg,
              requestId
            }
          } = action;
          if (condition && arg.subscribe) {
            const substate = mutableState[_c = arg.queryCacheKey] ?? (mutableState[_c] = {});
            substate[requestId] = arg.subscriptionOptions ?? substate[requestId] ?? {};
            mutated = true;
          }
        }
        return mutated;
      };
      const getSubscriptions = () => internalState.currentSubscriptions;
      const getSubscriptionCount = (queryCacheKey) => {
        const subscriptions = getSubscriptions();
        const subscriptionsForQueryArg = subscriptions[queryCacheKey] ?? {};
        return countObjectKeys(subscriptionsForQueryArg);
      };
      const isRequestSubscribed = (queryCacheKey, requestId) => {
        var _a;
        const subscriptions = getSubscriptions();
        return !!((_a = subscriptions == null ? void 0 : subscriptions[queryCacheKey]) == null ? void 0 : _a[requestId]);
      };
      const subscriptionSelectors = {
        getSubscriptions,
        getSubscriptionCount,
        isRequestSubscribed
      };
      return (action, mwApi) => {
        if (!previousSubscriptions) {
          previousSubscriptions = JSON.parse(JSON.stringify(internalState.currentSubscriptions));
        }
        if (api.util.resetApiState.match(action)) {
          previousSubscriptions = internalState.currentSubscriptions = {};
          updateSyncTimer = null;
          return [true, false];
        }
        if (api.internalActions.internal_getRTKQSubscriptions.match(action)) {
          return [false, subscriptionSelectors];
        }
        const didMutate = actuallyMutateSubscriptions(internalState.currentSubscriptions, action);
        let actionShouldContinue = true;
        if (didMutate) {
          if (!updateSyncTimer) {
            updateSyncTimer = setTimeout(() => {
              const newSubscriptions = JSON.parse(JSON.stringify(internalState.currentSubscriptions));
              const [, patches] = produceWithPatches(previousSubscriptions, () => newSubscriptions);
              mwApi.next(api.internalActions.subscriptionsUpdated(patches));
              previousSubscriptions = newSubscriptions;
              updateSyncTimer = null;
            }, 500);
          }
          const isSubscriptionSliceAction = typeof action.type == "string" && !!action.type.startsWith(subscriptionsPrefix);
          const isAdditionalSubscriptionAction = queryThunk.rejected.match(action) && action.meta.condition && !!action.meta.arg.subscribe;
          actionShouldContinue = !isSubscriptionSliceAction && !isAdditionalSubscriptionAction;
        }
        return [actionShouldContinue, false];
      };
    };
    function isObjectEmpty(obj) {
      for (const k in obj) {
        return false;
      }
      return true;
    }
    var THIRTY_TWO_BIT_MAX_TIMER_SECONDS = 2147483647 / 1e3 - 1;
    var buildCacheCollectionHandler = ({
      reducerPath,
      api,
      queryThunk,
      context,
      internalState,
      selectors: {
        selectQueryEntry,
        selectConfig
      }
    }) => {
      const {
        removeQueryResult,
        unsubscribeQueryResult,
        cacheEntriesUpserted
      } = api.internalActions;
      const canTriggerUnsubscribe = isAnyOf(unsubscribeQueryResult.match, queryThunk.fulfilled, queryThunk.rejected, cacheEntriesUpserted.match);
      function anySubscriptionsRemainingForKey(queryCacheKey) {
        const subscriptions = internalState.currentSubscriptions[queryCacheKey];
        return !!subscriptions && !isObjectEmpty(subscriptions);
      }
      const currentRemovalTimeouts = {};
      const handler2 = (action, mwApi, internalState2) => {
        const state = mwApi.getState();
        const config = selectConfig(state);
        if (canTriggerUnsubscribe(action)) {
          let queryCacheKeys;
          if (cacheEntriesUpserted.match(action)) {
            queryCacheKeys = action.payload.map((entry) => entry.queryDescription.queryCacheKey);
          } else {
            const {
              queryCacheKey
            } = unsubscribeQueryResult.match(action) ? action.payload : action.meta.arg;
            queryCacheKeys = [queryCacheKey];
          }
          handleUnsubscribeMany(queryCacheKeys, mwApi, config);
        }
        if (api.util.resetApiState.match(action)) {
          for (const [key, timeout] of Object.entries(currentRemovalTimeouts)) {
            if (timeout) clearTimeout(timeout);
            delete currentRemovalTimeouts[key];
          }
        }
        if (context.hasRehydrationInfo(action)) {
          const {
            queries
          } = context.extractRehydrationInfo(action);
          handleUnsubscribeMany(Object.keys(queries), mwApi, config);
        }
      };
      function handleUnsubscribeMany(cacheKeys, api2, config) {
        const state = api2.getState();
        for (const queryCacheKey of cacheKeys) {
          const entry = selectQueryEntry(state, queryCacheKey);
          handleUnsubscribe(queryCacheKey, entry == null ? void 0 : entry.endpointName, api2, config);
        }
      }
      function handleUnsubscribe(queryCacheKey, endpointName, api2, config) {
        const endpointDefinition = context.endpointDefinitions[endpointName];
        const keepUnusedDataFor = (endpointDefinition == null ? void 0 : endpointDefinition.keepUnusedDataFor) ?? config.keepUnusedDataFor;
        if (keepUnusedDataFor === Infinity) {
          return;
        }
        const finalKeepUnusedDataFor = Math.max(0, Math.min(keepUnusedDataFor, THIRTY_TWO_BIT_MAX_TIMER_SECONDS));
        if (!anySubscriptionsRemainingForKey(queryCacheKey)) {
          const currentTimeout = currentRemovalTimeouts[queryCacheKey];
          if (currentTimeout) {
            clearTimeout(currentTimeout);
          }
          currentRemovalTimeouts[queryCacheKey] = setTimeout(() => {
            if (!anySubscriptionsRemainingForKey(queryCacheKey)) {
              api2.dispatch(removeQueryResult({
                queryCacheKey
              }));
            }
            delete currentRemovalTimeouts[queryCacheKey];
          }, finalKeepUnusedDataFor * 1e3);
        }
      }
      return handler2;
    };
    var neverResolvedError = new Error("Promise never resolved before cacheEntryRemoved.");
    var buildCacheLifecycleHandler = ({
      api,
      reducerPath,
      context,
      queryThunk,
      mutationThunk,
      internalState,
      selectors: {
        selectQueryEntry,
        selectApiState
      }
    }) => {
      const isQueryThunk = isAsyncThunkAction(queryThunk);
      const isMutationThunk = isAsyncThunkAction(mutationThunk);
      const isFulfilledThunk = isFulfilled(queryThunk, mutationThunk);
      const lifecycleMap = {};
      function resolveLifecycleEntry(cacheKey, data, meta) {
        const lifecycle = lifecycleMap[cacheKey];
        if (lifecycle == null ? void 0 : lifecycle.valueResolved) {
          lifecycle.valueResolved({
            data,
            meta
          });
          delete lifecycle.valueResolved;
        }
      }
      function removeLifecycleEntry(cacheKey) {
        const lifecycle = lifecycleMap[cacheKey];
        if (lifecycle) {
          delete lifecycleMap[cacheKey];
          lifecycle.cacheEntryRemoved();
        }
      }
      const handler2 = (action, mwApi, stateBefore) => {
        const cacheKey = getCacheKey(action);
        function checkForNewCacheKey(endpointName, cacheKey2, requestId, originalArgs) {
          const oldEntry = selectQueryEntry(stateBefore, cacheKey2);
          const newEntry = selectQueryEntry(mwApi.getState(), cacheKey2);
          if (!oldEntry && newEntry) {
            handleNewKey(endpointName, originalArgs, cacheKey2, mwApi, requestId);
          }
        }
        if (queryThunk.pending.match(action)) {
          checkForNewCacheKey(action.meta.arg.endpointName, cacheKey, action.meta.requestId, action.meta.arg.originalArgs);
        } else if (api.internalActions.cacheEntriesUpserted.match(action)) {
          for (const {
            queryDescription,
            value
          } of action.payload) {
            const {
              endpointName,
              originalArgs,
              queryCacheKey
            } = queryDescription;
            checkForNewCacheKey(endpointName, queryCacheKey, action.meta.requestId, originalArgs);
            resolveLifecycleEntry(queryCacheKey, value, {});
          }
        } else if (mutationThunk.pending.match(action)) {
          const state = mwApi.getState()[reducerPath].mutations[cacheKey];
          if (state) {
            handleNewKey(action.meta.arg.endpointName, action.meta.arg.originalArgs, cacheKey, mwApi, action.meta.requestId);
          }
        } else if (isFulfilledThunk(action)) {
          resolveLifecycleEntry(cacheKey, action.payload, action.meta.baseQueryMeta);
        } else if (api.internalActions.removeQueryResult.match(action) || api.internalActions.removeMutationResult.match(action)) {
          removeLifecycleEntry(cacheKey);
        } else if (api.util.resetApiState.match(action)) {
          for (const cacheKey2 of Object.keys(lifecycleMap)) {
            removeLifecycleEntry(cacheKey2);
          }
        }
      };
      function getCacheKey(action) {
        if (isQueryThunk(action)) return action.meta.arg.queryCacheKey;
        if (isMutationThunk(action)) {
          return action.meta.arg.fixedCacheKey ?? action.meta.requestId;
        }
        if (api.internalActions.removeQueryResult.match(action)) return action.payload.queryCacheKey;
        if (api.internalActions.removeMutationResult.match(action)) return getMutationCacheKey(action.payload);
        return "";
      }
      function handleNewKey(endpointName, originalArgs, queryCacheKey, mwApi, requestId) {
        const endpointDefinition = context.endpointDefinitions[endpointName];
        const onCacheEntryAdded = endpointDefinition == null ? void 0 : endpointDefinition.onCacheEntryAdded;
        if (!onCacheEntryAdded) return;
        const lifecycle = {};
        const cacheEntryRemoved = new Promise((resolve) => {
          lifecycle.cacheEntryRemoved = resolve;
        });
        const cacheDataLoaded = Promise.race([new Promise((resolve) => {
          lifecycle.valueResolved = resolve;
        }), cacheEntryRemoved.then(() => {
          throw neverResolvedError;
        })]);
        cacheDataLoaded.catch(() => {
        });
        lifecycleMap[queryCacheKey] = lifecycle;
        const selector = api.endpoints[endpointName].select(isAnyQueryDefinition(endpointDefinition) ? originalArgs : queryCacheKey);
        const extra = mwApi.dispatch((_, __, extra2) => extra2);
        const lifecycleApi = {
          ...mwApi,
          getCacheEntry: () => selector(mwApi.getState()),
          requestId,
          extra,
          updateCachedData: isAnyQueryDefinition(endpointDefinition) ? (updateRecipe) => mwApi.dispatch(api.util.updateQueryData(endpointName, originalArgs, updateRecipe)) : void 0,
          cacheDataLoaded,
          cacheEntryRemoved
        };
        const runningHandler = onCacheEntryAdded(originalArgs, lifecycleApi);
        Promise.resolve(runningHandler).catch((e) => {
          if (e === neverResolvedError) return;
          throw e;
        });
      }
      return handler2;
    };
    var buildDevCheckHandler = ({
      api,
      context: {
        apiUid
      },
      reducerPath
    }) => {
      return (action, mwApi) => {
        if (api.util.resetApiState.match(action)) {
          mwApi.dispatch(api.internalActions.middlewareRegistered(apiUid));
        }
      };
    };
    var buildInvalidationByTagsHandler = ({
      reducerPath,
      context,
      context: {
        endpointDefinitions
      },
      mutationThunk,
      queryThunk,
      api,
      assertTagType,
      refetchQuery,
      internalState
    }) => {
      const {
        removeQueryResult
      } = api.internalActions;
      const isThunkActionWithTags = isAnyOf(isFulfilled(mutationThunk), isRejectedWithValue(mutationThunk));
      const isQueryEnd = isAnyOf(isFulfilled(mutationThunk, queryThunk), isRejected(mutationThunk, queryThunk));
      let pendingTagInvalidations = [];
      const handler2 = (action, mwApi) => {
        if (isThunkActionWithTags(action)) {
          invalidateTags(calculateProvidedByThunk(action, "invalidatesTags", endpointDefinitions, assertTagType), mwApi);
        } else if (isQueryEnd(action)) {
          invalidateTags([], mwApi);
        } else if (api.util.invalidateTags.match(action)) {
          invalidateTags(calculateProvidedBy(action.payload, void 0, void 0, void 0, void 0, assertTagType), mwApi);
        }
      };
      function hasPendingRequests(state) {
        var _a;
        const {
          queries,
          mutations
        } = state;
        for (const cacheRecord of [queries, mutations]) {
          for (const key in cacheRecord) {
            if (((_a = cacheRecord[key]) == null ? void 0 : _a.status) === "pending") return true;
          }
        }
        return false;
      }
      function invalidateTags(newTags, mwApi) {
        const rootState = mwApi.getState();
        const state = rootState[reducerPath];
        pendingTagInvalidations.push(...newTags);
        if (state.config.invalidationBehavior === "delayed" && hasPendingRequests(state)) {
          return;
        }
        const tags = pendingTagInvalidations;
        pendingTagInvalidations = [];
        if (tags.length === 0) return;
        const toInvalidate = api.util.selectInvalidatedBy(rootState, tags);
        context.batch(() => {
          const valuesArray = Array.from(toInvalidate.values());
          for (const {
            queryCacheKey
          } of valuesArray) {
            const querySubState = state.queries[queryCacheKey];
            const subscriptionSubState = internalState.currentSubscriptions[queryCacheKey] ?? {};
            if (querySubState) {
              if (countObjectKeys(subscriptionSubState) === 0) {
                mwApi.dispatch(removeQueryResult({
                  queryCacheKey
                }));
              } else if (querySubState.status !== "uninitialized") {
                mwApi.dispatch(refetchQuery(querySubState));
              }
            }
          }
        });
      }
      return handler2;
    };
    var buildPollingHandler = ({
      reducerPath,
      queryThunk,
      api,
      refetchQuery,
      internalState
    }) => {
      const currentPolls = {};
      const handler2 = (action, mwApi) => {
        if (api.internalActions.updateSubscriptionOptions.match(action) || api.internalActions.unsubscribeQueryResult.match(action)) {
          updatePollingInterval(action.payload, mwApi);
        }
        if (queryThunk.pending.match(action) || queryThunk.rejected.match(action) && action.meta.condition) {
          updatePollingInterval(action.meta.arg, mwApi);
        }
        if (queryThunk.fulfilled.match(action) || queryThunk.rejected.match(action) && !action.meta.condition) {
          startNextPoll(action.meta.arg, mwApi);
        }
        if (api.util.resetApiState.match(action)) {
          clearPolls();
        }
      };
      function startNextPoll({
        queryCacheKey
      }, api2) {
        const state = api2.getState()[reducerPath];
        const querySubState = state.queries[queryCacheKey];
        const subscriptions = internalState.currentSubscriptions[queryCacheKey];
        if (!querySubState || querySubState.status === "uninitialized") return;
        const {
          lowestPollingInterval,
          skipPollingIfUnfocused
        } = findLowestPollingInterval(subscriptions);
        if (!Number.isFinite(lowestPollingInterval)) return;
        const currentPoll = currentPolls[queryCacheKey];
        if (currentPoll == null ? void 0 : currentPoll.timeout) {
          clearTimeout(currentPoll.timeout);
          currentPoll.timeout = void 0;
        }
        const nextPollTimestamp = Date.now() + lowestPollingInterval;
        currentPolls[queryCacheKey] = {
          nextPollTimestamp,
          pollingInterval: lowestPollingInterval,
          timeout: setTimeout(() => {
            if (state.config.focused || !skipPollingIfUnfocused) {
              api2.dispatch(refetchQuery(querySubState));
            }
            startNextPoll({
              queryCacheKey
            }, api2);
          }, lowestPollingInterval)
        };
      }
      function updatePollingInterval({
        queryCacheKey
      }, api2) {
        const state = api2.getState()[reducerPath];
        const querySubState = state.queries[queryCacheKey];
        const subscriptions = internalState.currentSubscriptions[queryCacheKey];
        if (!querySubState || querySubState.status === "uninitialized") {
          return;
        }
        const {
          lowestPollingInterval
        } = findLowestPollingInterval(subscriptions);
        if (!Number.isFinite(lowestPollingInterval)) {
          cleanupPollForKey(queryCacheKey);
          return;
        }
        const currentPoll = currentPolls[queryCacheKey];
        const nextPollTimestamp = Date.now() + lowestPollingInterval;
        if (!currentPoll || nextPollTimestamp < currentPoll.nextPollTimestamp) {
          startNextPoll({
            queryCacheKey
          }, api2);
        }
      }
      function cleanupPollForKey(key) {
        const existingPoll = currentPolls[key];
        if (existingPoll == null ? void 0 : existingPoll.timeout) {
          clearTimeout(existingPoll.timeout);
        }
        delete currentPolls[key];
      }
      function clearPolls() {
        for (const key of Object.keys(currentPolls)) {
          cleanupPollForKey(key);
        }
      }
      function findLowestPollingInterval(subscribers = {}) {
        let skipPollingIfUnfocused = false;
        let lowestPollingInterval = Number.POSITIVE_INFINITY;
        for (let key in subscribers) {
          if (!!subscribers[key].pollingInterval) {
            lowestPollingInterval = Math.min(subscribers[key].pollingInterval, lowestPollingInterval);
            skipPollingIfUnfocused = subscribers[key].skipPollingIfUnfocused || skipPollingIfUnfocused;
          }
        }
        return {
          lowestPollingInterval,
          skipPollingIfUnfocused
        };
      }
      return handler2;
    };
    var buildQueryLifecycleHandler = ({
      api,
      context,
      queryThunk,
      mutationThunk
    }) => {
      const isPendingThunk = isPending(queryThunk, mutationThunk);
      const isRejectedThunk = isRejected(queryThunk, mutationThunk);
      const isFullfilledThunk = isFulfilled(queryThunk, mutationThunk);
      const lifecycleMap = {};
      const handler2 = (action, mwApi) => {
        var _a, _b;
        if (isPendingThunk(action)) {
          const {
            requestId,
            arg: {
              endpointName,
              originalArgs
            }
          } = action.meta;
          const endpointDefinition = context.endpointDefinitions[endpointName];
          const onQueryStarted = endpointDefinition == null ? void 0 : endpointDefinition.onQueryStarted;
          if (onQueryStarted) {
            const lifecycle = {};
            const queryFulfilled = new Promise((resolve, reject) => {
              lifecycle.resolve = resolve;
              lifecycle.reject = reject;
            });
            queryFulfilled.catch(() => {
            });
            lifecycleMap[requestId] = lifecycle;
            const selector = api.endpoints[endpointName].select(isAnyQueryDefinition(endpointDefinition) ? originalArgs : requestId);
            const extra = mwApi.dispatch((_, __, extra2) => extra2);
            const lifecycleApi = {
              ...mwApi,
              getCacheEntry: () => selector(mwApi.getState()),
              requestId,
              extra,
              updateCachedData: isAnyQueryDefinition(endpointDefinition) ? (updateRecipe) => mwApi.dispatch(api.util.updateQueryData(endpointName, originalArgs, updateRecipe)) : void 0,
              queryFulfilled
            };
            onQueryStarted(originalArgs, lifecycleApi);
          }
        } else if (isFullfilledThunk(action)) {
          const {
            requestId,
            baseQueryMeta
          } = action.meta;
          (_a = lifecycleMap[requestId]) == null ? void 0 : _a.resolve({
            data: action.payload,
            meta: baseQueryMeta
          });
          delete lifecycleMap[requestId];
        } else if (isRejectedThunk(action)) {
          const {
            requestId,
            rejectedWithValue,
            baseQueryMeta
          } = action.meta;
          (_b = lifecycleMap[requestId]) == null ? void 0 : _b.reject({
            error: action.payload ?? action.error,
            isUnhandledError: !rejectedWithValue,
            meta: baseQueryMeta
          });
          delete lifecycleMap[requestId];
        }
      };
      return handler2;
    };
    var buildWindowEventHandler = ({
      reducerPath,
      context,
      api,
      refetchQuery,
      internalState
    }) => {
      const {
        removeQueryResult
      } = api.internalActions;
      const handler2 = (action, mwApi) => {
        if (onFocus.match(action)) {
          refetchValidQueries(mwApi, "refetchOnFocus");
        }
        if (onOnline.match(action)) {
          refetchValidQueries(mwApi, "refetchOnReconnect");
        }
      };
      function refetchValidQueries(api2, type) {
        const state = api2.getState()[reducerPath];
        const queries = state.queries;
        const subscriptions = internalState.currentSubscriptions;
        context.batch(() => {
          for (const queryCacheKey of Object.keys(subscriptions)) {
            const querySubState = queries[queryCacheKey];
            const subscriptionSubState = subscriptions[queryCacheKey];
            if (!subscriptionSubState || !querySubState) continue;
            const shouldRefetch = Object.values(subscriptionSubState).some((sub) => sub[type] === true) || Object.values(subscriptionSubState).every((sub) => sub[type] === void 0) && state.config[type];
            if (shouldRefetch) {
              if (countObjectKeys(subscriptionSubState) === 0) {
                api2.dispatch(removeQueryResult({
                  queryCacheKey
                }));
              } else if (querySubState.status !== "uninitialized") {
                api2.dispatch(refetchQuery(querySubState));
              }
            }
          }
        });
      }
      return handler2;
    };
    function buildMiddleware(input) {
      const {
        reducerPath,
        queryThunk,
        api,
        context
      } = input;
      const {
        apiUid
      } = context;
      const actions = {
        invalidateTags: createAction(`${reducerPath}/invalidateTags`)
      };
      const isThisApiSliceAction = (action) => action.type.startsWith(`${reducerPath}/`);
      const handlerBuilders = [buildDevCheckHandler, buildCacheCollectionHandler, buildInvalidationByTagsHandler, buildPollingHandler, buildCacheLifecycleHandler, buildQueryLifecycleHandler];
      const middleware = (mwApi) => {
        let initialized2 = false;
        const internalState = {
          currentSubscriptions: {}
        };
        const builderArgs = {
          ...input,
          internalState,
          refetchQuery,
          isThisApiSliceAction
        };
        const handlers = handlerBuilders.map((build) => build(builderArgs));
        const batchedActionsHandler = buildBatchedActionsHandler(builderArgs);
        const windowEventsHandler = buildWindowEventHandler(builderArgs);
        return (next) => {
          return (action) => {
            if (!isAction(action)) {
              return next(action);
            }
            if (!initialized2) {
              initialized2 = true;
              mwApi.dispatch(api.internalActions.middlewareRegistered(apiUid));
            }
            const mwApiWithNext = {
              ...mwApi,
              next
            };
            const stateBefore = mwApi.getState();
            const [actionShouldContinue, internalProbeResult] = batchedActionsHandler(action, mwApiWithNext, stateBefore);
            let res;
            if (actionShouldContinue) {
              res = next(action);
            } else {
              res = internalProbeResult;
            }
            if (!!mwApi.getState()[reducerPath]) {
              windowEventsHandler(action, mwApiWithNext, stateBefore);
              if (isThisApiSliceAction(action) || context.hasRehydrationInfo(action)) {
                for (const handler2 of handlers) {
                  handler2(action, mwApiWithNext, stateBefore);
                }
              }
            }
            return res;
          };
        };
      };
      return {
        middleware,
        actions
      };
      function refetchQuery(querySubState) {
        return input.api.endpoints[querySubState.endpointName].initiate(querySubState.originalArgs, {
          subscribe: false,
          forceRefetch: true
        });
      }
    }
    var coreModuleName = /* @__PURE__ */ Symbol();
    var coreModule = ({
      createSelector: createSelector2 = createSelector
    } = {}) => ({
      name: coreModuleName,
      init(api, {
        baseQuery,
        tagTypes,
        reducerPath,
        serializeQueryArgs,
        keepUnusedDataFor,
        refetchOnMountOrArgChange,
        refetchOnFocus,
        refetchOnReconnect,
        invalidationBehavior,
        onSchemaFailure,
        catchSchemaFailure,
        skipSchemaValidation
      }, context) {
        enablePatches();
        const assertTagType = (tag) => {
          return tag;
        };
        Object.assign(api, {
          reducerPath,
          endpoints: {},
          internalActions: {
            onOnline,
            onOffline,
            onFocus,
            onFocusLost
          },
          util: {}
        });
        const selectors = buildSelectors({
          serializeQueryArgs,
          reducerPath,
          createSelector: createSelector2
        });
        const {
          selectInvalidatedBy,
          selectCachedArgsForQuery,
          buildQuerySelector,
          buildInfiniteQuerySelector,
          buildMutationSelector
        } = selectors;
        safeAssign$1(api.util, {
          selectInvalidatedBy,
          selectCachedArgsForQuery
        });
        const {
          queryThunk,
          infiniteQueryThunk,
          mutationThunk,
          patchQueryData,
          updateQueryData,
          upsertQueryData,
          prefetch,
          buildMatchThunkActions
        } = buildThunks({
          baseQuery,
          reducerPath,
          context,
          api,
          serializeQueryArgs,
          assertTagType,
          selectors,
          onSchemaFailure,
          catchSchemaFailure,
          skipSchemaValidation
        });
        const {
          reducer,
          actions: sliceActions
        } = buildSlice({
          context,
          queryThunk,
          mutationThunk,
          serializeQueryArgs,
          reducerPath,
          assertTagType,
          config: {
            refetchOnFocus,
            refetchOnReconnect,
            refetchOnMountOrArgChange,
            keepUnusedDataFor,
            reducerPath,
            invalidationBehavior
          }
        });
        safeAssign$1(api.util, {
          patchQueryData,
          updateQueryData,
          upsertQueryData,
          prefetch,
          resetApiState: sliceActions.resetApiState,
          upsertQueryEntries: sliceActions.cacheEntriesUpserted
        });
        safeAssign$1(api.internalActions, sliceActions);
        const {
          middleware,
          actions: middlewareActions
        } = buildMiddleware({
          reducerPath,
          context,
          queryThunk,
          mutationThunk,
          infiniteQueryThunk,
          api,
          assertTagType,
          selectors
        });
        safeAssign$1(api.util, middlewareActions);
        safeAssign$1(api, {
          reducer,
          middleware
        });
        const {
          buildInitiateQuery,
          buildInitiateInfiniteQuery,
          buildInitiateMutation,
          getRunningMutationThunk,
          getRunningMutationsThunk,
          getRunningQueriesThunk,
          getRunningQueryThunk
        } = buildInitiate({
          queryThunk,
          mutationThunk,
          infiniteQueryThunk,
          api,
          serializeQueryArgs,
          context
        });
        safeAssign$1(api.util, {
          getRunningMutationThunk,
          getRunningMutationsThunk,
          getRunningQueryThunk,
          getRunningQueriesThunk
        });
        return {
          name: coreModuleName,
          injectEndpoint(endpointName, definition) {
            var _a;
            const anyApi = api;
            const endpoint = (_a = anyApi.endpoints)[endpointName] ?? (_a[endpointName] = {});
            if (isQueryDefinition$1(definition)) {
              safeAssign$1(endpoint, {
                name: endpointName,
                select: buildQuerySelector(endpointName, definition),
                initiate: buildInitiateQuery(endpointName, definition)
              }, buildMatchThunkActions(queryThunk, endpointName));
            }
            if (isMutationDefinition$1(definition)) {
              safeAssign$1(endpoint, {
                name: endpointName,
                select: buildMutationSelector(),
                initiate: buildInitiateMutation(endpointName)
              }, buildMatchThunkActions(mutationThunk, endpointName));
            }
            if (isInfiniteQueryDefinition$1(definition)) {
              safeAssign$1(endpoint, {
                name: endpointName,
                select: buildInfiniteQuerySelector(endpointName, definition),
                initiate: buildInitiateInfiniteQuery(endpointName, definition)
              }, buildMatchThunkActions(queryThunk, endpointName));
            }
          }
        };
      }
    });
    /* @__PURE__ */ buildCreateApi(coreModule());
    var withSelector = { exports: {} };
    var useSyncExternalStoreWithSelector_production = {};
    /**
     * @license React
     * use-sync-external-store-with-selector.production.js
     *
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var hasRequiredUseSyncExternalStoreWithSelector_production;
    function requireUseSyncExternalStoreWithSelector_production() {
      if (hasRequiredUseSyncExternalStoreWithSelector_production) return useSyncExternalStoreWithSelector_production;
      hasRequiredUseSyncExternalStoreWithSelector_production = 1;
      var React2 = requireReact();
      function is2(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
      }
      var objectIs = "function" === typeof Object.is ? Object.is : is2, useSyncExternalStore = React2.useSyncExternalStore, useRef = React2.useRef, useEffect = React2.useEffect, useMemo = React2.useMemo, useDebugValue = React2.useDebugValue;
      useSyncExternalStoreWithSelector_production.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual2) {
        var instRef = useRef(null);
        if (null === instRef.current) {
          var inst = { hasValue: false, value: null };
          instRef.current = inst;
        } else inst = instRef.current;
        instRef = useMemo(
          function() {
            function memoizedSelector(nextSnapshot) {
              if (!hasMemo) {
                hasMemo = true;
                memoizedSnapshot = nextSnapshot;
                nextSnapshot = selector(nextSnapshot);
                if (void 0 !== isEqual2 && inst.hasValue) {
                  var currentSelection = inst.value;
                  if (isEqual2(currentSelection, nextSnapshot))
                    return memoizedSelection = currentSelection;
                }
                return memoizedSelection = nextSnapshot;
              }
              currentSelection = memoizedSelection;
              if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
              var nextSelection = selector(nextSnapshot);
              if (void 0 !== isEqual2 && isEqual2(currentSelection, nextSelection))
                return memoizedSnapshot = nextSnapshot, currentSelection;
              memoizedSnapshot = nextSnapshot;
              return memoizedSelection = nextSelection;
            }
            var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
            return [
              function() {
                return memoizedSelector(getSnapshot());
              },
              null === maybeGetServerSnapshot ? void 0 : function() {
                return memoizedSelector(maybeGetServerSnapshot());
              }
            ];
          },
          [getSnapshot, getServerSnapshot, selector, isEqual2]
        );
        var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
        useEffect(
          function() {
            inst.hasValue = true;
            inst.value = value;
          },
          [value]
        );
        useDebugValue(value);
        return value;
      };
      return useSyncExternalStoreWithSelector_production;
    }
    var hasRequiredWithSelector;
    function requireWithSelector() {
      if (hasRequiredWithSelector) return withSelector.exports;
      hasRequiredWithSelector = 1;
      {
        withSelector.exports = requireUseSyncExternalStoreWithSelector_production();
      }
      return withSelector.exports;
    }
    var withSelectorExports = requireWithSelector();
    function defaultNoopBatch(callback) {
      callback();
    }
    function createListenerCollection() {
      let first = null;
      let last = null;
      return {
        clear() {
          first = null;
          last = null;
        },
        notify() {
          defaultNoopBatch(() => {
            let listener = first;
            while (listener) {
              listener.callback();
              listener = listener.next;
            }
          });
        },
        get() {
          const listeners = [];
          let listener = first;
          while (listener) {
            listeners.push(listener);
            listener = listener.next;
          }
          return listeners;
        },
        subscribe(callback) {
          let isSubscribed = true;
          const listener = last = {
            callback,
            next: null,
            prev: last
          };
          if (listener.prev) {
            listener.prev.next = listener;
          } else {
            first = listener;
          }
          return function unsubscribe() {
            if (!isSubscribed || first === null) return;
            isSubscribed = false;
            if (listener.next) {
              listener.next.prev = listener.prev;
            } else {
              last = listener.prev;
            }
            if (listener.prev) {
              listener.prev.next = listener.next;
            } else {
              first = listener.next;
            }
          };
        }
      };
    }
    var nullListeners = {
      notify() {
      },
      get: () => []
    };
    function createSubscription(store2, parentSub) {
      let unsubscribe;
      let listeners = nullListeners;
      let subscriptionsAmount = 0;
      let selfSubscribed = false;
      function addNestedSub(listener) {
        trySubscribe();
        const cleanupListener = listeners.subscribe(listener);
        let removed = false;
        return () => {
          if (!removed) {
            removed = true;
            cleanupListener();
            tryUnsubscribe();
          }
        };
      }
      function notifyNestedSubs() {
        listeners.notify();
      }
      function handleChangeWrapper() {
        if (subscription.onStateChange) {
          subscription.onStateChange();
        }
      }
      function isSubscribed() {
        return selfSubscribed;
      }
      function trySubscribe() {
        subscriptionsAmount++;
        if (!unsubscribe) {
          unsubscribe = store2.subscribe(handleChangeWrapper);
          listeners = createListenerCollection();
        }
      }
      function tryUnsubscribe() {
        subscriptionsAmount--;
        if (unsubscribe && subscriptionsAmount === 0) {
          unsubscribe();
          unsubscribe = void 0;
          listeners.clear();
          listeners = nullListeners;
        }
      }
      function trySubscribeSelf() {
        if (!selfSubscribed) {
          selfSubscribed = true;
          trySubscribe();
        }
      }
      function tryUnsubscribeSelf() {
        if (selfSubscribed) {
          selfSubscribed = false;
          tryUnsubscribe();
        }
      }
      const subscription = {
        addNestedSub,
        notifyNestedSubs,
        handleChangeWrapper,
        isSubscribed,
        trySubscribe: trySubscribeSelf,
        tryUnsubscribe: tryUnsubscribeSelf,
        getListeners: () => listeners
      };
      return subscription;
    }
    var canUseDOM$1 = () => !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
    var isDOM$1 = /* @__PURE__ */ canUseDOM$1();
    var isRunningInReactNative$1 = () => typeof navigator !== "undefined" && navigator.product === "ReactNative";
    var isReactNative$1 = /* @__PURE__ */ isRunningInReactNative$1();
    var getUseIsomorphicLayoutEffect$1 = () => isDOM$1 || isReactNative$1 ? reactExports.useLayoutEffect : reactExports.useEffect;
    var useIsomorphicLayoutEffect$1 = /* @__PURE__ */ getUseIsomorphicLayoutEffect$1();
    function is(x, y) {
      if (x === y) {
        return x !== 0 || y !== 0 || 1 / x === 1 / y;
      } else {
        return x !== x && y !== y;
      }
    }
    function shallowEqual(objA, objB) {
      if (is(objA, objB)) return true;
      if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
        return false;
      }
      const keysA = Object.keys(objA);
      const keysB = Object.keys(objB);
      if (keysA.length !== keysB.length) return false;
      for (let i = 0; i < keysA.length; i++) {
        if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
          return false;
        }
      }
      return true;
    }
    var ContextKey = /* @__PURE__ */ Symbol.for(`react-redux-context`);
    var gT = typeof globalThis !== "undefined" ? globalThis : (
      /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */
      {}
    );
    function getContext() {
      if (!reactExports.createContext) return {};
      const contextMap = gT[ContextKey] ?? (gT[ContextKey] = /* @__PURE__ */ new Map());
      let realContext = contextMap.get(reactExports.createContext);
      if (!realContext) {
        realContext = reactExports.createContext(
          null
        );
        contextMap.set(reactExports.createContext, realContext);
      }
      return realContext;
    }
    var ReactReduxContext = /* @__PURE__ */ getContext();
    function Provider(providerProps) {
      const { children, context, serverState, store: store2 } = providerProps;
      const contextValue = reactExports.useMemo(() => {
        const subscription = createSubscription(store2);
        const baseContextValue = {
          store: store2,
          subscription,
          getServerState: serverState ? () => serverState : void 0
        };
        {
          return baseContextValue;
        }
      }, [store2, serverState]);
      const previousState = reactExports.useMemo(() => store2.getState(), [store2]);
      useIsomorphicLayoutEffect$1(() => {
        const { subscription } = contextValue;
        subscription.onStateChange = subscription.notifyNestedSubs;
        subscription.trySubscribe();
        if (previousState !== store2.getState()) {
          subscription.notifyNestedSubs();
        }
        return () => {
          subscription.tryUnsubscribe();
          subscription.onStateChange = void 0;
        };
      }, [contextValue, previousState]);
      const Context = context || ReactReduxContext;
      return /* @__PURE__ */ reactExports.createElement(Context.Provider, { value: contextValue }, children);
    }
    var Provider_default = Provider;
    function createReduxContextHook(context = ReactReduxContext) {
      return function useReduxContext2() {
        const contextValue = reactExports.useContext(context);
        return contextValue;
      };
    }
    var useReduxContext = /* @__PURE__ */ createReduxContextHook();
    function createStoreHook(context = ReactReduxContext) {
      const useReduxContext2 = context === ReactReduxContext ? useReduxContext : (
        // @ts-ignore
        createReduxContextHook(context)
      );
      const useStore2 = () => {
        const { store: store2 } = useReduxContext2();
        return store2;
      };
      Object.assign(useStore2, {
        withTypes: () => useStore2
      });
      return useStore2;
    }
    var useStore = /* @__PURE__ */ createStoreHook();
    function createDispatchHook(context = ReactReduxContext) {
      const useStore2 = context === ReactReduxContext ? useStore : createStoreHook(context);
      const useDispatch2 = () => {
        const store2 = useStore2();
        return store2.dispatch;
      };
      Object.assign(useDispatch2, {
        withTypes: () => useDispatch2
      });
      return useDispatch2;
    }
    var useDispatch = /* @__PURE__ */ createDispatchHook();
    var refEquality = (a, b) => a === b;
    function createSelectorHook(context = ReactReduxContext) {
      const useReduxContext2 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);
      const useSelector2 = (selector, equalityFnOrOptions = {}) => {
        const { equalityFn = refEquality } = typeof equalityFnOrOptions === "function" ? { equalityFn: equalityFnOrOptions } : equalityFnOrOptions;
        const reduxContext = useReduxContext2();
        const { store: store2, subscription, getServerState } = reduxContext;
        reactExports.useRef(true);
        const wrappedSelector = reactExports.useCallback(
          {
            [selector.name](state) {
              const selected = selector(state);
              return selected;
            }
          }[selector.name],
          [selector]
        );
        const selectedState = withSelectorExports.useSyncExternalStoreWithSelector(
          subscription.addNestedSub,
          store2.getState,
          getServerState || store2.getState,
          wrappedSelector,
          equalityFn
        );
        reactExports.useDebugValue(selectedState);
        return selectedState;
      };
      Object.assign(useSelector2, {
        withTypes: () => useSelector2
      });
      return useSelector2;
    }
    var useSelector = /* @__PURE__ */ createSelectorHook();
    var batch = defaultNoopBatch;
    function capitalize(str) {
      return str.replace(str[0], str[0].toUpperCase());
    }
    function isQueryDefinition(e) {
      return e.type === "query";
    }
    function isMutationDefinition(e) {
      return e.type === "mutation";
    }
    function isInfiniteQueryDefinition(e) {
      return e.type === "infinitequery";
    }
    function safeAssign(target, ...args) {
      return Object.assign(target, ...args);
    }
    var UNINITIALIZED_VALUE = Symbol();
    function useStableQueryArgs(queryArgs, serialize, endpointDefinition, endpointName) {
      const incoming = reactExports.useMemo(() => ({
        queryArgs,
        serialized: typeof queryArgs == "object" ? serialize({
          queryArgs,
          endpointDefinition,
          endpointName
        }) : queryArgs
      }), [queryArgs, serialize, endpointDefinition, endpointName]);
      const cache2 = reactExports.useRef(incoming);
      reactExports.useEffect(() => {
        if (cache2.current.serialized !== incoming.serialized) {
          cache2.current = incoming;
        }
      }, [incoming]);
      return cache2.current.serialized === incoming.serialized ? cache2.current.queryArgs : queryArgs;
    }
    function useShallowStableValue(value) {
      const cache2 = reactExports.useRef(value);
      reactExports.useEffect(() => {
        if (!shallowEqual(cache2.current, value)) {
          cache2.current = value;
        }
      }, [value]);
      return shallowEqual(cache2.current, value) ? cache2.current : value;
    }
    var canUseDOM = () => !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
    var isDOM = /* @__PURE__ */ canUseDOM();
    var isRunningInReactNative = () => typeof navigator !== "undefined" && navigator.product === "ReactNative";
    var isReactNative = /* @__PURE__ */ isRunningInReactNative();
    var getUseIsomorphicLayoutEffect = () => isDOM || isReactNative ? reactExports.useLayoutEffect : reactExports.useEffect;
    var useIsomorphicLayoutEffect = /* @__PURE__ */ getUseIsomorphicLayoutEffect();
    var noPendingQueryStateSelector = (selected) => {
      if (selected.isUninitialized) {
        return {
          ...selected,
          isUninitialized: false,
          isFetching: true,
          isLoading: selected.data !== void 0 ? false : true,
          status: QueryStatus.pending
        };
      }
      return selected;
    };
    function pick(obj, ...keys2) {
      const ret = {};
      keys2.forEach((key) => {
        ret[key] = obj[key];
      });
      return ret;
    }
    var COMMON_HOOK_DEBUG_FIELDS = ["data", "status", "isLoading", "isSuccess", "isError", "error"];
    function buildHooks({
      api,
      moduleOptions: {
        batch: batch2,
        hooks: {
          useDispatch: useDispatch2,
          useSelector: useSelector2,
          useStore: useStore2
        },
        unstable__sideEffectsInRender,
        createSelector: createSelector2
      },
      serializeQueryArgs,
      context
    }) {
      const usePossiblyImmediateEffect = unstable__sideEffectsInRender ? (cb) => cb() : reactExports.useEffect;
      return {
        buildQueryHooks,
        buildInfiniteQueryHooks,
        buildMutationHook,
        usePrefetch
      };
      function queryStatePreSelector(currentState, lastResult, queryArgs) {
        if ((lastResult == null ? void 0 : lastResult.endpointName) && currentState.isUninitialized) {
          const {
            endpointName
          } = lastResult;
          const endpointDefinition = context.endpointDefinitions[endpointName];
          if (queryArgs !== skipToken && serializeQueryArgs({
            queryArgs: lastResult.originalArgs,
            endpointDefinition,
            endpointName
          }) === serializeQueryArgs({
            queryArgs,
            endpointDefinition,
            endpointName
          })) lastResult = void 0;
        }
        let data = currentState.isSuccess ? currentState.data : lastResult == null ? void 0 : lastResult.data;
        if (data === void 0) data = currentState.data;
        const hasData = data !== void 0;
        const isFetching = currentState.isLoading;
        const isLoading = (!lastResult || lastResult.isLoading || lastResult.isUninitialized) && !hasData && isFetching;
        const isSuccess = currentState.isSuccess || hasData && (isFetching && !(lastResult == null ? void 0 : lastResult.isError) || currentState.isUninitialized);
        return {
          ...currentState,
          data,
          currentData: currentState.data,
          isFetching,
          isLoading,
          isSuccess
        };
      }
      function infiniteQueryStatePreSelector(currentState, lastResult, queryArgs) {
        if ((lastResult == null ? void 0 : lastResult.endpointName) && currentState.isUninitialized) {
          const {
            endpointName
          } = lastResult;
          const endpointDefinition = context.endpointDefinitions[endpointName];
          if (queryArgs !== skipToken && serializeQueryArgs({
            queryArgs: lastResult.originalArgs,
            endpointDefinition,
            endpointName
          }) === serializeQueryArgs({
            queryArgs,
            endpointDefinition,
            endpointName
          })) lastResult = void 0;
        }
        let data = currentState.isSuccess ? currentState.data : lastResult == null ? void 0 : lastResult.data;
        if (data === void 0) data = currentState.data;
        const hasData = data !== void 0;
        const isFetching = currentState.isLoading;
        const isLoading = (!lastResult || lastResult.isLoading || lastResult.isUninitialized) && !hasData && isFetching;
        const isSuccess = currentState.isSuccess || isFetching && hasData;
        return {
          ...currentState,
          data,
          currentData: currentState.data,
          isFetching,
          isLoading,
          isSuccess
        };
      }
      function usePrefetch(endpointName, defaultOptions) {
        const dispatch = useDispatch2();
        const stableDefaultOptions = useShallowStableValue(defaultOptions);
        return reactExports.useCallback((arg, options) => dispatch(api.util.prefetch(endpointName, arg, {
          ...stableDefaultOptions,
          ...options
        })), [endpointName, dispatch, stableDefaultOptions]);
      }
      function useQuerySubscriptionCommonImpl(endpointName, arg, {
        refetchOnReconnect,
        refetchOnFocus,
        refetchOnMountOrArgChange,
        skip = false,
        pollingInterval = 0,
        skipPollingIfUnfocused = false,
        ...rest
      } = {}) {
        const {
          initiate
        } = api.endpoints[endpointName];
        const dispatch = useDispatch2();
        const subscriptionSelectorsRef = reactExports.useRef(void 0);
        if (!subscriptionSelectorsRef.current) {
          const returnedValue = dispatch(api.internalActions.internal_getRTKQSubscriptions());
          subscriptionSelectorsRef.current = returnedValue;
        }
        const stableArg = useStableQueryArgs(
          skip ? skipToken : arg,
          // Even if the user provided a per-endpoint `serializeQueryArgs` with
          // a consistent return value, _here_ we want to use the default behavior
          // so we can tell if _anything_ actually changed. Otherwise, we can end up
          // with a case where the query args did change but the serialization doesn't,
          // and then we never try to initiate a refetch.
          defaultSerializeQueryArgs,
          context.endpointDefinitions[endpointName],
          endpointName
        );
        const stableSubscriptionOptions = useShallowStableValue({
          refetchOnReconnect,
          refetchOnFocus,
          pollingInterval,
          skipPollingIfUnfocused
        });
        const initialPageParam = rest.initialPageParam;
        const stableInitialPageParam = useShallowStableValue(initialPageParam);
        const promiseRef = reactExports.useRef(void 0);
        let {
          queryCacheKey,
          requestId
        } = promiseRef.current || {};
        let currentRenderHasSubscription = false;
        if (queryCacheKey && requestId) {
          currentRenderHasSubscription = subscriptionSelectorsRef.current.isRequestSubscribed(queryCacheKey, requestId);
        }
        const subscriptionRemoved = !currentRenderHasSubscription && promiseRef.current !== void 0;
        usePossiblyImmediateEffect(() => {
          if (subscriptionRemoved) {
            promiseRef.current = void 0;
          }
        }, [subscriptionRemoved]);
        usePossiblyImmediateEffect(() => {
          var _a;
          const lastPromise = promiseRef.current;
          if (stableArg === skipToken) {
            lastPromise == null ? void 0 : lastPromise.unsubscribe();
            promiseRef.current = void 0;
            return;
          }
          const lastSubscriptionOptions = (_a = promiseRef.current) == null ? void 0 : _a.subscriptionOptions;
          if (!lastPromise || lastPromise.arg !== stableArg) {
            lastPromise == null ? void 0 : lastPromise.unsubscribe();
            const promise = dispatch(initiate(stableArg, {
              subscriptionOptions: stableSubscriptionOptions,
              forceRefetch: refetchOnMountOrArgChange,
              ...isInfiniteQueryDefinition(context.endpointDefinitions[endpointName]) ? {
                initialPageParam: stableInitialPageParam
              } : {}
            }));
            promiseRef.current = promise;
          } else if (stableSubscriptionOptions !== lastSubscriptionOptions) {
            lastPromise.updateSubscriptionOptions(stableSubscriptionOptions);
          }
        }, [dispatch, initiate, refetchOnMountOrArgChange, stableArg, stableSubscriptionOptions, subscriptionRemoved, stableInitialPageParam, endpointName]);
        return [promiseRef, dispatch, initiate, stableSubscriptionOptions];
      }
      function buildUseQueryState(endpointName, preSelector) {
        const useQueryState = (arg, {
          skip = false,
          selectFromResult
        } = {}) => {
          const {
            select
          } = api.endpoints[endpointName];
          const stableArg = useStableQueryArgs(skip ? skipToken : arg, serializeQueryArgs, context.endpointDefinitions[endpointName], endpointName);
          const lastValue = reactExports.useRef(void 0);
          const selectDefaultResult = reactExports.useMemo(() => (
            // Normally ts-ignores are bad and should be avoided, but we're
            // already casting this selector to be `Selector<any>` anyway,
            // so the inconsistencies don't matter here
            // @ts-ignore
            createSelector2([
              // @ts-ignore
              select(stableArg),
              (_, lastResult) => lastResult,
              (_) => stableArg
            ], preSelector, {
              memoizeOptions: {
                resultEqualityCheck: shallowEqual
              }
            })
          ), [select, stableArg]);
          const querySelector = reactExports.useMemo(() => selectFromResult ? createSelector2([selectDefaultResult], selectFromResult, {
            devModeChecks: {
              identityFunctionCheck: "never"
            }
          }) : selectDefaultResult, [selectDefaultResult, selectFromResult]);
          const currentState = useSelector2((state) => querySelector(state, lastValue.current), shallowEqual);
          const store2 = useStore2();
          const newLastValue = selectDefaultResult(store2.getState(), lastValue.current);
          useIsomorphicLayoutEffect(() => {
            lastValue.current = newLastValue;
          }, [newLastValue]);
          return currentState;
        };
        return useQueryState;
      }
      function usePromiseRefUnsubscribeOnUnmount(promiseRef) {
        reactExports.useEffect(() => {
          return () => {
            var _a, _b;
            (_b = (_a = promiseRef.current) == null ? void 0 : _a.unsubscribe) == null ? void 0 : _b.call(_a);
            promiseRef.current = void 0;
          };
        }, [promiseRef]);
      }
      function refetchOrErrorIfUnmounted(promiseRef) {
        if (!promiseRef.current) throw new Error(formatProdErrorMessage(38));
        return promiseRef.current.refetch();
      }
      function buildQueryHooks(endpointName) {
        const useQuerySubscription = (arg, options = {}) => {
          const [promiseRef] = useQuerySubscriptionCommonImpl(endpointName, arg, options);
          usePromiseRefUnsubscribeOnUnmount(promiseRef);
          return reactExports.useMemo(() => ({
            /**
             * A method to manually refetch data for the query
             */
            refetch: () => refetchOrErrorIfUnmounted(promiseRef)
          }), [promiseRef]);
        };
        const useLazyQuerySubscription = ({
          refetchOnReconnect,
          refetchOnFocus,
          pollingInterval = 0,
          skipPollingIfUnfocused = false
        } = {}) => {
          const {
            initiate
          } = api.endpoints[endpointName];
          const dispatch = useDispatch2();
          const [arg, setArg] = reactExports.useState(UNINITIALIZED_VALUE);
          const promiseRef = reactExports.useRef(void 0);
          const stableSubscriptionOptions = useShallowStableValue({
            refetchOnReconnect,
            refetchOnFocus,
            pollingInterval,
            skipPollingIfUnfocused
          });
          usePossiblyImmediateEffect(() => {
            var _a, _b;
            const lastSubscriptionOptions = (_a = promiseRef.current) == null ? void 0 : _a.subscriptionOptions;
            if (stableSubscriptionOptions !== lastSubscriptionOptions) {
              (_b = promiseRef.current) == null ? void 0 : _b.updateSubscriptionOptions(stableSubscriptionOptions);
            }
          }, [stableSubscriptionOptions]);
          const subscriptionOptionsRef = reactExports.useRef(stableSubscriptionOptions);
          usePossiblyImmediateEffect(() => {
            subscriptionOptionsRef.current = stableSubscriptionOptions;
          }, [stableSubscriptionOptions]);
          const trigger = reactExports.useCallback(function(arg2, preferCacheValue = false) {
            let promise;
            batch2(() => {
              var _a;
              (_a = promiseRef.current) == null ? void 0 : _a.unsubscribe();
              promiseRef.current = promise = dispatch(initiate(arg2, {
                subscriptionOptions: subscriptionOptionsRef.current,
                forceRefetch: !preferCacheValue
              }));
              setArg(arg2);
            });
            return promise;
          }, [dispatch, initiate]);
          const reset = reactExports.useCallback(() => {
            var _a, _b;
            if ((_a = promiseRef.current) == null ? void 0 : _a.queryCacheKey) {
              dispatch(api.internalActions.removeQueryResult({
                queryCacheKey: (_b = promiseRef.current) == null ? void 0 : _b.queryCacheKey
              }));
            }
          }, [dispatch]);
          reactExports.useEffect(() => {
            return () => {
              var _a;
              (_a = promiseRef == null ? void 0 : promiseRef.current) == null ? void 0 : _a.unsubscribe();
            };
          }, []);
          reactExports.useEffect(() => {
            if (arg !== UNINITIALIZED_VALUE && !promiseRef.current) {
              trigger(arg, true);
            }
          }, [arg, trigger]);
          return reactExports.useMemo(() => [trigger, arg, {
            reset
          }], [trigger, arg, reset]);
        };
        const useQueryState = buildUseQueryState(endpointName, queryStatePreSelector);
        return {
          useQueryState,
          useQuerySubscription,
          useLazyQuerySubscription,
          useLazyQuery(options) {
            const [trigger, arg, {
              reset
            }] = useLazyQuerySubscription(options);
            const queryStateResults = useQueryState(arg, {
              ...options,
              skip: arg === UNINITIALIZED_VALUE
            });
            const info = reactExports.useMemo(() => ({
              lastArg: arg
            }), [arg]);
            return reactExports.useMemo(() => [trigger, {
              ...queryStateResults,
              reset
            }, info], [trigger, queryStateResults, reset, info]);
          },
          useQuery(arg, options) {
            const querySubscriptionResults = useQuerySubscription(arg, options);
            const queryStateResults = useQueryState(arg, {
              selectFromResult: arg === skipToken || (options == null ? void 0 : options.skip) ? void 0 : noPendingQueryStateSelector,
              ...options
            });
            const debugValue = pick(queryStateResults, ...COMMON_HOOK_DEBUG_FIELDS);
            reactExports.useDebugValue(debugValue);
            return reactExports.useMemo(() => ({
              ...queryStateResults,
              ...querySubscriptionResults
            }), [queryStateResults, querySubscriptionResults]);
          }
        };
      }
      function buildInfiniteQueryHooks(endpointName) {
        const useInfiniteQuerySubscription = (arg, options = {}) => {
          const [promiseRef, dispatch, initiate, stableSubscriptionOptions] = useQuerySubscriptionCommonImpl(endpointName, arg, options);
          const subscriptionOptionsRef = reactExports.useRef(stableSubscriptionOptions);
          usePossiblyImmediateEffect(() => {
            subscriptionOptionsRef.current = stableSubscriptionOptions;
          }, [stableSubscriptionOptions]);
          const trigger = reactExports.useCallback(function(arg2, direction) {
            let promise;
            batch2(() => {
              var _a;
              (_a = promiseRef.current) == null ? void 0 : _a.unsubscribe();
              promiseRef.current = promise = dispatch(initiate(arg2, {
                subscriptionOptions: subscriptionOptionsRef.current,
                direction
              }));
            });
            return promise;
          }, [promiseRef, dispatch, initiate]);
          usePromiseRefUnsubscribeOnUnmount(promiseRef);
          const stableArg = useStableQueryArgs(
            options.skip ? skipToken : arg,
            // Even if the user provided a per-endpoint `serializeQueryArgs` with
            // a consistent return value, _here_ we want to use the default behavior
            // so we can tell if _anything_ actually changed. Otherwise, we can end up
            // with a case where the query args did change but the serialization doesn't,
            // and then we never try to initiate a refetch.
            defaultSerializeQueryArgs,
            context.endpointDefinitions[endpointName],
            endpointName
          );
          const refetch = reactExports.useCallback(() => refetchOrErrorIfUnmounted(promiseRef), [promiseRef]);
          return reactExports.useMemo(() => {
            const fetchNextPage = () => {
              return trigger(stableArg, "forward");
            };
            const fetchPreviousPage = () => {
              return trigger(stableArg, "backward");
            };
            return {
              trigger,
              /**
               * A method to manually refetch data for the query
               */
              refetch,
              fetchNextPage,
              fetchPreviousPage
            };
          }, [refetch, trigger, stableArg]);
        };
        const useInfiniteQueryState = buildUseQueryState(endpointName, infiniteQueryStatePreSelector);
        return {
          useInfiniteQueryState,
          useInfiniteQuerySubscription,
          useInfiniteQuery(arg, options) {
            const {
              refetch,
              fetchNextPage,
              fetchPreviousPage
            } = useInfiniteQuerySubscription(arg, options);
            const queryStateResults = useInfiniteQueryState(arg, {
              selectFromResult: arg === skipToken || (options == null ? void 0 : options.skip) ? void 0 : noPendingQueryStateSelector,
              ...options
            });
            const debugValue = pick(queryStateResults, ...COMMON_HOOK_DEBUG_FIELDS, "hasNextPage", "hasPreviousPage");
            reactExports.useDebugValue(debugValue);
            return reactExports.useMemo(() => ({
              ...queryStateResults,
              fetchNextPage,
              fetchPreviousPage,
              refetch
            }), [queryStateResults, fetchNextPage, fetchPreviousPage, refetch]);
          }
        };
      }
      function buildMutationHook(name) {
        return ({
          selectFromResult,
          fixedCacheKey
        } = {}) => {
          const {
            select,
            initiate
          } = api.endpoints[name];
          const dispatch = useDispatch2();
          const [promise, setPromise] = reactExports.useState();
          reactExports.useEffect(() => () => {
            if (!(promise == null ? void 0 : promise.arg.fixedCacheKey)) {
              promise == null ? void 0 : promise.reset();
            }
          }, [promise]);
          const triggerMutation = reactExports.useCallback(function(arg) {
            const promise2 = dispatch(initiate(arg, {
              fixedCacheKey
            }));
            setPromise(promise2);
            return promise2;
          }, [dispatch, initiate, fixedCacheKey]);
          const {
            requestId
          } = promise || {};
          const selectDefaultResult = reactExports.useMemo(() => select({
            fixedCacheKey,
            requestId: promise == null ? void 0 : promise.requestId
          }), [fixedCacheKey, promise, select]);
          const mutationSelector = reactExports.useMemo(() => selectFromResult ? createSelector2([selectDefaultResult], selectFromResult) : selectDefaultResult, [selectFromResult, selectDefaultResult]);
          const currentState = useSelector2(mutationSelector, shallowEqual);
          const originalArgs = fixedCacheKey == null ? promise == null ? void 0 : promise.arg.originalArgs : void 0;
          const reset = reactExports.useCallback(() => {
            batch2(() => {
              if (promise) {
                setPromise(void 0);
              }
              if (fixedCacheKey) {
                dispatch(api.internalActions.removeMutationResult({
                  requestId,
                  fixedCacheKey
                }));
              }
            });
          }, [dispatch, fixedCacheKey, promise, requestId]);
          const debugValue = pick(currentState, ...COMMON_HOOK_DEBUG_FIELDS, "endpointName");
          reactExports.useDebugValue(debugValue);
          const finalState = reactExports.useMemo(() => ({
            ...currentState,
            originalArgs,
            reset
          }), [currentState, originalArgs, reset]);
          return reactExports.useMemo(() => [triggerMutation, finalState], [triggerMutation, finalState]);
        };
      }
    }
    var reactHooksModuleName = /* @__PURE__ */ Symbol();
    var reactHooksModule = ({
      batch: batch$1 = batch,
      hooks = {
        useDispatch,
        useSelector,
        useStore
      },
      createSelector: createSelector$1 = createSelector,
      unstable__sideEffectsInRender = false,
      ...rest
    } = {}) => {
      return {
        name: reactHooksModuleName,
        init(api, {
          serializeQueryArgs
        }, context) {
          const anyApi = api;
          const {
            buildQueryHooks,
            buildInfiniteQueryHooks,
            buildMutationHook,
            usePrefetch
          } = buildHooks({
            api,
            moduleOptions: {
              batch: batch$1,
              hooks,
              unstable__sideEffectsInRender,
              createSelector: createSelector$1
            },
            serializeQueryArgs,
            context
          });
          safeAssign(anyApi, {
            usePrefetch
          });
          safeAssign(context, {
            batch: batch$1
          });
          return {
            injectEndpoint(endpointName, definition) {
              if (isQueryDefinition(definition)) {
                const {
                  useQuery,
                  useLazyQuery,
                  useLazyQuerySubscription,
                  useQueryState,
                  useQuerySubscription
                } = buildQueryHooks(endpointName);
                safeAssign(anyApi.endpoints[endpointName], {
                  useQuery,
                  useLazyQuery,
                  useLazyQuerySubscription,
                  useQueryState,
                  useQuerySubscription
                });
                api[`use${capitalize(endpointName)}Query`] = useQuery;
                api[`useLazy${capitalize(endpointName)}Query`] = useLazyQuery;
              }
              if (isMutationDefinition(definition)) {
                const useMutation = buildMutationHook(endpointName);
                safeAssign(anyApi.endpoints[endpointName], {
                  useMutation
                });
                api[`use${capitalize(endpointName)}Mutation`] = useMutation;
              } else if (isInfiniteQueryDefinition(definition)) {
                const {
                  useInfiniteQuery,
                  useInfiniteQuerySubscription,
                  useInfiniteQueryState
                } = buildInfiniteQueryHooks(endpointName);
                safeAssign(anyApi.endpoints[endpointName], {
                  useInfiniteQuery,
                  useInfiniteQuerySubscription,
                  useInfiniteQueryState
                });
                api[`use${capitalize(endpointName)}InfiniteQuery`] = useInfiniteQuery;
              }
            }
          };
        }
      };
    };
    var createApi = /* @__PURE__ */ buildCreateApi(coreModule(), reactHooksModule());
    const _0xd877ee = _0x471e;
    (function(_0x39c085, _0x30afa7) {
      const _0x30faa5 = _0x471e, _0x180468 = _0x39c085();
      while (!![]) {
        try {
          const _0x52e0a2 = parseInt(_0x30faa5(186)) / 1 * (parseInt(_0x30faa5(191)) / 2) + parseInt(_0x30faa5(187)) / 3 * (parseInt(_0x30faa5(185)) / 4) + parseInt(_0x30faa5(194)) / 5 + -parseInt(_0x30faa5(192)) / 6 * (-parseInt(_0x30faa5(183)) / 7) + parseInt(_0x30faa5(182)) / 8 * (parseInt(_0x30faa5(190)) / 9) + -parseInt(_0x30faa5(193)) / 10 + parseInt(_0x30faa5(195)) / 11 * (-parseInt(_0x30faa5(189)) / 12);
          if (_0x52e0a2 === _0x30afa7) break;
          else _0x180468["push"](_0x180468["shift"]());
        } catch (_0x29dd5c) {
          _0x180468["push"](_0x180468["shift"]());
        }
      }
    })(_0x3340, 838267);
    function _0x471e(_0x2dfd6b, _0x284cbb) {
      const _0x334094 = _0x3340();
      return _0x471e = function(_0x471e91, _0x1ccb25) {
        _0x471e91 = _0x471e91 - 181;
        let _0xc0a007 = _0x334094[_0x471e91];
        return _0xc0a007;
      }, _0x471e(_0x2dfd6b, _0x284cbb);
    }
    function _0x3340() {
      const _0x1e0e82 = ["12893589wGSdch", "4svPnVX", "1866Eoohva", "11867790JScJcI", "7107605uHtSyN", "11dFKlcd", "/api/users", "https://portfolio-api-tau-liard.vercel.app/", "8YKxPaH", "16107VrvhYY", "mutation", "8WiPxQZ", "750542ywMxYW", "1622121ufzUCU", "POST", "49526460mgXOjq"];
      _0x3340 = function() {
        return _0x1e0e82;
      };
      return _0x3340();
    }
    const apiSlice = createApi({ "reducerPath": "api", "baseQuery": fetchBaseQuery({ "baseUrl": _0xd877ee(181) }), "endpoints": (_0xfff86f) => ({ "createContact": _0xfff86f[_0xd877ee(184)]({ "query": (_0x37d504) => ({ "url": _0xd877ee(196), "method": _0xd877ee(188), "body": _0x37d504 }) }) }) });
    const { useCreateContactMutation } = apiSlice;
    const ContactForm = () => {
      const [createPost, { isLoading, isSuccess, error }] = useCreateContactMutation();
      const [showForm, setShowForm] = reactExports.useState(true);
      const formik = useFormik({
        initialValues,
        validationSchema,
        onSubmit: async (values, { resetForm }) => {
          try {
            await createPost(values).unwrap();
            resetForm();
          } catch (err) {
            console.error("Error submitting form:", err);
          }
        }
      });
      const getPlaceholder = (name, defaultText) => {
        return formik.touched[name] && formik.errors[name] ? formik.errors[name] : defaultText;
      };
      reactExports.useEffect(() => {
        if (isSuccess) {
          setShowForm(false);
          const timer = setTimeout(() => {
            setShowForm(true);
          }, 5e3);
          return () => clearTimeout(timer);
        }
      }, [isSuccess]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "contact-form-content", children: showForm ? /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: formik.handleSubmit, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "name-container", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              name: "firstname",
              placeholder: getPlaceholder("firstname", "First Name *"),
              ...formik.getFieldProps("firstname"),
              className: formik.touched.firstname && formik.errors.firstname ? "error-border" : ""
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              name: "lastname",
              placeholder: getPlaceholder("lastname", "Last Name"),
              ...formik.getFieldProps("lastname"),
              className: formik.touched.lastname && formik.errors.lastname ? "error-border" : ""
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            name: "email",
            placeholder: getPlaceholder("email", "Email *"),
            ...formik.getFieldProps("email"),
            className: formik.touched.email && formik.errors.email ? "error-border" : ""
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            name: "mobile",
            placeholder: getPlaceholder("mobile", "Mobile Number *"),
            ...formik.getFieldProps("mobile"),
            className: formik.touched.mobile && formik.errors.mobile ? "error-border" : ""
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "textarea",
          {
            name: "description",
            rows: 3,
            placeholder: getPlaceholder("description", "Message *"),
            ...formik.getFieldProps("description"),
            className: formik.touched.description && formik.errors.description ? "error-border" : ""
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "submit", disabled: isLoading, children: isLoading ? "Sending" : "Send" })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-6xl", children: " Thank you! Your message has been sent." }) }) });
    };
    const ContactMe = () => {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "contact-container", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { children: "Contact Me" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contact-content", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "mailto:roushanbhadani0209@gmail.com", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              ContactInfoCard,
              {
                iconUrl: "./assets/images/mail.png",
                text: "roushanbhadani0209@gmail.com"
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "https://github.com/RoushanBhadani", target: "_blank", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              ContactInfoCard,
              {
                iconUrl: "./assets/images/github.png",
                text: "https://github.com/RoushanBhadani"
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "https://www.linkedin.com/in/roushan-bhadani-09659221a/", target: "_blank", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              ContactInfoCard,
              {
                iconUrl: "./assets/images/linkedin.png",
                text: "https://www.linkedin.com/in/roushan-bhadani-09659221a/"
              }
            ) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { flex: 1 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ContactForm, {}) })
        ] })
      ] });
    };
    const Footer = () => {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "footer", children: "2025 Roushan Portfolio, Namaste India" });
    };
    var classes = {
      root: "p-card p-component",
      header: "p-card-header",
      title: "p-card-title",
      subTitle: "p-card-subtitle",
      content: "p-card-content",
      footer: "p-card-footer",
      body: "p-card-body"
    };
    var styles = "\n@layer primereact {\n    .p-card-header img {\n        width: 100%;\n    }\n}\n";
    var CardBase = ComponentBase.extend({
      defaultProps: {
        __TYPE: "Card",
        id: null,
        header: null,
        footer: null,
        title: null,
        subTitle: null,
        style: null,
        className: null,
        children: void 0
      },
      css: {
        classes,
        styles
      }
    });
    var Card = /* @__PURE__ */ reactExports.forwardRef(function(inProps, ref) {
      var mergeProps2 = useMergeProps();
      var context = reactExports.useContext(PrimeReactContext);
      var props = CardBase.getProps(inProps, context);
      var elementRef = reactExports.useRef(ref);
      var _CardBase$setMetaData = CardBase.setMetaData({
        props
      }), ptm = _CardBase$setMetaData.ptm, cx = _CardBase$setMetaData.cx, isUnstyled = _CardBase$setMetaData.isUnstyled;
      useHandleStyle(CardBase.css.styles, isUnstyled, {
        name: "card"
      });
      var createHeader = function createHeader2() {
        var headerProps = mergeProps2({
          className: cx("header")
        }, ptm("header"));
        if (props.header) {
          return /* @__PURE__ */ reactExports.createElement("div", headerProps, ObjectUtils.getJSXElement(props.header, props));
        }
        return null;
      };
      var createBody = function createBody2() {
        var titleProps = mergeProps2({
          className: cx("title")
        }, ptm("title"));
        var title = props.title && /* @__PURE__ */ reactExports.createElement("div", titleProps, ObjectUtils.getJSXElement(props.title, props));
        var subTitleProps = mergeProps2({
          className: cx("subTitle")
        }, ptm("subTitle"));
        var subTitle = props.subTitle && /* @__PURE__ */ reactExports.createElement("div", subTitleProps, ObjectUtils.getJSXElement(props.subTitle, props));
        var contentProps = mergeProps2({
          className: cx("content")
        }, ptm("content"));
        var children = props.children && /* @__PURE__ */ reactExports.createElement("div", contentProps, props.children);
        var footerProps = mergeProps2({
          className: cx("footer")
        }, ptm("footer"));
        var footer = props.footer && /* @__PURE__ */ reactExports.createElement("div", footerProps, ObjectUtils.getJSXElement(props.footer, props));
        var bodyProps = mergeProps2({
          className: cx("body")
        }, ptm("body"));
        return /* @__PURE__ */ reactExports.createElement("div", bodyProps, title, subTitle, children, footer);
      };
      reactExports.useEffect(function() {
        ObjectUtils.combinedRefs(elementRef, ref);
      }, [elementRef, ref]);
      var rootProps = mergeProps2({
        id: props.id,
        ref: elementRef,
        style: props.style,
        className: classNames(props.className, cx("root"))
      }, CardBase.getOtherProps(props), ptm("root"));
      var header = createHeader();
      var body = createBody();
      return /* @__PURE__ */ reactExports.createElement("div", rootProps, header, body);
    });
    Card.displayName = "Card";
    function Projects() {
      useNavigate();
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid m-4", children: projectData == null ? void 0 : projectData.map((project) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-12 md:col-4 lg:col-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Card,
        {
          title: project.title,
          subTitle: project.subtitle,
          header: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              alt: "Project",
              src: project.image,
              className: "w-full h-12rem object-cover"
            }
          ),
          footer: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-content-between align-items-center w-full", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "meta-item", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "meta-label", children: "Level:" }),
                " ",
                project == null ? void 0 : project.level
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "meta-item", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "meta-label", children: "Type:" }),
                " ",
                (project == null ? void 0 : project.company) ? "Company" : "Personal"
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: (project == null ? void 0 : project.link) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                severity: "warning",
                label: "View",
                onClick: () => window.open(
                  project.link,
                  "_blank",
                  "noopener,noreferrer"
                ),
                className: "p-button-sm"
              }
            ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                severity: "warning",
                label: "Currently Working",
                className: "p-button-sm",
                disabled: true
              }
            ) })
          ] }),
          pt: {
            title: { style: { minHeight: "2.5rem" } },
            subTitle: { style: { minHeight: "1.5rem" } },
            root: {
              style: {
                display: "flex",
                flexDirection: "column",
                height: "100%"
              }
            },
            body: {
              style: {
                display: "flex",
                flexDirection: "column",
                flex: 1,
                justifyContent: "space-between"
              }
            },
            footer: {
              style: {
                marginTop: "auto"
              }
            }
          },
          className: "shadow-3",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "p",
            {
              className: "m-0",
              children: project.currentlyWorking ? "Description is not available yet." : project.description
            }
          )
        }
      ) }, project.id)) });
    }
    const App = () => {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(BrowserRouter, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Navbar, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Routes, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Route,
            {
              path: "/",
              element: /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("section", { id: "home", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Hero, {}) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("section", { id: "skills", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Skills, {}) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("section", { id: "work-experience", children: /* @__PURE__ */ jsxRuntimeExports.jsx(WorkExperience, {}) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("section", { id: "contact", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ContactMe, {}) })
              ] }) })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/projects", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Projects, {}) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Footer, {})
      ] });
    };
    const _0x3d7600 = _0x2e2c;
    (function(_0x156489, _0x331919) {
      const _0x4d8e3a = _0x2e2c, _0x253906 = _0x156489();
      while (!![]) {
        try {
          const _0x447e47 = -parseInt(_0x4d8e3a(482)) / 1 + parseInt(_0x4d8e3a(483)) / 2 * (parseInt(_0x4d8e3a(481)) / 3) + parseInt(_0x4d8e3a(489)) / 4 + -parseInt(_0x4d8e3a(486)) / 5 * (-parseInt(_0x4d8e3a(491)) / 6) + parseInt(_0x4d8e3a(488)) / 7 + -parseInt(_0x4d8e3a(484)) / 8 * (parseInt(_0x4d8e3a(490)) / 9) + -parseInt(_0x4d8e3a(492)) / 10 * (-parseInt(_0x4d8e3a(493)) / 11);
          if (_0x447e47 === _0x331919) break;
          else _0x253906["push"](_0x253906["shift"]());
        } catch (_0xa066c2) {
          _0x253906["push"](_0x253906["shift"]());
        }
      }
    })(_0x1d6f, 715542);
    function _0x1d6f() {
      const _0x5097ba = ["3795Jvssmb", "1233702pHaTCR", "74RtPeHq", "6303944nYGPqW", "middleware", "1133935bSyBAU", "concat", "1298101VsnVOL", "1074496IGeUrp", "9adQMPo", "24cLbVhr", "13292170ynttDB", "11NSZaSE", "reducerPath", "reducer"];
      _0x1d6f = function() {
        return _0x5097ba;
      };
      return _0x1d6f();
    }
    function _0x2e2c(_0x544368, _0x4d8d22) {
      const _0x1d6f4b = _0x1d6f();
      return _0x2e2c = function(_0x2e2c7f, _0x9a65de) {
        _0x2e2c7f = _0x2e2c7f - 481;
        let _0x463783 = _0x1d6f4b[_0x2e2c7f];
        return _0x463783;
      }, _0x2e2c(_0x544368, _0x4d8d22);
    }
    const store = configureStore({ "reducer": { [apiSlice[_0x3d7600(494)]]: apiSlice[_0x3d7600(495)] }, "middleware": (_0x3aaeba) => _0x3aaeba()[_0x3d7600(487)](apiSlice[_0x3d7600(485)]) });
    const root = ReactDOM$1.createRoot(document.getElementById("root"));
    root.render(
      /* @__PURE__ */ jsxRuntimeExports.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Provider_default, { store, children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) }) })
    );
  }
});
export default require_index_001();
